# -*- coding: utf-8 -*-
import os
import uuid
import json
import random
import logging
import asyncio
import subprocess
from datetime import datetime, timedelta, timezone
from dotenv import load_dotenv
import discord
import io
import math
try:
    from PIL import Image, ImageDraw, ImageOps, ImageFont  # type: ignore
    PILLOW_AVAILABLE = True
except ImportError:
    PILLOW_AVAILABLE = False
    Image = None
    ImageDraw = None
    ImageOps = None
    ImageFont = None
import aiohttp
import traceback
from discord.ext import commands
from discord import app_commands
from typing import Optional, List, Dict, Tuple, Any
import time

# Load .env
load_dotenv()
TOKEN = os.getenv("DISCORD_TOKEN")
TOKEN_SECONDARY = os.getenv("DISCORD_TOKEN_SECONDARY")
STARTUP_CHANNEL_ID = os.getenv("STARTUP_CHANNEL_ID")  # optional channel ID to announce
BOT_OWNER_ID = os.getenv("BOT_OWNER_ID")  # bot owner ID for admin commands

if not TOKEN:
    raise RuntimeError("DISCORD_TOKEN not found in environment (.env).")

# Optional: secondary bot token for running a paired bot on same host
SECONDARY_BOT_ENABLED = bool(TOKEN_SECONDARY)

# Files & constants (use stable data directory anchored to this file)
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(BASE_DIR, "data")
os.makedirs(DATA_DIR, exist_ok=True)

def _abs_data_path(path: str) -> str:
    # Map any relative filename into the data directory
    return path if os.path.isabs(path) else os.path.join(DATA_DIR, path)

DATA_FILE = os.path.join(DATA_DIR, "economy.json")
MONEY_FILE = os.path.join(DATA_DIR, "user_money.json")
INCOME_FILE = os.path.join(DATA_DIR, "income_roles.json")
STORE_FILE = os.path.join(DATA_DIR, "store.json")
JOBS_FILE = os.path.join(DATA_DIR, "jobs.json")
AUCTIONS_FILE = os.path.join(DATA_DIR, "auctions.json")
LOOT_ROLES_FILE = os.path.join(DATA_DIR, "loot_roles.json")
SECTS_FILE = os.path.join(DATA_DIR, "sects.json")
SECT_SHOP_FILE = os.path.join(DATA_DIR, "sect_shop.json")
CASES_FILE = os.path.join(DATA_DIR, "cases.json")
CASE_ITEMS_FILE = os.path.join(DATA_DIR, "case_items.json")
MARKET_FILE = os.path.join(DATA_DIR, "market.json")
# PARTIES_FILE removed
MONEY_ICON = "<:SpiritStonesPurple:1353660935465599086>"

# -----------------------
# New JSON Data Management System
# -----------------------

# Separate data files for each system
USER_INVENTORIES_FILE = os.path.join(DATA_DIR, "user_inventories.json")
USER_EQUIPMENT_FILE = os.path.join(DATA_DIR, "user_equipment.json")
USER_ATTRIBUTES_FILE = os.path.join(DATA_DIR, "user_attributes.json")
USER_SECTS_FILE = os.path.join(DATA_DIR, "user_sects.json")
USER_JOBS_FILE = os.path.join(DATA_DIR, "user_jobs.json")
USER_IMMORTAL_ARTS_FILE = os.path.join(DATA_DIR, "user_immortal_arts.json")
USER_STATS_FILE = os.path.join(DATA_DIR, "user_stats.json")

# Market reroll cost

# -----------------------
# Ensure JSON files exist
# -----------------------

def ensure_json_files():
    """Create all JSON files if they don't exist"""
    files = [
        USER_INVENTORIES_FILE,
        USER_EQUIPMENT_FILE,
        USER_ATTRIBUTES_FILE,
        USER_SECTS_FILE,
        USER_JOBS_FILE,
        USER_IMMORTAL_ARTS_FILE,
        USER_STATS_FILE
    ]
    for file_path in files:
        if not os.path.exists(file_path):
            save_json(file_path, {})

# -----------------------
# Data Management Functions
# -----------------------

def load_user_inventory(user_id: int) -> list:
    """Load user's inventory from separate file"""
    try:
        data = load_json(USER_INVENTORIES_FILE)
        return data.get(str(user_id), [])
    except:
        return []

def save_user_inventory(user_id: int, inventory: list):
    """Save user's inventory to separate file"""
    try:
        data = load_json(USER_INVENTORIES_FILE)
        print(f"DEBUG: Loaded existing data: {data}")
    except Exception as e:
        data = {}
        print(f"DEBUG: Created new data dict due to error: {e}")
    
    data[str(user_id)] = inventory
    print(f"DEBUG: Updated data: {data}")
    
    save_json(USER_INVENTORIES_FILE, data)
    print(f"DEBUG: Saved inventory for user {user_id}: {len(inventory)} items to {USER_INVENTORIES_FILE}")
    
    # Verify it was saved
    try:
        verify_data = load_json(USER_INVENTORIES_FILE)
        print(f"DEBUG: Verification - loaded data: {verify_data}")
    except Exception as e:
        print(f"DEBUG: Verification failed: {e}")

def load_user_equipment(user_id: int) -> dict:
    """Load user's equipment from separate file"""
    try:
        data = load_json(USER_EQUIPMENT_FILE)
        equipment = data.get(str(user_id), {})
        # Ensure all slots exist
        if "weapon" not in equipment:
            equipment["weapon"] = None
        if "armor" not in equipment:
            equipment["armor"] = None
        if "artifacts" not in equipment:
            equipment["artifacts"] = []
        return equipment
    except:
        return {"weapon": None, "armor": None, "artifacts": []}

def save_user_equipment(user_id: int, equipment: dict):
    """Save user's equipment to separate file"""
    try:
        data = load_json(USER_EQUIPMENT_FILE)
    except:
        data = {}
    data[str(user_id)] = equipment
    save_json(USER_EQUIPMENT_FILE, data)

def load_user_attributes(user_id: int) -> dict:
    """Load user's attributes from separate file"""
    try:
        data = load_json(USER_ATTRIBUTES_FILE)
        attributes = data.get(str(user_id), {})
        # Ensure all attributes exist
        if "strength" not in attributes:
            attributes["strength"] = 0
        if "defence" not in attributes:
            attributes["defence"] = 0
        if "longevity" not in attributes:
            attributes["longevity"] = 0
        if "luck" not in attributes:
            attributes["luck"] = 0
        return attributes
    except:
        return {"strength": 0, "defence": 0, "longevity": 0, "luck": 0}

def save_user_attributes(user_id: int, attributes: dict):
    """Save user's attributes to separate file"""
    try:
        data = load_json(USER_ATTRIBUTES_FILE)
    except:
        data = {}
    data[str(user_id)] = attributes
    save_json(USER_ATTRIBUTES_FILE, data)

def load_user_sect_data(user_id: int) -> dict:
    """Load user's sect data from separate file"""
    try:
        data = load_json(USER_SECTS_FILE)
        sect_data = data.get(str(user_id), {})
        # Ensure all sect fields exist
        if "sect" not in sect_data:
            sect_data["sect"] = None
        if "sect_rank" not in sect_data:
            sect_data["sect_rank"] = None
        if "sect_position" not in sect_data:
            sect_data["sect_position"] = None
        return sect_data
    except:
        return {"sect": None, "sect_rank": None, "sect_position": None}

def save_user_sect_data(user_id: int, sect_data: dict):
    """Save user's sect data to separate file"""
    try:
        data = load_json(USER_SECTS_FILE)
    except:
        data = {}
    data[str(user_id)] = sect_data
    save_json(USER_SECTS_FILE, data)

def load_user_job_data(user_id: int) -> dict:
    """Load user's job data from separate file"""
    try:
        data = load_json(USER_JOBS_FILE)
        job_data = data.get(str(user_id), {})
        # Ensure all job fields exist
        if "job" not in job_data:
            job_data["job"] = None
        if "selected_job" not in job_data:
            job_data["selected_job"] = None
        if "job_rank" not in job_data:
            job_data["job_rank"] = 0
        if "job_experience" not in job_data:
            job_data["job_experience"] = 0
        return job_data
    except:
        return {"job": None, "selected_job": None, "job_rank": 0, "job_experience": 0}

def save_user_job_data(user_id: int, job_data: dict):
    """Save user's job data to separate file"""
    try:
        data = load_json(USER_JOBS_FILE)
    except:
        data = {}
    data[str(user_id)] = job_data
    save_json(USER_JOBS_FILE, data)

def load_user_immortal_arts(user_id: int) -> dict:
    """Load user's immortal arts from separate file"""
    try:
        data = load_json(USER_IMMORTAL_ARTS_FILE)
        arts_data = data.get(str(user_id), {})
        # Ensure all immortal arts fields exist
        if "slots" not in arts_data:
            arts_data["slots"] = [None, None, None]
        if "rerolls" not in arts_data:
            arts_data["rerolls"] = 3
        if "unlocked_slots" not in arts_data:
            arts_data["unlocked_slots"] = 1
        return arts_data
    except:
        return {"slots": [None, None, None], "rerolls": 3, "unlocked_slots": 1}

def save_user_immortal_arts(user_id: int, arts_data: dict):
    """Save user's immortal arts to separate file"""
    try:
        data = load_json(USER_IMMORTAL_ARTS_FILE)
    except:
        data = {}
    data[str(user_id)] = arts_data
    save_json(USER_IMMORTAL_ARTS_FILE, data)

def load_user_stats(user_id: int) -> dict:
    """Load user's stats from separate file"""
    try:
        data = load_json(USER_STATS_FILE)
        stats = data.get(str(user_id), {})
        # Ensure all stat fields exist
        if "cash" not in stats:
            stats["cash"] = 0
        if "bank" not in stats:
            stats["bank"] = 0
        if "last_cultivate" not in stats:
            stats["last_cultivate"] = None
        if "last_collect" not in stats:
            stats["last_collect"] = None
        if "last_job_timestamp" not in stats:
            stats["last_job_timestamp"] = 0
        return stats
    except:
        return {"cash": 0, "bank": 0, "last_cultivate": None, "last_collect": None, "last_job_timestamp": 0}

def save_user_stats(user_id: int, stats: dict):
    """Save user's stats to separate file"""
    try:
        data = load_json(USER_STATS_FILE)
    except:
        data = {}
    data[str(user_id)] = stats
    save_json(USER_STATS_FILE, data)

# -----------------------
# Updated get_user_meta and set_user_meta functions
# -----------------------

def get_user_meta(user_id):
    """Get user metadata - use old system that actually works"""
    try:
        data = load_json(DATA_FILE)
        user_data = data.get(str(user_id), {})
        
        # Ensure all required fields exist
        if "inventory" not in user_data:
            user_data["inventory"] = []
        if "equipment" not in user_data:
            user_data["equipment"] = {"weapon": None, "armor": None, "artifacts": []}
        if "attributes" not in user_data:
            user_data["attributes"] = {"strength": 0, "defence": 0, "longevity": 0, "luck": 0}
        if "immortal_arts" not in user_data:
            user_data["immortal_arts"] = {"slots": [None, None, None], "rerolls": 3, "unlocked_slots": 1}
        if "cash" not in user_data:
            user_data["cash"] = 0
        if "bank" not in user_data:
            user_data["bank"] = 0
        
        return user_data
        
    except Exception as e:
        print(f"ERROR in get_user_meta for user {user_id}: {e}")
        # Return safe defaults if everything fails
        return {
            "inventory": [],
            "equipment": {"weapon": None, "armor": None, "artifacts": []},
            "attributes": {"strength": 0, "defence": 0, "longevity": 0, "luck": 0},
            "sect": None,
            "sect_rank": None,
            "sect_position": None,
            "job": None,
            "selected_job": None,
            "job_rank": 0,
            "job_experience": 0,
            "immortal_arts": {"slots": [None, None, None], "rerolls": 3, "unlocked_slots": 1},
            "cash": 0,
            "bank": 0,
            "last_cultivate": None,
            "last_collect": None,
            "last_job_timestamp": 0
        }

def set_user_meta(user_id, meta: dict):
    """Set user metadata - use old system that actually works"""
    try:
        # Save to old system (the one that actually works)
        old_data = load_json(DATA_FILE)
        old_data[str(user_id)] = meta
        
        # Check if save was successful
        if not save_json(DATA_FILE, old_data):
            print(f"WARNING: Failed to save data for user {user_id}")
            return False
            
        return True
        
    except Exception as e:
        print(f"ERROR in set_user_meta for user {user_id}: {e}")
        return False

# -----------------------
# Legacy compatibility functions (for existing code)
# -----------------------

def get_balances(user_id):
    """Get user's cash and bank balance"""
    stats = load_user_stats(user_id)
    return stats.get("cash", 0), stats.get("bank", 0)

def add_cash(user_id, amount):
    """Add/subtract cash from user with automatic debt collection"""
    stats = load_user_stats(user_id)
    current_cash = stats.get("cash", 0)
    
    # If user is in debt (negative balance) and getting positive money
    if current_cash < 0 and amount > 0:
        # Check if they have active loans
        loans = load_loans()
        active_loans = [loan for loan in loans.values() 
                        if loan["borrower_id"] == user_id and loan["status"] == "active"]
        
        if active_loans:
            # User has debt, money goes to loan shark(s)
            remaining_amount = amount
            for loan in active_loans:
                if remaining_amount <= 0:
                    break
                    
                lender_id = loan["lender_id"]
                remaining_debt = loan["total_to_repay"] - loan.get("amount_paid", 0)
                
                if remaining_debt > 0:
                    # Calculate how much to pay on this loan
                    payment_amount = min(remaining_amount, remaining_debt)
                    
                    # Process the payment
                    success, _ = process_loan_payment(loan["loan_name"], payment_amount)
                    if success:
                        # Give money to the loan shark
                        lender_stats = load_user_stats(lender_id)
                        lender_stats["cash"] = lender_stats.get("cash", 0) + payment_amount
                        save_user_stats(lender_id, lender_stats)
                        
                        remaining_amount -= payment_amount
                        print(f"DEBUG: Collected {payment_amount} from {user_id} for loan {loan['loan_name']}, gave to lender {lender_id}")
            
            # If there's money left after paying debts, user gets it
            if remaining_amount > 0:
                stats["cash"] = current_cash + remaining_amount
                print(f"DEBUG: User {user_id} gets remaining {remaining_amount} after debt payment")
            else:
                # All money went to debt, user stays in negative
                stats["cash"] = current_cash
                print(f"DEBUG: All money from {user_id} went to debt payment")
        else:
            # No active loans, normal behavior
            stats["cash"] = current_cash + amount
    else:
        # Normal case - no debt or negative amount
        stats["cash"] = max(0, current_cash + amount)
    
    save_user_stats(user_id, stats)
    
    # Track wealth quest progress when money is added (positive amounts only)
    if amount > 0:
        try:
            check_wealth_quest_progress(user_id, amount)
        except Exception as e:
            print(f"DEBUG: Error tracking wealth quest progress in add_cash: {e}")

def set_cash(user_id, amount):
    """Set user's cash amount"""
    stats = load_user_stats(user_id)
    stats["cash"] = max(0, amount)
    save_user_stats(user_id, stats)

def set_bank(user_id, amount):
    """Set user's bank amount"""
    stats = load_user_stats(user_id)
    stats["bank"] = max(0, amount)
    save_user_stats(user_id, stats)

def get_user_sect_and_boost(user_id):
    """Get user's sect name and boost percentage"""
    sect_data = load_user_sect_data(user_id)
    sect_name = sect_data.get("sect")
    
    if not sect_name:
        return None, 0
    
    # Load sect data to get boost
    sects = load_json(SECTS_FILE)
    if sect_name in sects:
        sect = sects[sect_name]
        # Calculate boost based on sect rank
        rank = sect_data.get("sect_rank", "outer disciple")
        if rank == "sect leader":
            return sect_name, 20
        elif rank == "elder":
            return sect_name, 15
        elif rank == "inner disciple":
            return sect_name, 10
        else:  # outer disciple
            return sect_name, 5
    
    return sect_name, 0

def ensure_file(file_path: str, default_content: Any):
    """Ensure a file exists with default content if it doesn't"""
    if not os.path.exists(file_path):
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(default_content, f, indent=4)

# Initialize all data files if they don't exist
ensure_file(USER_INVENTORIES_FILE, {})
ensure_file(USER_EQUIPMENT_FILE, {})
ensure_file(USER_ATTRIBUTES_FILE, {})
ensure_file(USER_SECTS_FILE, {})
ensure_file(USER_JOBS_FILE, {})
ensure_file(USER_IMMORTAL_ARTS_FILE, {})
ensure_file(USER_STATS_FILE, {})

# -----------------------
# JSON System (Lightweight)
# -----------------------

def debug_user_data(user_id: int):
    """Debug function to check user data in all files"""
    print(f"=== Debugging user {user_id} ===")
    
    try:
        inventory = load_user_inventory(user_id)
        print(f"Inventory: {len(inventory)} items")
    except Exception as e:
        print(f"Inventory error: {e}")
    
    try:
        equipment = load_user_equipment(user_id)
        print(f"Equipment: {equipment}")
    except Exception as e:
        print(f"Equipment error: {e}")
    
    try:
        attributes = load_user_attributes(user_id)
        print(f"Attributes: {attributes}")
    except Exception as e:
        print(f"Attributes error: {e}")
    
    try:
        sect_data = load_user_sect_data(user_id)
        print(f"Sect data: {sect_data}")
    except Exception as e:
        print(f"Sect data error: {e}")
    
    try:
        job_data = load_user_job_data(user_id)
        print(f"Job data: {job_data}")
    except Exception as e:
        print(f"Job data error: {e}")
    
    try:
        immortal_arts = load_user_immortal_arts(user_id)
        print(f"Immortal arts: {immortal_arts}")
    except Exception as e:
        print(f"Immortal arts error: {e}")
    
    try:
        stats = load_user_stats(user_id)
        print(f"Stats: {stats}")
    except Exception as e:
        print(f"Stats error: {e}")
    
    print("=== End Debug ===")

# -----------------------
# Data Migration System
# -----------------------

def migrate_user_data_to_new_system(user_id: int):
    """Migrate user data from old system to new separate files"""
    try:
        # Try to load from old system first
        old_data = {}
        try:
            old_data = load_json(DATA_FILE).get(str(user_id), {})
        except:
            pass
        
        if not old_data:
            return False  # No old data to migrate
        
        # Migrate inventory
        if "inventory" in old_data:
            save_user_inventory(user_id, old_data["inventory"])
        
        # Migrate equipment
        if "equipment" in old_data:
            save_user_equipment(user_id, old_data["equipment"])
        
        # Migrate attributes
        if "attributes" in old_data:
            save_user_attributes(user_id, old_data["attributes"])
        
        # Migrate sect data
        if "sect" in old_data or "sect_rank" in old_data:
            sect_data = {
                "sect": old_data.get("sect"),
                "sect_rank": old_data.get("sect_rank"),
                "sect_position": old_data.get("sect_position")
            }
            save_user_sect_data(user_id, sect_data)
        
        # Migrate job data
        if "job" in old_data or "selected_job" in old_data:
            job_data = {
                "job": old_data.get("job"),
                "selected_job": old_data.get("selected_job"),
                "job_rank": old_data.get("job_rank", 0),
                "job_experience": old_data.get("job_experience", 0)
            }
            save_user_job_data(user_id, job_data)
        
        # Migrate immortal arts
        if "immortal_arts" in old_data:
            save_user_immortal_arts(user_id, old_data["immortal_arts"])
        
        # Migrate stats
        stats = {
            "cash": old_data.get("cash", 0),
            "bank": old_data.get("bank", 0),
            "last_cultivate": old_data.get("last_cultivate"),
            "last_collect": old_data.get("last_collect"),
            "last_job_timestamp": old_data.get("last_job_timestamp", 0)
        }
        save_user_stats(user_id, stats)
        
        return True
        
    except Exception as e:
        print(f"Error migrating data for user {user_id}: {e}")
        return False

def get_user_meta_with_migration(user_id):
    """Get user metadata with automatic migration from old system"""
    # First try to get from new system
    try:
        # Load from all separate files
        inventory = load_user_inventory(user_id)
        equipment = load_user_equipment(user_id)
        attributes = load_user_attributes(user_id)
        sect_data = load_user_sect_data(user_id)
        job_data = load_user_job_data(user_id)
        immortal_arts = load_user_immortal_arts(user_id)
        stats = load_user_stats(user_id)
        
        # Combine into one metadata object
        new_meta = {
            "inventory": inventory,
            "equipment": equipment,
            "attributes": attributes,
            "sect": sect_data["sect"],
            "sect_rank": sect_data["sect_rank"],
            "sect_position": sect_data["sect_position"],
            "job": job_data["job"],
            "selected_job": job_data["selected_job"],
            "job_rank": job_data["job_rank"],
            "job_experience": job_data["job_experience"],
            "immortal_arts": immortal_arts,
            "cash": stats["cash"],
            "bank": stats["bank"],
            "last_cultivate": stats["last_cultivate"],
            "last_collect": stats["last_collect"],
            "last_job_timestamp": stats["last_job_timestamp"]
        }
        
        # Check if we have any real data (not just defaults)
        if new_meta.get("inventory") or new_meta.get("cash") > 0 or new_meta.get("sect"):
            return new_meta
    except Exception as e:
        print(f"Error loading from new system for user {user_id}: {e}")
    
    # If no data in new system, try to migrate from old system
    if migrate_user_data_to_new_system(user_id):
        # Try to load again after migration
        try:
            inventory = load_user_inventory(user_id)
            equipment = load_user_equipment(user_id)
            attributes = load_user_attributes(user_id)
            sect_data = load_user_sect_data(user_id)
            job_data = load_user_job_data(user_id)
            immortal_arts = load_user_immortal_arts(user_id)
            stats = load_user_stats(user_id)
            
            return {
                "inventory": inventory,
                "equipment": equipment,
                "attributes": attributes,
                "sect": sect_data["sect"],
                "sect_rank": sect_data["sect_rank"],
                "sect_position": sect_data["sect_position"],
                "job": job_data["job"],
                "selected_job": job_data["selected_job"],
                "job_rank": job_data["job_rank"],
                "job_experience": job_data["job_experience"],
                "immortal_arts": immortal_arts,
                "cash": stats["cash"],
                "bank": stats["bank"],
                "last_cultivate": stats["last_cultivate"],
                "last_collect": stats["last_collect"],
                "last_job_timestamp": stats["last_job_timestamp"]
            }
        except Exception as e:
            print(f"Error loading after migration for user {user_id}: {e}")
    
    # Return defaults if everything fails
    return {
        "inventory": [],
        "equipment": {"weapon": None, "armor": None, "artifacts": []},
        "attributes": {"strength": 0, "defence": 0, "longevity": 0, "luck": 0},
        "sect": None,
        "sect_rank": None,
        "sect_position": None,
        "job": None,
        "selected_job": None,
        "job_rank": 0,
        "job_experience": 0,
        "immortal_arts": {"slots": [None, None, None], "rerolls": 3, "unlocked_slots": 1},
        "cash": 0,
        "bank": 0,
        "last_cultivate": None,
        "last_collect": None,
        "last_job_timestamp": 0
    }


# Tournament files/constants
TOURNAMENTS_FILE = os.path.join(DATA_DIR, "tournaments.json")
LOAN_OFFERS_FILE = os.path.join(DATA_DIR, "loan_offers.json")
TOURNAMENT_EMOJI = "🏆"
TOURNAMENT_COLOR = 0x9b59b6

# -----------------------
# Ore System
# -----------------------
ORE_TYPES = {
    "common": ["Iron Ore", "Copper Ore", "Tin Ore", "Coal Ore", "Stone Ore"],
    "uncommon": ["Silver Ore", "Gold Ore", "Bronze Ore", "Steel Ore", "Mithril Ore"],
    "rare": ["Platinum Ore", "Titanium Ore", "Cobalt Ore", "Nickel Ore", "Chromium Ore"],
    "epic": ["Tungsten Ore", "Vanadium Ore", "Molybdenum Ore", "Niobium Ore", "Tantalum Ore"],
    "legendary": ["Adamantium Ore", "Vibranium Ore", "Uru Ore", "Orichalcum Ore", "Meteoric Ore"],
    "mythic": ["Celestial Ore", "Void Ore", "Ethereal Ore", "Quantum Ore", "Dimensional Ore"],
    "divine": ["Divine Essence", "Heavenly Core", "Godly Fragment", "Transcendent Shard", "Omnipotent Crystal"]
}

ORE_RARITY_WEIGHTS = {
    "common": 70,      # 70% chance - very common (increased)
    "uncommon": 25,    # 25% chance - common (kept same)
    "rare": 4,         # 4% chance - uncommon (reduced from 10%)
    "epic": 1.5,       # 1.5% chance - epic (new tier)
    "legendary": 0.8,  # 0.8% chance - rare (reduced from 3%)
    "mythic": 0.001,   # 0.001% chance - ALMOST IMPOSSIBLE
    "divine": 0.0001   # 0.0001% chance - IMPOSSIBLE
}

# -----------------------
# Market System Constants
# -----------------------
MARKET_RARITY_WEIGHTS = {
    "common": 45,      # 45% chance - almost always found
    "uncommon": 35,    # 35% chance - very common
    "rare": 15,        # 15% chance - common
    "epic": 8,         # 8% chance - epic (new tier)
    "legendary": 4,    # 4% chance - normal
    "mythic": 0.001,  # 0.001% chance - ALMOST IMPOSSIBLE
    "divine": 0.0001  # 0.0001% chance - IMPOSSIBLE
}

# Market item types and their base costs - Properly balanced by rarity
MARKET_ITEM_TYPES = {
    "weapon": {
        "common": 10000,        # 10K - Basic weapons
        "uncommon": 100000,     # 100K - Improved weapons
        "rare": 1000000,        # 1M - Rare weapons
        "epic": 5000000,        # 5M - Epic weapons (new tier)
        "legendary": 10000000,  # 10M - Legendary weapons
        "mythic": 100000000,    # 100M - Mythic weapons
        "divine": 1000000000    # 1B - Divine weapons
    },
    "armor": {
        "common": 8000,         # 8K - Basic armor
        "uncommon": 80000,      # 80K - Improved armor
        "rare": 800000,         # 800K - Rare armor
        "epic": 4000000,        # 4M - Epic armor (new tier)
        "legendary": 8000000,   # 8M - Legendary armor
        "mythic": 80000000,     # 80M - Mythic armor
        "divine": 800000000     # 800M - Divine armor
    },
    "artifact": {
        "common": 15000,        # 15K - Basic artifacts
        "uncommon": 150000,     # 150K - Improved artifacts
        "rare": 1500000,        # 1.5M - Rare artifacts
        "epic": 7500000,        # 7.5M - Epic artifacts (new tier)
        "legendary": 15000000,  # 15M - Legendary artifacts
        "mythic": 150000000,    # 150M - Mythic artifacts
        "divine": 1500000000    # 1.5B - Divine artifacts
    },
    "ore": {
        "common": 5000,         # 5K - Basic ore
        "uncommon": 50000,      # 50K - Improved ore
        "rare": 500000,         # 500K - Rare ore
        "epic": 2500000,        # 2.5M - Epic ore (new tier)
        "legendary": 5000000,   # 5M - Legendary ore
        "mythic": 50000000,     # 50M - Mythic ore
        "divine": 500000000     # 500M - Divine ore
    },
    "loot": {
        "common": 3000,         # 3K - Basic loot
        "uncommon": 30000,      # 30K - Improved loot
        "rare": 300000,         # 300K - Rare loot
        "epic": 1500000,        # 1.5M - Epic loot (new tier)
        "legendary": 3000000,   # 3M - Legendary loot
        "mythic": 30000000,     # 30M - Mythic loot
        "divine": 300000000     # 300M - Divine loot
    },
    "consumable": {
        "common": 2000,         # 2K - Basic consumables
        "uncommon": 20000,      # 20K - Improved consumables
        "rare": 200000,         # 200K - Rare consumables
        "epic": 1000000,        # 1M - Epic consumables (new tier)
        "legendary": 2000000,   # 2M - Legendary consumables
        "mythic": 20000000,     # 20M - Mythic consumables
        "divine": 200000000     # 200M - Divine consumables
    }
}

# Bonus effects for legendary+ items and artifacts - Balanced and fair
ITEM_BONUS_EFFECTS = {
    "weapon": {
        "legendary": {
            "damage_boost": 8,
            "critical_chance": 5,
            "work_income_boost": 8,
            "blackjack_boost": 6,
            "roulette_boost": 4,
            "luck_boost": 3,
            "cultivation_boost": 6,
            "xp_boost": 4,
            "passive_income": 50,
            "description": "⚔️ +8 damage, +5% critical chance, +8% work income, +6% blackjack payout, +4% roulette, +3% luck, +6% cultivation, +4% XP gain, +50 daily income"
        },
        "mythic": {
            "damage_boost": 15,
            "critical_chance": 8,
            "lifesteal": 3,
            "work_income_boost": 12,
            "blackjack_boost": 10,
            "roulette_boost": 8,
            "shop_discount": 5,
            "luck_boost": 5,
            "cultivation_boost": 10,
            "xp_boost": 8,
            "passive_income": 100,
            "description": "⚔️ +15 damage, +8% critical chance, +3% lifesteal, +12% work income, +10% blackjack, +8% roulette, -5% shop prices, +5% luck, +10% cultivation, +8% XP gain, +100 daily income"
        },
        "divine": {
            "damage_boost": 25,
            "critical_chance": 12,
            "lifesteal": 5,
            "armor_penetration": 10,
            "work_income_boost": 18,
            "blackjack_boost": 15,
            "roulette_boost": 12,
            "shop_discount": 8,
            "sell_bonus": 10,
            "luck_boost": 8,
            "cultivation_boost": 15,
            "xp_boost": 12,
            "passive_income": 200,
            "description": "⚔️ +25 damage, +12% critical chance, +5% lifesteal, +10% armor penetration, +18% work income, +15% blackjack, +12% roulette, -8% shop prices, +10% sell prices, +8% luck, +15% cultivation, +12% XP gain, +200 daily income"
        }
    },
    "armor": {
        "legendary": {
            "defense_boost": 12,
            "damage_reduction": 6,
            "work_cooldown_reduction": 8,
            "cultivation_boost": 8,
            "luck_boost": 5,
            "work_income_boost": 6,
            "blackjack_boost": 5,
            "roulette_boost": 4,
            "xp_boost": 5,
            "passive_income": 75,
            "description": "🛡️ +12 defense, +6% damage reduction, -8% work cooldown, +8% cultivation, +5% luck, +6% work income, +5% blackjack, +4% roulette, +5% XP gain, +75 daily income"
        },
        "mythic": {
            "defense_boost": 20,
            "damage_reduction": 10,
            "health_boost": 8,
            "work_cooldown_reduction": 12,
            "cultivation_boost": 12,
            "roulette_boost": 8,
            "luck_boost": 8,
            "work_income_boost": 10,
            "blackjack_boost": 8,
            "xp_boost": 8,
            "passive_income": 150,
            "description": "🛡️ +20 defense, +10% damage reduction, +8% health, -12% work cooldown, +12% cultivation, +8% roulette, +8% luck, +10% work income, +8% blackjack, +8% XP gain, +150 daily income"
        },
        "divine": {
            "defense_boost": 30,
            "damage_reduction": 15,
            "health_boost": 15,
            "immunity_chance": 3,
            "work_cooldown_reduction": 18,
            "cultivation_boost": 18,
            "roulette_boost": 12,
            "gambling_loss_reduction": 10,
            "luck_boost": 12,
            "work_income_boost": 15,
            "xp_boost": 10,
            "blackjack_boost": 8,
            "passive_income": 300,
            "description": "🛡️ +30 defense, +15% damage reduction, +15% health, +3% immunity chance, -18% work cooldown, +18% cultivation, +12% roulette, +10% gambling loss reduction, +12% luck, +15% work income, +10% XP gain, +8% blackjack, +300 daily income"
        }
    },
    "artifact": {
        "legendary": {
            "all_stats": 6,
            "work_income_boost": 12,
            "blackjack_boost": 10,
            "roulette_boost": 8,
            "shop_discount": 8,
            "luck_boost": 5,
            "cultivation_boost": 8,
            "xp_boost": 6,
            "passive_income": 100,
            "description": "✨ +6 to all stats, +12% work income, +10% blackjack payout, +8% roulette, -8% shop prices, +5% luck, +8% cultivation, +6% XP gain, +100 daily income"
        },
        "mythic": {
            "all_stats": 12,
            "work_income_boost": 20,
            "blackjack_boost": 18,
            "roulette_boost": 12,
            "shop_discount": 12,
            "sell_bonus": 10,
            "luck_boost": 8,
            "cultivation_boost": 12,
            "xp_boost": 10,
            "passive_income": 200,
            "description": "✨ +12 to all stats, +20% work income, +18% blackjack payout, +12% roulette, -12% shop prices, +10% sell prices, +8% luck, +12% cultivation, +10% XP gain, +200 daily income"
        },
        "divine": {
            "all_stats": 20,
            "work_income_boost": 30,
            "blackjack_boost": 25,
            "roulette_boost": 18,
            "shop_discount": 18,
            "sell_bonus": 15,
            "luck_boost": 12,
            "cultivation_boost": 18,
            "xp_boost": 15,
            "passive_income": 400,
            "description": "✨ +20 to all stats, +30% work income, +25% blackjack payout, +18% roulette, -18% shop prices, +15% sell prices, +12% luck, +18% cultivation, +15% XP gain, +400 daily income"
        }
    }
}

def apply_item_bonus_effects(item: dict) -> dict:
    """Apply bonus effects to legendary+ items and artifacts"""
    item_type = item.get("type")
    rarity = item.get("rarity")
    
    # Only apply bonuses to legendary+ items and artifacts
    if rarity not in ["legendary", "mythic", "divine"] or item_type not in ITEM_BONUS_EFFECTS:
        return item
    
    # Get bonus effects for this item type and rarity
    bonus_effects = ITEM_BONUS_EFFECTS[item_type][rarity]
    
    # Apply weapon bonuses
    if item_type == "weapon":
        if "damage_boost" in bonus_effects:
            item["damage"] = item.get("damage", 0) + bonus_effects["damage_boost"]
        if "critical_chance" in bonus_effects:
            item["critical_chance"] = bonus_effects["critical_chance"]
        if "lifesteal" in bonus_effects:
            item["lifesteal"] = bonus_effects["lifesteal"]
        if "armor_penetration" in bonus_effects:
            item["armor_penetration"] = bonus_effects["armor_penetration"]
        if "work_income_boost" in bonus_effects:
            item["work_income_boost"] = bonus_effects["work_income_boost"]
        if "blackjack_boost" in bonus_effects:
            item["blackjack_boost"] = bonus_effects["blackjack_boost"]
        if "roulette_boost" in bonus_effects:
            item["roulette_boost"] = bonus_effects["roulette_boost"]
        if "shop_discount" in bonus_effects:
            item["shop_discount"] = bonus_effects["shop_discount"]
        if "sell_bonus" in bonus_effects:
            item["sell_bonus"] = bonus_effects["sell_bonus"]
        if "passive_income" in bonus_effects:
            item["passive_income"] = bonus_effects["passive_income"]
        if "luck_boost" in bonus_effects:
            item["luck_boost"] = bonus_effects["luck_boost"]
        if "cultivation_boost" in bonus_effects:
            item["cultivation_boost"] = bonus_effects["cultivation_boost"]
        if "xp_boost" in bonus_effects:
            item["xp_boost"] = bonus_effects["xp_boost"]
    
    # Apply armor bonuses
    elif item_type == "armor":
        if "defense_boost" in bonus_effects:
            item["defense"] = item.get("defense", 0) + bonus_effects["defense_boost"]
        if "damage_reduction" in bonus_effects:
            item["damage_reduction"] = bonus_effects["damage_reduction"]
        if "health_boost" in bonus_effects:
            item["health_boost"] = bonus_effects["health_boost"]
        if "immunity_chance" in bonus_effects:
            item["immunity_chance"] = bonus_effects["immunity_chance"]
        if "work_cooldown_reduction" in bonus_effects:
            item["work_cooldown_reduction"] = bonus_effects["work_cooldown_reduction"]
        if "cultivation_boost" in bonus_effects:
            item["cultivation_boost"] = bonus_effects["cultivation_boost"]
        if "roulette_boost" in bonus_effects:
            item["roulette_boost"] = bonus_effects["roulette_boost"]
        if "gambling_loss_reduction" in bonus_effects:
            item["gambling_loss_reduction"] = bonus_effects["gambling_loss_reduction"]
        if "passive_income" in bonus_effects:
            item["passive_income"] = bonus_effects["passive_income"]
        if "luck_boost" in bonus_effects:
            item["luck_boost"] = bonus_effects["luck_boost"]
        if "work_income_boost" in bonus_effects:
            item["work_income_boost"] = bonus_effects["work_income_boost"]
        if "xp_boost" in bonus_effects:
            item["xp_boost"] = bonus_effects["xp_boost"]
        if "blackjack_boost" in bonus_effects:
            item["blackjack_boost"] = bonus_effects["blackjack_boost"]
    
    # Apply artifact bonuses (biggest bonuses)
    elif item_type == "artifact":
        if "all_stats" in bonus_effects:
            item["all_stats_boost"] = bonus_effects["all_stats"]
        if "work_income_boost" in bonus_effects:
            item["work_income_boost"] = bonus_effects["work_income_boost"]
        if "blackjack_boost" in bonus_effects:
            item["blackjack_boost"] = bonus_effects["blackjack_boost"]
        if "roulette_boost" in bonus_effects:
            item["roulette_boost"] = bonus_effects["roulette_boost"]
        if "shop_discount" in bonus_effects:
            item["shop_discount"] = bonus_effects["shop_discount"]
        if "sell_bonus" in bonus_effects:
            item["sell_bonus"] = bonus_effects["sell_bonus"]
        if "passive_income" in bonus_effects:
            item["passive_income"] = bonus_effects["passive_income"]
        if "luck_boost" in bonus_effects:
            item["luck_boost"] = bonus_effects["luck_boost"]
        if "cultivation_boost" in bonus_effects:
            item["cultivation_boost"] = bonus_effects["cultivation_boost"]
        if "xp_boost" in bonus_effects:
            item["xp_boost"] = bonus_effects["xp_boost"]
    
    # Add bonus description
    item["bonus_description"] = bonus_effects["description"]
    
    return item

def calculate_passive_effects(user_id: int) -> dict:
    """Calculate passive effects from equipped items (income, etc.)"""
    try:
        equipment = get_user_equipment(user_id)
        if not isinstance(equipment, dict):
            print(f"DEBUG: Invalid equipment for user {user_id}: {equipment}")
            equipment = {}
        
        passive_effects = {
            "passive_income": 0,
            "work_income_boost": 0,
            "blackjack_boost": 0,
            "shop_discount": 0,
            "sell_bonus": 0,
            "work_cooldown_reduction": 0,
            "cultivation_boost": 0,
            "roulette_boost": 0,
            "gambling_loss_reduction": 0,
            "xp_boost": 0,
            "luck_boost": 0
        }
        
        # Check weapon for passive effects
        if equipment.get("weapon") and isinstance(equipment["weapon"], dict):
            weapon = equipment["weapon"]
            if "passive_income" in weapon:
                passive_effects["passive_income"] += weapon["passive_income"]
            if "work_income_boost" in weapon:
                passive_effects["work_income_boost"] += weapon["work_income_boost"]
            if "blackjack_boost" in weapon:
                passive_effects["blackjack_boost"] += weapon["blackjack_boost"]
            if "shop_discount" in weapon:
                passive_effects["shop_discount"] += weapon["shop_discount"]
            if "sell_bonus" in weapon:
                passive_effects["sell_bonus"] += weapon["sell_bonus"]
            if "luck_boost" in weapon:
                passive_effects["luck_boost"] += weapon["luck_boost"]
            if "cultivation_boost" in weapon:
                passive_effects["cultivation_boost"] += weapon["cultivation_boost"]
            if "xp_boost" in weapon:
                passive_effects["xp_boost"] += weapon["xp_boost"]
            if "roulette_boost" in weapon:
                passive_effects["roulette_boost"] += weapon["roulette_boost"]
        
        # Check armor for passive effects
        if equipment.get("armor") and isinstance(equipment["armor"], dict):
            armor = equipment["armor"]
            if "passive_income" in armor:
                passive_effects["passive_income"] += armor["passive_income"]
            if "work_cooldown_reduction" in armor:
                passive_effects["work_cooldown_reduction"] += armor["work_cooldown_reduction"]
            if "cultivation_boost" in armor:
                passive_effects["cultivation_boost"] += armor["cultivation_boost"]
            if "roulette_boost" in armor:
                passive_effects["roulette_boost"] += armor["roulette_boost"]
            if "gambling_loss_reduction" in armor:
                passive_effects["gambling_loss_reduction"] += armor["gambling_loss_reduction"]
            if "luck_boost" in armor:
                passive_effects["luck_boost"] += armor["luck_boost"]
            if "work_income_boost" in armor:
                passive_effects["work_income_boost"] += armor["work_income_boost"]
            if "xp_boost" in armor:
                passive_effects["xp_boost"] += armor["xp_boost"]
            if "blackjack_boost" in armor:
                passive_effects["blackjack_boost"] += armor["blackjack_boost"]
        
        # Check artifacts for passive effects (biggest bonuses)
        if equipment.get("artifacts") and isinstance(equipment["artifacts"], list):
            for artifact in equipment["artifacts"]:
                if isinstance(artifact, dict):
                    if "passive_income" in artifact:
                        passive_effects["passive_income"] += artifact["passive_income"]
                    if "work_income_boost" in artifact:
                        passive_effects["work_income_boost"] += artifact["work_income_boost"]
                    if "blackjack_boost" in artifact:
                        passive_effects["blackjack_boost"] += artifact["blackjack_boost"]
                    if "shop_discount" in artifact:
                        passive_effects["shop_discount"] += artifact["shop_discount"]
                    if "sell_bonus" in artifact:
                        passive_effects["sell_bonus"] += artifact["sell_bonus"]
                    if "roulette_boost" in artifact:
                        passive_effects["roulette_boost"] += artifact["roulette_boost"]
        
        return passive_effects
    except Exception as e:
        print(f"ERROR in calculate_passive_effects for user {user_id}: {e}")
        return {
            "passive_income": 0,
            "work_income_boost": 0,
            "blackjack_boost": 0,
            "shop_discount": 0,
            "sell_bonus": 0,
            "work_cooldown_reduction": 0,
            "cultivation_boost": 0,
            "roulette_boost": 0,
            "gambling_loss_reduction": 0,
            "xp_boost": 0,
            "luck_boost": 0
        }

# Market item names by type and rarity
MARKET_ITEM_NAMES = {
    "weapon": {
        "common": ["Rusty Sword", "Wooden Staff", "Stone Axe", "Bone Dagger", "Copper Spear"],
        "uncommon": ["Iron Sword", "Steel Staff", "Iron Axe", "Steel Dagger", "Iron Spear"],
        "rare": ["Steel Sword", "Silver Staff", "Steel Axe", "Silver Dagger", "Steel Spear"],
        "epic": ["Tungsten Sword", "Platinum Staff", "Tungsten Axe", "Platinum Dagger", "Tungsten Spear"],
        "legendary": ["Mythril Sword", "Gold Staff", "Mythril Axe", "Gold Dagger", "Mythril Spear"],
        "mythic": ["Adamantium Sword", "Platinum Staff", "Adamantium Axe", "Platinum Dagger", "Adamantium Spear"],
        "divine": ["Divine Blade", "Celestial Staff", "Divine Axe", "Celestial Dagger", "Divine Spear"]
    },
    "armor": {
        "common": ["Leather Armor", "Cloth Robe", "Wooden Shield", "Straw Hat", "Rope Belt"],
        "uncommon": ["Chainmail", "Silk Robe", "Iron Shield", "Leather Hat", "Leather Belt"],
        "rare": ["Steel Plate", "Mage Robe", "Steel Shield", "Steel Helmet", "Steel Belt"],
        "epic": ["Tungsten Plate", "Enchanted Robe", "Tungsten Shield", "Tungsten Helmet", "Tungsten Belt"],
        "legendary": ["Mythril Plate", "Royal Robe", "Mythril Shield", "Royal Crown", "Royal Belt"],
        "mythic": ["Adamantium Plate", "Mystic Robe", "Adamantium Shield", "Mystic Crown", "Mystic Belt"],
        "divine": ["Divine Armor", "Celestial Robe", "Divine Shield", "Celestial Crown", "Divine Belt"]
    },
    "artifact": {
        "common": ["Lucky Charm", "Healing Stone", "Light Crystal", "Wind Feather", "Earth Fragment"],
        "uncommon": ["Fortune Ring", "Life Stone", "Fire Crystal", "Storm Feather", "Mountain Fragment"],
        "rare": ["Destiny Ring", "Immortality Stone", "Thunder Crystal", "Hurricane Feather", "Volcano Fragment"],
        "epic": ["Fate Ring", "Eternal Stone", "Lightning Crystal", "Tornado Feather", "Earthquake Fragment"],
        "legendary": ["Destiny Ring", "Immortality Stone", "Thunder Crystal", "Hurricane Feather", "Volcano Fragment"],
        "mythic": ["Time Ring", "Infinite Stone", "Cosmic Crystal", "Space Feather", "Reality Fragment"],
        "divine": ["Creation Ring", "Omnipotent Stone", "Divine Crystal", "God Feather", "Universe Fragment"]
    },
    "loot": {
        "common": ["Ancient Coin", "Mystic Fragment", "Enchanted Dust", "Spirit Essence", "Crystal Shard"],
        "uncommon": ["Rare Gem", "Mystic Orb", "Enchanted Crystal", "Spirit Core", "Ancient Relic"],
        "rare": ["Legendary Relic", "Mystic Artifact", "Enchanted Gem", "Spirit Crystal", "Ancient Artifact"],
        "epic": ["Mythic Relic", "Divine Fragment", "Enchanted Artifact", "Spirit Relic", "Ancient Treasure"],
        "legendary": ["Legendary Relic", "Mystic Artifact", "Enchanted Gem", "Spirit Crystal", "Ancient Artifact"],
        "mythic": ["Divine Relic", "Cosmic Fragment", "Enchanted Relic", "Spirit Treasure", "Ancient Power"],
        "divine": ["Omnipotent Relic", "Universal Fragment", "Enchanted Power", "Spirit Power", "Ancient Essence"]
    },
    "consumable": {
        "common": ["Basic Healing Potion", "Simple Mana Elixir", "Weak Strength Tonic", "Minor Luck Charm"],
        "uncommon": ["Healing Elixir", "Mana Potion", "Strength Tonic", "Luck Charm", "Speed Draught"],
        "rare": ["Greater Healing Elixir", "Pure Mana Potion", "Mighty Strength Tonic", "Greater Luck Charm"],
        "epic": ["Supreme Healing Elixir", "Ultimate Strength Tonic", "Legendary Luck Charm"],
        "legendary": ["Greater Healing Elixir", "Pure Mana Potion", "Mighty Strength Tonic", "Greater Luck Charm"],
        "mythic": ["Cosmic Healing Elixir", "Infinite Mana Potion", "Eternal Strength Tonic", "Mythic Luck Charm"],
        "divine": ["Omnipotent Healing Elixir", "Universal Mana Potion", "Absolute Strength Tonic", "Divine Luck Charm"]
    }
}



def ensure_market_exists():
    """Ensure market data exists, create if it doesn't"""
    # Initialize the global market system
    global MARKET_ITEMS, MARKET_LAST_UPDATE
    
    # Load current market data
    load_market()
    
    # If market is empty, generate new items
    if not MARKET_ITEMS:
        generate_daily_market()
        print(f"Generated {len(MARKET_ITEMS)} market items on startup")
    else:
        print(f"Market already has {len(MARKET_ITEMS)} items")

def add_ore_to_inventory(user_id: int, ore_name: str, amount: int = 1):
    """Add ore to user's inventory"""
    user_meta = get_user_meta(user_id)
    if "inventory" not in user_meta:
        user_meta["inventory"] = []
    
    # Check if ore already exists in inventory
    existing_ore = None
    for item in user_meta["inventory"]:
        if item.get("type") == "ore" and item.get("name") == ore_name:
            existing_ore = item
            break
    
    if existing_ore:
        # Update existing ore amount
        if "amount" not in existing_ore:
            existing_ore["amount"] = 1
        existing_ore["amount"] += amount
    else:
        # Add new ore item
        ore_item = {
            "name": ore_name,
            "type": "ore",
            "rarity": "common",  # Default rarity, can be enhanced later
            "description": f"A {ore_name} ore",
            "amount": amount
        }
        user_meta["inventory"].append(ore_item)
    
    set_user_meta(user_id, user_meta)

def add_item_to_inventory(user_id: int, item: dict):
    """Add item to user's inventory with stacking support"""
    user_meta = get_user_meta(user_id)
    if "inventory" not in user_meta:
        user_meta["inventory"] = []
    
    # Check if identical item already exists in inventory (for stacking)
    existing_item = None
    for inv_item in user_meta["inventory"]:
        if (inv_item.get("name") == item["name"] and 
            inv_item.get("type") == item["type"] and 
            inv_item.get("rarity") == item["rarity"]):
            
            # For weapons, armor, and artifacts, check if stats are identical
            if item["type"] in ["weapon", "armor", "artifact"]:
                if (inv_item.get("damage", 0) == item.get("damage", 0) and
                    inv_item.get("defense", 0) == item.get("defense", 0) and
                    inv_item.get("abilities", []) == item.get("abilities", [])):
                    existing_item = inv_item
                    break
            else:
                # For other item types, just check name, type, and rarity
                existing_item = inv_item
                break
    
    if existing_item:
        # Update existing item amount
        if "amount" not in existing_item:
            existing_item["amount"] = 1
        # Add the amount from the new item (default to 1 if not specified)
        add_amount = item.get("amount", 1)
        existing_item["amount"] += add_amount
        print(f"DEBUG: Updated existing item {existing_item['name']} amount to {existing_item['amount']} (added {add_amount})")
    else:
        # Create a copy of the item without market-specific fields
        inventory_item = {
            "name": item["name"],
            "type": item["type"],
            "rarity": item["rarity"],
            "amount": item.get("amount", 1)  # Use specified amount or default to 1
        }
        
        # Add type-specific fields
        if item["type"] == "weapon":
            inventory_item["damage"] = item.get("damage", 0)
        elif item["type"] == "armor":
            inventory_item["defense"] = item.get("defense", 0)
        elif item["type"] == "artifact":
            inventory_item["abilities"] = item.get("abilities", [])
        
        # Apply bonus effects for legendary+ items
        if item["type"] in ["weapon", "armor", "artifact"] and item.get("rarity") in ["legendary", "mythic", "divine"]:
            inventory_item = apply_item_bonus_effects(inventory_item)
        elif item["type"] == "store_item":
            # Handle store items - copy all relevant fields
            inventory_item["description"] = item.get("description", "")
            inventory_item["effects"] = item.get("effects", {})
            inventory_item["usable"] = item.get("usable", True)
            inventory_item["consumable"] = item.get("consumable", False)
            inventory_item["command"] = item.get("command")
            inventory_item["limit_uses"] = item.get("limit_uses")
            inventory_item["purchased_price"] = item.get("purchased_price", 0)
            inventory_item["stock_remaining"] = item.get("stock_remaining", 0)
        elif item["type"] in ["loot", "consumable"]:
            inventory_item["description"] = item.get("description", "")
        elif item["type"] == "ore":
            inventory_item["description"] = f"A {item['rarity']} quality ore"
        elif item["type"] == "material":
            inventory_item["description"] = item.get("description", f"A {item['rarity']} quality material")
        
        # Add value field - use existing value or calculate default based on rarity
        if "value" in item and item["value"] > 0:
            inventory_item["value"] = item["value"]
        else:
            # Calculate default value based on rarity and type
            rarity = item.get("rarity", "common").lower()
            item_type = item.get("type", "item")
            
            # Base values by rarity
            rarity_base_values = {
                "common": 100,
                "uncommon": 500,
                "rare": 2500,
                "epic": 10000,
                "legendary": 50000,
                "mythic": 250000,
                "divine": 1000000,
                "primordial": 1000000000
            }
            
            base_value = rarity_base_values.get(rarity, 100)
            
            # Type multipliers
            type_multipliers = {
                "weapon": 1.5,
                "armor": 1.2,
                "artifact": 2.0,
                "ore": 0.8,
                "material": 0.6,
                "loot": 1.0,
                "consumable": 0.5
            }
            
            type_mult = type_multipliers.get(item_type, 1.0)
            
            # Calculate final value
            final_value = int(base_value * type_mult)
            
            # Add some randomness (±20%)
            random_factor = 0.8 + (random.random() * 0.4)
            final_value = int(final_value * random_factor)
            
            inventory_item["value"] = final_value
            print(f"DEBUG: Generated default value {inventory_item['value']} for {item['name']} ({rarity} {item_type})")
        
        # Add command and limit_uses fields if they exist
        if "command" in item:
            inventory_item["command"] = item["command"]
        if "limit_uses" in item:
            inventory_item["limit_uses"] = item["limit_uses"]
        
        # Add other important fields for store items
        if "effects" in item:
            inventory_item["effects"] = item["effects"]
        if "usable" in item:
            inventory_item["usable"] = item["usable"]
        if "consumable" in item:
            inventory_item["consumable"] = item["consumable"]
        if "purchased_price" in item:
            inventory_item["purchased_price"] = item["purchased_price"]
        if "stock_remaining" in item:
            inventory_item["stock_remaining"] = item["stock_remaining"]
        
        # Add important store item properties
        if "usable" in item:
            inventory_item["usable"] = item["usable"]
        if "consumable" in item:
            inventory_item["consumable"] = item["consumable"]
        if "effects" in item:
            inventory_item["effects"] = item["effects"]
        if "spirit_animal" in item:
            inventory_item["spirit_animal"] = item["spirit_animal"]
            inventory_item["win_chance"] = item.get("win_chance", 50)
        if "description" in item:
            inventory_item["description"] = item["description"]
        
        # Add source and timestamp for expedition items
        if "source" in item:
            inventory_item["source"] = item["source"]
        if "added_at" in item:
            inventory_item["added_at"] = item["added_at"]
        else:
            inventory_item["added_at"] = int(time.time())
        
        user_meta["inventory"].append(inventory_item)
        print(f"DEBUG: Added new item {inventory_item['name']} to inventory")
    
    set_user_meta(user_id, user_meta)
    print(f"DEBUG: Inventory updated for user {user_id}, total items: {len(user_meta['inventory'])}")
    print(f"DEBUG: Last item added: {user_meta['inventory'][-1] if user_meta['inventory'] else 'None'}")

def fix_inventory_item_values(user_id: int):
    """Fix any items in user's inventory that have 0 or missing values"""
    user_meta = get_user_meta(user_id)
    if "inventory" not in user_meta:
        return
    
    fixed_count = 0
    for item in user_meta["inventory"]:
        if "value" not in item or item.get("value", 0) <= 0:
            # Calculate default value based on rarity and type
            rarity = item.get("rarity", "common").lower()
            item_type = item.get("type", "item")
            
            # Base values by rarity
            rarity_base_values = {
                "common": 100,
                "uncommon": 500,
                "rare": 2500,
                "epic": 10000,
                "legendary": 50000,
                "mythic": 250000,
                "divine": 1000000,
                "primordial": 1000000000
            }
            
            base_value = rarity_base_values.get(rarity, 100)
            
            # Type multipliers
            type_multipliers = {
                "weapon": 1.5,
                "armor": 1.2,
                "artifact": 2.0,
                "ore": 0.8,
                "material": 0.6,
                "loot": 1.0,
                "consumable": 0.5
            }
            
            type_mult = type_multipliers.get(item_type, 1.0)
            
            # Calculate final value
            final_value = int(base_value * type_mult)
            
            # Add some randomness (±20%)
            random_factor = 0.8 + (random.random() * 0.4)
            final_value = int(final_value * random_factor)
            
            old_value = item.get("value", "missing")
            item["value"] = final_value
            fixed_count += 1
            item_name = item.get('name', 'Unknown Item')
            print(f"DEBUG: Fixed item {item_name} value from {old_value} to {final_value}")
    
    if fixed_count > 0:
        set_user_meta(user_id, user_meta)
        print(f"DEBUG: Fixed {fixed_count} items with invalid values for user {user_id}")

# Immortal Art Reroll System
IMMORTAL_ART_REROLL_COST = 100000  # 100k
IMMORTAL_ART_REROLL_DAILY_LIMIT = 5

def get_immortal_art_reroll_count(user_id: int) -> int:
    """Get user's daily immortal art reroll count"""
    user_meta = get_user_meta(user_id)
    daily_data = user_meta.get("daily_immortal_rerolls", {})
    current_day = time.strftime("%Y-%m-%d")
    
    if daily_data.get("date") != current_day:
        return 0
    return daily_data.get("count", 0)

def increment_immortal_art_reroll_count(user_id: int):
    """Increment user's daily immortal art reroll count"""
    user_meta = get_user_meta(user_id)
    current_day = time.strftime("%Y-%m-%d")
    
    if "daily_immortal_rerolls" not in user_meta:
        user_meta["daily_immortal_rerolls"] = {}
    
    daily_data = user_meta["daily_immortal_rerolls"]
    if daily_data.get("date") != current_day:
        daily_data["date"] = current_day
        daily_data["count"] = 0
    
    daily_data["count"] += 1
    set_user_meta(user_id, user_meta)

# Default jobs
DEFAULT_JOBS = {
    "Farmer": [200, 400],
    "Blacksmith": [300, 500],
    "Alchemist": [400, 600],
    "Merchant": [600, 800],
    "Miner": [350, 550],
    "Hunter": [450, 650]
}

# Case system constants

CASE_EMOJI = "🎁"
CASE_COLOR = 0x9b59b6  # Purple
CASE_COOLDOWNS = {}  # User ID -> {case_key -> timestamp}

# Global cooldowns
COOLDOWNS = {}  # User ID -> timestamp

# Job System Constants
JOB_RANKS = {
    "apprentice": {"xp_required": 0, "multiplier": 1.0, "message_requirement": 0},
    "beginner": {"xp_required": 100, "multiplier": 1.2, "message_requirement": 50},
    "adept": {"xp_required": 300, "multiplier": 1.5, "message_requirement": 150},
    "greater": {"xp_required": 600, "multiplier": 2.0, "message_requirement": 300},
    "master": {"xp_required": 1000, "multiplier": 3.0, "message_requirement": 500}
}

# Job progression multipliers for message requirements
JOB_PROGRESSION_MULTIPLIERS = [2, 3, 4, 5, 6, 7, 8, 9, 10]

# Job-specific crafting items and their base rarities
JOB_CRAFTING_ITEMS = {
    "Blacksmith": {
        "apprentice": {
            "items": ["Rusty Sword", "Basic Spear", "Simple Dagger"],
            "base_rarity": "common",
            "quality_chance": 0.05
        },
        "beginner": {
            "items": ["Iron Sword", "Steel Spear", "Sharp Dagger", "Battle Axe"],
            "base_rarity": "uncommon",
            "quality_chance": 0.10
        },
        "adept": {
            "items": ["Steel Greatsword", "Silver Spear", "Enchanted Dagger", "War Axe", "Battle Hammer"],
            "base_rarity": "rare",
            "quality_chance": 0.20
        },
        "greater": {
            "items": ["Mythril Sword", "Dragonbone Spear", "Shadow Dagger", "Thunder Axe", "Earth Hammer", "Lightning Blade"],
            "base_rarity": "legendary",
            "quality_chance": 0.35
        },
        "master": {
            "items": ["Celestial Blade", "Phoenix Spear", "Void Dagger", "Storm Axe", "Mountain Hammer", "Star Sword", "Moon Blade"],
            "base_rarity": "mythic",
            "quality_chance": 0.50
        }
    },
    "Alchemist": {
        "apprentice": {
            "items": ["Basic Healing Pill", "Simple Mana Potion", "Weak Antidote"],
            "base_rarity": "common",
            "quality_chance": 0.05
        },
        "beginner": {
            "items": ["Healing Pill", "Mana Potion", "Antidote", "Strength Elixir"],
            "base_rarity": "uncommon",
            "quality_chance": 0.10
        },
        "adept": {
            "items": ["Greater Healing Pill", "Greater Mana Potion", "Cure All", "Might Elixir", "Wisdom Potion"],
            "base_rarity": "rare",
            "quality_chance": 0.20
        },
        "greater": {
            "items": ["Supreme Healing Pill", "Supreme Mana Potion", "Panacea", "Titan Elixir", "Sage Potion", "Immortality Elixir"],
            "base_rarity": "legendary",
            "quality_chance": 0.35
        },
        "master": {
            "items": ["Celestial Healing Pill", "Celestial Mana Potion", "Elixir of Life", "God Elixir", "Omniscience Potion", "Eternal Youth Elixir", "Creation Elixir"],
            "base_rarity": "mythic",
            "quality_chance": 0.50
        }
    },
    "Farmer": {
        "apprentice": {
            "items": ["Basic Rice", "Simple Vegetables", "Weak Herbs"],
            "base_rarity": "common",
            "quality_chance": 0.05
        },
        "beginner": {
            "items": ["Quality Rice", "Fresh Vegetables", "Medicinal Herbs", "Golden Wheat"],
            "base_rarity": "uncommon",
            "quality_chance": 0.10
        },
        "adept": {
            "items": ["Spirit Rice", "Enchanted Vegetables", "Rare Herbs", "Divine Wheat", "Mystical Fruits"],
            "base_rarity": "rare",
            "quality_chance": 0.20
        },
        "greater": {
            "items": ["Celestial Rice", "Mythical Vegetables", "Legendary Herbs", "Sacred Wheat", "Immortal Fruits", "World Tree Seeds"],
            "base_rarity": "legendary",
            "quality_chance": 0.35
        },
        "master": {
            "items": ["Cosmic Rice", "Eternal Vegetables", "Mythic Herbs", "Infinite Wheat", "Timeless Fruits", "Genesis Seeds", "Creation Essence"],
            "base_rarity": "mythic",
            "quality_chance": 0.50
        }
    },
    "Merchant": {
        "apprentice": {
            "items": ["Basic Trade Goods", "Simple Contracts", "Weak Charms"],
            "base_rarity": "common",
            "quality_chance": 0.05
        },
        "beginner": {
            "items": ["Quality Trade Goods", "Trade Contracts", "Lucky Charms", "Business Seals"],
            "base_rarity": "uncommon",
            "quality_chance": 0.10
        },
        "adept": {
            "items": ["Rare Trade Goods", "Binding Contracts", "Fortune Charms", "Royal Seals", "Trade Networks"],
            "base_rarity": "rare",
            "quality_chance": 0.20
        },
        "greater": {
            "items": ["Legendary Trade Goods", "Eternal Contracts", "Destiny Charms", "Imperial Seals", "Global Networks", "Market Dominance"],
            "base_rarity": "legendary",
            "quality_chance": 0.35
        },
        "master": {
            "items": ["Mythic Trade Goods", "Infinite Contracts", "Fate Charms", "Cosmic Seals", "Universal Networks", "Economic Empire", "Wealth Creation"],
            "base_rarity": "mythic",
            "quality_chance": 0.50
        }
    },
    "Miner": {
        "apprentice": {
            "items": ["Basic Pickaxe", "Simple Shovel", "Weak Hammer"],
            "base_rarity": "common",
            "quality_chance": 0.05
        },
        "beginner": {
            "items": ["Iron Pickaxe", "Steel Shovel", "Strong Hammer", "Mining Cart"],
            "base_rarity": "uncommon",
            "quality_chance": 0.10
        },
        "adept": {
            "items": ["Steel Pickaxe", "Silver Shovel", "Enchanted Hammer", "Advanced Cart", "Mining Drill"],
            "base_rarity": "rare",
            "quality_chance": 0.20
        },
        "greater": {
            "items": ["Mithril Pickaxe", "Dragonbone Shovel", "Thunder Hammer", "Flying Cart", "Laser Drill", "Tunnel Borer"],
            "base_rarity": "legendary",
            "quality_chance": 0.35
        },
        "master": {
            "items": ["Celestial Pickaxe", "Phoenix Shovel", "Storm Hammer", "Cosmic Cart", "Quantum Drill", "Reality Borer", "Creation Tool"],
            "base_rarity": "mythic",
            "quality_chance": 0.50
        }
    },
    "Hunter": {
        "apprentice": {
            "items": ["Basic Bow", "Simple Arrow", "Weak Trap"],
            "base_rarity": "common",
            "quality_chance": 0.05
        },
        "beginner": {
            "items": ["Iron Bow", "Steel Arrow", "Strong Trap", "Tracking Device"],
            "base_rarity": "uncommon",
            "quality_chance": 0.10
        },
        "adept": {
            "items": ["Steel Bow", "Silver Arrow", "Enchanted Trap", "Advanced Tracker", "Hunting Dog"],
            "base_rarity": "rare",
            "quality_chance": 0.20
        },
        "greater": {
            "items": ["Mithril Bow", "Dragonbone Arrow", "Thunder Trap", "Flying Tracker", "Spirit Dog", "Shadow Cloak"],
            "base_rarity": "legendary",
            "quality_chance": 0.35
        },
        "master": {
            "items": ["Celestial Bow", "Phoenix Arrow", "Storm Trap", "Cosmic Tracker", "Void Dog", "Reality Cloak", "Creation Weapon"],
            "base_rarity": "mythic",
            "quality_chance": 0.50
        }
    }
}

# Job XP gain per work session
JOB_XP_PER_WORK = 25

# Message XP gain (for job progression)
MESSAGE_XP_GAIN = 1

# Job System Helper Functions
def get_job_rank(user_id: int, job_name: str) -> str:
    """Get the current rank of a user in a specific job"""
    meta = get_user_meta(user_id)
    job_data = meta.get("jobs", {}).get(job_name, {})
    current_xp = job_data.get("xp", 0)
    
    # Find the highest rank the user qualifies for
    for rank in reversed(list(JOB_RANKS.keys())):
        if current_xp >= JOB_RANKS[rank]["xp_required"]:
            return rank
    
    return "apprentice"

def get_job_xp(user_id: int, job_name: str) -> int:
    """Get the current XP of a user in a specific job"""
    meta = get_user_meta(user_id)
    job_data = meta.get("jobs", {}).get(job_name, {})
    return job_data.get("xp", 0)

def add_job_xp(user_id: int, job_name: str, xp_amount: int) -> tuple[str, int]:
    """Add XP to a user's job and return (new_rank, total_xp)"""
    meta = get_user_meta(user_id)
    
    # Initialize jobs structure if it doesn't exist
    if "jobs" not in meta:
        meta["jobs"] = {}
    if job_name not in meta["jobs"]:
        meta["jobs"][job_name] = {"xp": 0, "rank": "apprentice"}
    
    # Add XP
    old_xp = meta["jobs"][job_name]["xp"]
    new_xp = old_xp + xp_amount
    meta["jobs"][job_name]["xp"] = new_xp
    
    # Determine new rank
    new_rank = "apprentice"
    for rank in reversed(list(JOB_RANKS.keys())):
        if new_xp >= JOB_RANKS[rank]["xp_required"]:
            new_rank = rank
            break
    
    # Update rank
    meta["jobs"][job_name]["rank"] = new_rank
    set_user_meta(user_id, meta)
    
    return new_rank, new_xp

def get_job_rank_progress(user_id: int, job_name: str) -> tuple[str, int, int, int]:
    """Get job rank progress: (current_rank, current_xp, xp_needed, progress_percent)"""
    current_xp = get_job_xp(user_id, job_name)
    current_rank = get_job_rank(user_id, job_name)
    
    # Find next rank requirements
    rank_names = list(JOB_RANKS.keys())
    current_rank_index = rank_names.index(current_rank)
    
    if current_rank_index >= len(rank_names) - 1:
        # Already at max rank
        return current_rank, current_xp, 0, 100
    
    next_rank = rank_names[current_rank_index + 1]
    xp_needed = JOB_RANKS[next_rank]["xp_required"] - current_xp
    progress_percent = int((current_xp - JOB_RANKS[current_rank]["xp_required"]) / (JOB_RANKS[next_rank]["xp_required"] - JOB_RANKS[current_rank]["xp_required"]) * 100)
    
    return current_rank, current_xp, xp_needed, progress_percent

def craft_job_item(job_name: str, rank: str, user_id: int) -> tuple[str, str, int, str]:
    """Craft a random item based on job, rank, and user's skill.
    Returns (item_name, rarity, value, item_type) where item_type is one of
    'job_item', 'ore', or 'loot'."""
    # 70% chance for job-specific crafted items, 30% chance for general loot/ores
    if random.random() < 0.7 and job_name in JOB_CRAFTING_ITEMS and rank in JOB_CRAFTING_ITEMS[job_name]:
        # Job-specific crafted item
        job_data = JOB_CRAFTING_ITEMS[job_name][rank]
        base_rarity = job_data["base_rarity"]
        quality_chance = job_data["quality_chance"]
        
        # Choose random item from this rank
        item_name = random.choice(job_data["items"])
        
        # Determine final rarity based on user's skill and luck
        final_rarity = base_rarity
        if random.random() < quality_chance:
            # Weighted rarity upgrade - make legendary extremely rare
            rarity_order = ["common", "uncommon", "rare", "legendary", "mythic"]
            try:
                current_index = rarity_order.index(base_rarity)
                if current_index < len(rarity_order) - 1:
                    # Only 0.1% chance to upgrade to legendary
                    if current_index == 2 and random.random() < 0.001:  # rare -> legendary
                        final_rarity = "legendary"
                    # Only 0.01% chance to upgrade to mythic
                    elif current_index == 3 and random.random() < 0.0001:  # legendary -> mythic
                        final_rarity = "mythic"
                    # Normal upgrade for common/uncommon/rare
                    elif current_index < 2:
                        final_rarity = rarity_order[current_index + 1]
            except ValueError:
                pass
        
        # Use new direct pricing system for crafted items
        if final_rarity == "common":
            item_value = 300
        elif final_rarity == "uncommon":
            item_value = 1000
        elif final_rarity == "rare":
            item_value = 20000
        elif final_rarity == "epic":
            item_value = 70000
        elif final_rarity == "legendary":
            item_value = 400000
        elif final_rarity == "mythic":
            item_value = 4000000
        else:  # divine
            item_value = 70000000
        
        # Apply randomization based on rarity
        if final_rarity in ["legendary", "mythic", "divine", "primordial"]:
            random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
            item_value = int(item_value * random_factor)
        else:
            random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
            item_value = int(item_value * random_factor)
        
        return item_name, final_rarity, item_value, "job_item"
    else:
        # General loot/ore reward
        reward_type = random.choice(["ore", "loot"])
        
        if reward_type == "ore":
            # Generate ore based on rank with weighted rarity system
            # Legendary is VERY RARE, Mythic is 10x rarer, Divine is 100x rarer than Mythic
            ore_rarities = {
                "apprentice": ["common", "uncommon"],
                "beginner": ["common", "uncommon", "rare"],
                "adept": ["uncommon", "rare", "legendary"],
                "greater": ["rare", "legendary", "mythic"],
                "master": ["rare", "legendary", "mythic", "divine"]
            }
            
            available_rarities = ore_rarities.get(rank, ["common"])
            
            # Weighted rarity selection - make legendary extremely rare
            if "legendary" in available_rarities:
                if random.random() < 0.001:  # 0.1% chance for legendary
                    if "mythic" in available_rarities and random.random() < 0.0001:  # 0.01% chance for mythic
                        if "divine" in available_rarities and random.random() < 0.00001:  # 0.0001% chance for divine
                            rarity = "divine"
                        else:
                            rarity = "mythic"
                    else:
                        rarity = "legendary"
                else:
                    # Remove legendary+ from available rarities for this roll
                    available_rarities = [r for r in available_rarities if r not in ["legendary", "mythic", "divine"]]
                    rarity = random.choice(available_rarities) if available_rarities else "common"
            else:
                rarity = random.choice(available_rarities)
            
            # Generate ore name based on rarity
            ore_names = {
                "common": ["Iron Ore", "Copper Ore", "Stone"],
                "uncommon": ["Silver Ore", "Gold Ore", "Coal"],
                        "rare": ["Mithril Ore", "Adamantite Ore", "Crystal"],
        "epic": ["Tungsten Ore", "Vanadium Ore", "Molybdenum Ore"],
        "legendary": ["Dragon Ore", "Phoenix Ore", "Star Metal"],
                "mythic": ["Void Ore", "Ethereal Ore", "Cosmic Metal"],
                "divine": ["Divine Ore", "Creation Metal", "Genesis Stone"]
            }
            
            item_name = random.choice(ore_names.get(rarity, ["Unknown Ore"]))
            # Use new direct pricing system for ore
            if rarity == "common":
                item_value = 450
            elif rarity == "uncommon":
                item_value = 1300
            elif rarity == "rare":
                item_value = 30000
            elif rarity == "epic":
                item_value = 120000
            elif rarity == "legendary":
                item_value = 600000
            elif rarity == "mythic":
                item_value = 10000000
            else:  # divine
                item_value = 100000000
            
            # Apply randomization based on rarity
            if rarity in ["legendary", "mythic", "divine", "primordial"]:
                random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
                item_value = int(item_value * random_factor)
            else:
                random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
                item_value = int(item_value * random_factor)
            
            return item_name, rarity, item_value, "ore"
            
        else:
            # Generate loot based on rank with weighted rarity system
            # Legendary is VERY RARE, Mythic is 10x rarer, Divine is 100x rarer than Mythic
            loot_rarities = {
                "apprentice": ["common", "uncommon"],
                "beginner": ["common", "uncommon", "rare"],
                "adept": ["uncommon", "rare", "legendary"],
                "greater": ["rare", "legendary", "mythic"],
                "master": ["rare", "legendary", "mythic", "divine"]
            }
            
            available_rarities = loot_rarities.get(rank, ["common"])
            
            # Weighted rarity selection - make legendary extremely rare
            if "legendary" in available_rarities:
                if random.random() < 0.001:  # 0.1% chance for legendary
                    if "mythic" in available_rarities and random.random() < 0.0001:  # 0.01% chance for mythic
                        if "divine" in available_rarities and random.random() < 0.00001:  # 0.0001% chance for divine
                            rarity = "divine"
                        else:
                            rarity = "mythic"
                    else:
                        rarity = "legendary"
                else:
                    # Remove legendary+ from available rarities for this roll
                    available_rarities = [r for r in available_rarities if r not in ["legendary", "mythic", "divine"]]
                    rarity = random.choice(available_rarities) if available_rarities else "common"
            else:
                rarity = random.choice(available_rarities)
            
            # Generate loot name based on rarity
            loot_names = {
                "common": ["Ancient Coin", "Dusty Relic", "Broken Pottery"],
                "uncommon": ["Silver Coin", "Ancient Relic", "Valuable Pottery"],
                        "rare": ["Gold Coin", "Mystical Relic", "Enchanted Pottery"],
        "epic": ["Tungsten Coin", "Epic Relic", "Enchanted Pottery"],
        "legendary": ["Platinum Coin", "Legendary Relic", "Sacred Pottery"],
                "mythic": ["Diamond Coin", "Mythic Relic", "Eternal Pottery"],
                "divine": ["Divine Coin", "Creation Relic", "Genesis Pottery"]
            }
            
            item_name = random.choice(loot_names.get(rarity, ["Unknown Loot"]))
            # Use new direct pricing system for loot
            if rarity == "common":
                item_value = 300
            elif rarity == "uncommon":
                item_value = 1000
            elif rarity == "rare":
                item_value = 20000
            elif rarity == "epic":
                item_value = 70000
            elif rarity == "legendary":
                item_value = 400000
            elif rarity == "mythic":
                item_value = 4000000
            else:  # divine
                item_value = 70000000
            
            # Apply randomization based on rarity
            if rarity in ["legendary", "mythic", "divine", "primordial"]:
                random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
                item_value = int(item_value * random_factor)
            else:
                random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
                item_value = int(item_value * random_factor)
            
            return item_name, rarity, item_value, "loot"

def get_message_count(user_id: int) -> int:
    """Get the message count for a user"""
    meta = get_user_meta(user_id)
    return meta.get("message_count", 0)

def add_message_count(user_id: int, count: int = 1) -> int:
    """Add to message count and return new total"""
    meta = get_user_meta(user_id)
    current_count = meta.get("message_count", 0)
    new_count = current_count + count
    meta["message_count"] = new_count
    set_user_meta(user_id, meta)
    return new_count


# File helpers
def ensure_file(path, default):
    path = _abs_data_path(path)
    if not os.path.exists(path):
        with open(path, "w", encoding="utf-8") as f:
            json.dump(default, f, indent=4)


def load_json(path):
    path = _abs_data_path(path)
    try:
        if not os.path.exists(path):
            if path == JOBS_FILE:
                ensure_file(path, DEFAULT_JOBS)
            else:
                ensure_file(path, {})
        
        # Check if file is accessible and not locked
        if not os.access(path, os.R_OK):
            print(f"WARNING: File {path} is not readable")
            return {}
            
        with open(path, "r", encoding="utf-8") as f:
            try:
                return json.load(f)
            except json.JSONDecodeError as e:
                print(f"JSON decode error in {path}: {e}")
                if path == JOBS_FILE:
                    ensure_file(path, DEFAULT_JOBS)
                    return DEFAULT_JOBS.copy()
                else:
                    ensure_file(path, {})
                    return {}
            except Exception as e:
                print(f"Error reading file {path}: {e}")
                return {}
    except Exception as e:
        print(f"Critical error loading {path}: {e}")
        return {}


def save_json(path, data):
    path = _abs_data_path(path)
    try:
        # Check if directory exists and is writable
        dir_path = os.path.dirname(path)
        if not os.path.exists(dir_path):
            os.makedirs(dir_path, exist_ok=True)
            
        # Check if file is writable (or if it doesn't exist, if directory is writable)
        if os.path.exists(path) and not os.access(path, os.W_OK):
            print(f"WARNING: File {path} is not writable")
            return False
            
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4)
        return True
    except Exception as e:
        print(f"Error saving {path}: {e}")
        return False


# Create files if missing
ensure_file(DATA_FILE, {})
ensure_file(INCOME_FILE, {})
ensure_file(STORE_FILE, {})
ensure_file(JOBS_FILE, DEFAULT_JOBS)
ensure_file(AUCTIONS_FILE, {})
ensure_file(LOOT_ROLES_FILE, {})
ensure_file(CASES_FILE, {})
ensure_file(CASE_ITEMS_FILE, {})


# -----------------------
# Rarity Multipliers
# -----------------------
RARITY_MULTIPLIERS = {
    "common": 1,
    "uncommon": 2,
    "rare": 5,
    "legendary": 15,
    "mythic": 50,
    "divine": 100
}

# -----------------------
# Weapons, Armor, and Artifacts System
# -----------------------

# Weapon types and base damage
WEAPON_TYPES = {
    "sword": {"base_damage": 15, "emoji": "⚔️", "description": "Balanced weapon with good damage and speed"},
    "axe": {"base_damage": 25, "emoji": "🪓", "description": "Heavy weapon with high damage but slower speed"},
    "dagger": {"base_damage": 10, "emoji": "🗡️", "description": "Fast weapon with low damage but high critical chance"},
    "staff": {"base_damage": 12, "emoji": "🦯", "description": "Magical weapon with elemental damage"},
    "bow": {"base_damage": 18, "emoji": "🏹", "description": "Ranged weapon with good accuracy"},
    "spear": {"base_damage": 20, "emoji": "🔱", "description": "Long reach weapon with piercing damage"},
    "hammer": {"base_damage": 30, "emoji": "🔨", "description": "Massive damage but very slow"},
    "whip": {"base_damage": 8, "emoji": "🪢", "description": "Fast weapon with area damage"}
}

# Armor types and base health
ARMOR_TYPES = {
    "leather": {"base_health": 25, "emoji": "🥋", "description": "Light armor with good mobility"},
    "chainmail": {"base_health": 60, "emoji": "🔗", "description": "Medium armor with balanced protection"},
    "plate": {"base_health": 100, "emoji": "🛡️", "description": "Heavy armor with maximum protection"},
    "robe": {"base_health": 15, "emoji": "👘", "description": "Magical armor with spell resistance"},
    "scale": {"base_health": 75, "emoji": "🐟", "description": "Flexible armor with good protection"},
    "bone": {"base_health": 40, "emoji": "💀", "description": "Dark armor with necromantic properties"}
}

# Artifact types and special abilities - Economic focus
ARTIFACT_TYPES = {
    "ring": {"emoji": "💍", "description": "Fortune rings that boost economic gains"},
    "amulet": {"emoji": "📿", "description": "Prosperity amulets that enhance wealth"},
    "crystal": {"emoji": "💎", "description": "Wealth crystals that amplify earnings"},
    "scroll": {"emoji": "📜", "description": "Ancient scrolls of economic wisdom"},
    "orb": {"emoji": "🔮", "description": "Mystical orbs that attract fortune"},
    "talisman": {"emoji": "🕯️", "description": "Sacred talismans of prosperity"}
}

# Rarity multipliers for weapons and armor - Balanced system
RARITY_DAMAGE_MULTIPLIERS = {
    "common": 1.0,      # 1-3 damage
    "uncommon": 2.0,    # 3-5 damage  
    "rare": 3.5,        # 5-10 damage
    "epic": 6.0,        # 10-13 damage (weapons only)
    "legendary": 8.0,   # 15-20 damage
    "mythic": 15.0,     # 20-40 damage
    "divine": 30.0,     # 50-100 damage
                   "primordial": 1000.0     # 1000 damage (primordial only)
}

RARITY_HEALTH_MULTIPLIERS = {
    "common": 1.0,      # 1-3 health
    "uncommon": 2.0,    # 3-5 health
    "rare": 3.5,        # 5-10 health
    "epic": 6.0,        # 10-15 health (armor only)
    "legendary": 8.0,   # 15-25 health
    "mythic": 15.0,     # 25-50 health
    "divine": 30.0,     # 50-100 health
                   "primordial": 1000.0     # 1000 health (primordial only)
}

# Special abilities for artifacts - Focused on economic bonuses
ARTIFACT_ABILITIES = {
    "common": [
        "Minor work income boost (+3%)",
        "Slight blackjack payout (+2%)",
        "Basic shop discount (-2%)",
        "Minor sell price bonus (+2%)",
        "Slight roulette boost (+1%)"
    ],
    "uncommon": [
        "Work income boost (+5%)",
        "Blackjack payout boost (+4%)",
        "Shop discount (-4%)",
        "Sell price bonus (+4%)",
        "Roulette payout boost (+3%)",
        "Minor cultivation bonus (+2%)"
    ],
    "rare": [
        "Strong work income boost (+8%)",
        "Significant blackjack payout (+6%)",
        "Shop discount (-6%)",
        "Sell price bonus (+6%)",
        "Roulette payout boost (+5%)",
        "Cultivation bonus (+4%)",
        "Work cooldown reduction (-5%)"
    ],
    "legendary": [
        "Major work income boost (+15%)",
        "High blackjack payout (+12%)",
        "Shop discount (-10%)",
        "Sell price bonus (+12%)",
        "Roulette payout boost (+10%)",
        "Cultivation bonus (+8%)",
        "Work cooldown reduction (-10%)",
        "Gambling loss reduction (+8%)"
    ],
    "mythic": [
        "Massive work income boost (+25%)",
        "Extreme blackjack payout (+20%)",
        "Shop discount (-15%)",
        "Sell price bonus (+20%)",
        "Roulette payout boost (+18%)",
        "Cultivation bonus (+15%)",
        "Work cooldown reduction (-20%)",
        "Gambling loss reduction (+15%)",
        "Double win chance (+10%)"
    ],
    "divine": [
        "Ultimate work income boost (+40%)",
        "Perfect blackjack payout (+35%)",
        "Shop discount (-25%)",
        "Sell price bonus (+35%)",
        "Roulette payout boost (+30%)",
        "Cultivation bonus (+25%)",
        "Work cooldown reduction (-30%)",
        "Gambling loss reduction (+25%)",
        "Double win chance (+20%)",
        "All economic bonuses +50%"
    ]
}

# Expedition encounter types
ENCOUNTER_TYPES = {
    "beast": {
        "names": ["Dire Wolf", "Giant Bear", "Ancient Dragon", "Shadow Panther", "Thunder Eagle", "Venomous Serpent"],
        "base_damage": 20,
        "base_health": 100,
        "emoji": "🐺",
        "loot_chance": 0.7
    },
    "evil_cultivator": {
        "names": ["Dark Disciple", "Corrupted Master", "Shadow Assassin", "Blood Cultist", "Void Walker", "Chaos Lord"],
        "base_damage": 25,
        "base_health": 120,
        "emoji": "👤",
        "loot_chance": 0.8
    }
}

# Global encounter chance (default 30%)
EXPEDITION_ENCOUNTER_CHANCE = 0.3

# -----------------------
# Sect Shop System
# -----------------------

# Sect shop upgrades configuration
SECT_SHOP_UPGRADES = {
    "income_boost": {
        "name": "Income Boost",
        "emoji": "💰",
        "category": "economy",
        "base_cost": 100000,
        "cost_multiplier": 2.5,
        "max_level": 10,
        "effect_per_level": 5,
        "description": "Increases income from all sources by 5% per level"
    },
    "xp_boost": {
        "name": "XP Boost",
        "emoji": "🎯",
        "category": "core",
        "base_cost": 150000,
        "cost_multiplier": 2.5,
        "max_level": 10,
        "effect_per_level": 10,
        "description": "Increases XP gain from all activities by 10% per level"
    },
    "expedition_boost": {
        "name": "Expedition Boost",
        "emoji": "🗺️",
        "category": "adventure",
        "base_cost": 200000,
        "cost_multiplier": 2.5,
        "max_level": 8,
        "effect_per_level": 15,
        "description": "Increases expedition rewards and success chance by 15% per level"
    },
    "crafting_discount": {
        "name": "Crafting Discount",
        "emoji": "⚒️",
        "category": "economy",
        "base_cost": 250000,
        "cost_multiplier": 3.0,
        "max_level": 5,
        "effect_per_level": 10,
        "description": "Reduces crafting costs by 10% per level"
    },
    "daily_bonus": {
        "name": "Daily Bonus",
        "emoji": "📅",
        "category": "utility",
        "base_cost": 300000,
        "cost_multiplier": 3.0,
        "max_level": 5,
        "effect_per_level": 20,
        "description": "Increases daily bonus rewards by 20% per level"
    },
    "weekly_bonus": {
        "name": "Weekly Bonus",
        "emoji": "📊",
        "category": "utility",
        "base_cost": 500000,
        "cost_multiplier": 3.0,
        "max_level": 5,
        "effect_per_level": 25,
        "description": "Increases weekly bonus rewards by 25% per level"
    },
    "immortal_art_boost": {
        "name": "Immortal Art Boost",
        "emoji": "✨",
        "category": "mystical",
        "base_cost": 1000000,
        "cost_multiplier": 4.0,
        "max_level": 3,
        "effect_per_level": 50,
        "description": "Increases immortal art income by 50% per level"
    }
}

# Top 3 sect bonuses
TOP_SECT_BOOSTERS = {
    1: {
        "name": "🏆 Supreme Sect",
        "income_boost": 100,
        "xp_boost": 50
    },
    2: {
        "name": "🥈 Elite Sect", 
        "income_boost": 50,
        "xp_boost": 25
    },
    3: {
        "name": "🥉 Distinguished Sect",
        "income_boost": 25,
        "xp_boost": 15
    }
}

def get_sect_upgrades(sect_name: str) -> dict:
    """Get current upgrade levels for a sect"""
    data = load_json(SECTS_FILE)
    if sect_name not in data:
        return {}
    
    return data[sect_name].get("upgrades", {})

def get_sect_upgrade_level(sect_name: str, upgrade_type: str) -> int:
    """Get current level of a specific upgrade for a sect"""
    upgrades = get_sect_upgrades(sect_name)
    return upgrades.get(upgrade_type, 0)

def get_sect_upgrade_cost(sect_name: str, upgrade_type: str) -> int:
    """Calculate the cost to upgrade a sect upgrade"""
    if upgrade_type not in SECT_SHOP_UPGRADES:
        return 0
    
    current_level = get_sect_upgrade_level(sect_name, upgrade_type)
    upgrade_data = SECT_SHOP_UPGRADES[upgrade_type]
    
    if current_level >= upgrade_data["max_level"]:
        return 0
    
    base_cost = upgrade_data["base_cost"]
    multiplier = upgrade_data["cost_multiplier"]
    
    # Cost increases exponentially with each level
    return int(base_cost * (multiplier ** current_level))

def can_upgrade_sect(sect_name: str, upgrade_type: str) -> bool:
    """Check if a sect can upgrade a specific upgrade"""
    if upgrade_type not in SECT_SHOP_UPGRADES:
        return False
    
    current_level = get_sect_upgrade_level(sect_name, upgrade_type)
    upgrade_data = SECT_SHOP_UPGRADES[upgrade_type]
    
    return current_level < upgrade_data["max_level"]

def get_sect_boosts(sect_name: str) -> dict:
    """Get all active boosts for a sect (including top 3 bonuses)"""
    data = load_json(SECTS_FILE)
    if sect_name not in data:
        return {"income_boost": 0, "xp_boost": 0, "expedition_boost": 0, "crafting_discount": 0, "daily_bonus": 0, "weekly_bonus": 0, "immortal_art_boost": 0}
    
    upgrades = data[sect_name].get("upgrades", {})
    
    # Calculate total boosts from upgrades
    income_boost = upgrades.get("income_boost", 0) * SECT_SHOP_UPGRADES["income_boost"]["effect_per_level"]
    xp_boost = upgrades.get("xp_boost", 0) * SECT_SHOP_UPGRADES["xp_boost"]["effect_per_level"]
    expedition_boost = upgrades.get("expedition_boost", 0) * SECT_SHOP_UPGRADES["expedition_boost"]["effect_per_level"]
    crafting_discount = upgrades.get("crafting_discount", 0) * SECT_SHOP_UPGRADES["crafting_discount"]["effect_per_level"]
    daily_bonus = upgrades.get("daily_bonus", 0) * SECT_SHOP_UPGRADES["daily_bonus"]["effect_per_level"]
    weekly_bonus = upgrades.get("weekly_bonus", 0) * SECT_SHOP_UPGRADES["weekly_bonus"]["effect_per_level"]
    immortal_art_boost = upgrades.get("immortal_art_boost", 0) * SECT_SHOP_UPGRADES["immortal_art_boost"]["effect_per_level"]
    
    # Add top 3 sect bonuses
    sect_rank = get_sect_rank(sect_name)
    if sect_rank in TOP_SECT_BOOSTERS:
        top_booster = TOP_SECT_BOOSTERS[sect_rank]
        income_boost += top_booster["income_boost"]
        xp_boost += top_booster["xp_boost"]
    
    return {
        "income_boost": income_boost,
        "xp_boost": xp_boost,
        "expedition_boost": expedition_boost,
        "crafting_discount": crafting_discount,
        "daily_bonus": daily_bonus,
        "weekly_bonus": weekly_bonus,
        "immortal_art_boost": immortal_art_boost
    }


def apply_sect_boosts_to_income(user_id: int, base_amount: int) -> Tuple[int, int, float]:
    """Apply sect boosts to income amount. Returns (total_amount, bonus_amount, total_boost_percent)"""
    meta = get_user_meta(user_id)
    sect_name = meta.get("sect")
    
    if not sect_name:
        return base_amount, 0, 0.0
    
    sect_boosts = get_sect_boosts(sect_name)
    income_boost = sect_boosts["income_boost"]
    
    if income_boost <= 0:
        return base_amount, 0, 0.0
    
    bonus_amount = int(round(base_amount * income_boost / 100.0))
    total_amount = base_amount + bonus_amount
    
    return total_amount, bonus_amount, income_boost


def apply_sect_boosts_to_xp(user_id: int, base_xp: int) -> Tuple[int, int, float]:
    """Apply sect boosts to XP amount. Returns (total_xp, bonus_xp, total_boost_percent)"""
    meta = get_user_meta(user_id)
    sect_name = meta.get("sect")
    
    if not sect_name:
        return base_xp, 0, 0.0
    
    sect_boosts = get_sect_boosts(sect_name)
    xp_boost = sect_boosts["xp_boost"]
    
    if xp_boost <= 0:
        return base_xp, 0, 0.0
    
    bonus_xp = int(round(base_xp * xp_boost / 100.0))
    total_xp = base_xp + bonus_xp
    
    return total_xp, bonus_xp, xp_boost

def get_sect_rank(sect_name: str) -> int:
    """Get the rank of a sect based on total wealth"""
    data = load_json(SECTS_FILE)
    if sect_name not in data:
        return 0
    
    # Calculate total sect wealth
    total_wealth = 0
    for member_id in data[sect_name].get("members", []):
        cash, bank = get_balances(member_id)
        total_wealth += cash + bank
    
    # Store total wealth for ranking
    data[sect_name]["total_wealth"] = total_wealth
    save_json(SECTS_FILE, data)
    
    # Get all sects and sort by wealth
    sects = []
    for name, sect_data in data.items():
        if "total_wealth" in sect_data:
            sects.append((name, sect_data["total_wealth"]))
    
    sects.sort(key=lambda x: x[1], reverse=True)
    
    # Find rank
    for i, (name, _) in enumerate(sects):
        if name == sect_name:
            return i + 1
    
    return 0

def update_top_sect_boosters():
    """Update top 3 sect boosters based on current wealth rankings"""
    data = load_json(SECTS_FILE)
    
    # Calculate wealth for all sects
    sects = []
    for sect_name, sect_data in data.items():
        total_wealth = 0
        for member_id in sect_data.get("members", []):
            cash, bank = get_balances(member_id)
            total_wealth += cash + bank
        sect_data["total_wealth"] = total_wealth
        sects.append((sect_name, total_wealth))
    
    # Sort by wealth
    sects.sort(key=lambda x: x[1], reverse=True)
    
    # Update rankings
    for i, (sect_name, _) in enumerate(sects[:3]):
        rank = i + 1
        data[sect_name]["rank"] = rank
        if rank in TOP_SECT_BOOSTERS:
            data[sect_name]["rank_info"] = TOP_SECT_BOOSTERS[rank]
    
    save_json(SECTS_FILE, data)


# Sect shop commands will be moved to after the bot is defined


# Sect upgrade command will be moved to after the bot is defined


# Sect boosts command will be moved to after the bot is defined


# Sect contribute command will be moved to after the bot is defined


# Sect funds command will be moved to after the bot is defined


# Sect leaderboard command will be moved to after the bot is defined


# Admin command and constants will be moved to after the bot is defined

# -----------------------
# Equipment Management Functions
# -----------------------

def generate_weapon(weapon_type: str, rarity: str) -> dict:
    """Generate a weapon with specified type and rarity"""
    if weapon_type not in WEAPON_TYPES:
        weapon_type = random.choice(list(WEAPON_TYPES.keys()))
    
    # Use new balanced damage system - BUFFED EPIC+ WEAPONS
    if rarity == "common":
        final_damage = random.randint(1, 3)
    elif rarity == "uncommon":
        final_damage = random.randint(3, 5)
    elif rarity == "rare":
        final_damage = random.randint(5, 10)
    elif rarity == "epic":
        final_damage = random.randint(12, 16)  # BUFFED: was 10-13
    elif rarity == "legendary":
        final_damage = random.randint(18, 25)  # BUFFED: was 15-20
    elif rarity == "mythic":
        final_damage = random.randint(25, 50)  # BUFFED: was 20-40
    elif rarity == "divine":
        final_damage = random.randint(60, 120)  # BUFFED: was 50-100
    elif rarity == "primordial":
        final_damage = 1200  # BUFFED: was 1000
    else:
        final_damage = random.randint(1, 3)  # fallback
    
    # Use new direct pricing system
    weapon_sell_prices = {
        "common": 1200, "uncommon": 5600, "rare": 60000, "epic": 240000,
        "legendary": 2000000, "mythic": random.randint(20000000, 50000000),
        "divine": 400000000, "primordial": 1000000000
    }
    final_value = weapon_sell_prices.get(rarity, 1200)
    
    # Apply randomization based on rarity
    if rarity in ["legendary", "mythic", "divine", "primordial"]:
        random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
        final_value = int(final_value * random_factor)
    else:
        random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
        final_value = int(final_value * random_factor)
    
    item = {
        "type": "weapon",
        "weapon_type": weapon_type,
        "rarity": rarity,
        "damage": final_damage,
        "emoji": WEAPON_TYPES[weapon_type]["emoji"],
        "name": f"{rarity.title()} {weapon_type.title()}",
        "description": WEAPON_TYPES[weapon_type]["description"],
        "value": final_value,
        "created_at": datetime.now(timezone.utc).isoformat()
    }
    
    # Apply bonus effects for legendary+ weapons
    return apply_item_bonus_effects(item)

def generate_armor(armor_type: str, rarity: str) -> dict:
    """Generate armor with specified type and rarity"""
    if armor_type not in ARMOR_TYPES:
        armor_type = random.choice(list(ARMOR_TYPES.keys()))
    
    # Use new balanced health and defense system - REDUCED BY 50%
    if rarity == "common":
        final_health = random.randint(8, 12)
        final_defense = random.randint(1, 2)
    elif rarity == "uncommon":
        final_health = random.randint(12, 25)
        final_defense = random.randint(2, 4)
    elif rarity == "rare":
        final_health = random.randint(25, 50)
        final_defense = random.randint(4, 8)
    elif rarity == "epic":
        final_health = random.randint(50, 100)
        final_defense = random.randint(8, 12)
    elif rarity == "legendary":
        final_health = random.randint(100, 200)
        final_defense = random.randint(12, 18)
    elif rarity == "mythic":
        final_health = random.randint(200, 400)
        final_defense = random.randint(18, 30)
    elif rarity == "divine":
        final_health = random.randint(400, 750)
        final_defense = random.randint(30, 50)
    elif rarity == "admin":
        final_health = 2500  # Fixed admin health - REDUCED
        final_defense = 100  # Fixed admin defense
    else:
        final_health = random.randint(8, 12)  # fallback - REDUCED
        final_defense = random.randint(1, 2)  # fallback
    
    # Use new direct pricing system
    armor_sell_prices = {
        "common": 1300, "uncommon": 5800, "rare": 70000, "epic": 320000,
        "legendary": 3000000, "mythic": random.randint(30000000, 60000000),
        "divine": 400000000, "primordial": 1000000000
    }
    final_value = armor_sell_prices.get(rarity, 1300)
    
    # Apply randomization based on rarity
    if rarity in ["legendary", "mythic", "divine", "primordial"]:
        random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
        final_value = int(final_value * random_factor)
    else:
        random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
        final_value = int(final_value * random_factor)
    
    item = {
        "type": "armor",
        "armor_type": armor_type,
        "rarity": rarity,
        "health": final_health,
        "defense": final_defense,
        "emoji": ARMOR_TYPES[armor_type]["emoji"],
        "name": f"{rarity.title()} {armor_type.title()} Armor",
        "description": ARMOR_TYPES[armor_type]["description"],
        "value": final_value,
        "created_at": datetime.now(timezone.utc).isoformat()
    }
    
    # Apply bonus effects for legendary+ armor
    return apply_item_bonus_effects(item)

def generate_artifact(artifact_type: str, rarity: str) -> dict:
    """Generate an artifact with specified type and rarity"""
    if artifact_type not in ARTIFACT_TYPES:
        artifact_type = random.choice(list(ARTIFACT_TYPES.keys()))
    
    abilities = ARTIFACT_ABILITIES.get(rarity, ARTIFACT_ABILITIES["common"])
    selected_abilities = random.sample(abilities, min(3, len(abilities)))
    
    # Use new direct pricing system
    artifact_sell_prices = {
        "common": 1500, "uncommon": 6000, "rare": 80000, "epic": 360000,
        "legendary": 4000000, "mythic": random.randint(40000000, 70000000),
        "divine": 400000000, "primordial": 1000000000
    }
    final_value = artifact_sell_prices.get(rarity, 1500)
    
    # Apply randomization based on rarity
    if rarity in ["legendary", "mythic", "divine", "primordial"]:
        random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
        final_value = int(final_value * random_factor)
    else:
        random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
        final_value = int(final_value * random_factor)
    
    item = {
        "type": "artifact",
        "artifact_type": artifact_type,
        "rarity": rarity,
        "emoji": ARTIFACT_TYPES[artifact_type]["emoji"],
        "name": f"{rarity.title()} {artifact_type.title()}",
        "description": ARTIFACT_TYPES[artifact_type]["description"],
        "abilities": selected_abilities,
        "value": final_value,
        "created_at": datetime.now(timezone.utc).isoformat()
    }
    
    # Apply bonus effects for legendary+ artifacts (biggest bonuses)
    return apply_item_bonus_effects(item)

def get_user_equipment(user_id: int) -> dict:
    """Get user's equipped items"""
    try:
        meta = get_user_meta(user_id)
        if not meta or not isinstance(meta, dict):
            print(f"DEBUG: Invalid meta for user {user_id} in get_user_equipment: {meta}")
            return {"weapon": None, "armor": None, "artifacts": []}
        
        equipment = meta.get("equipment", {
            "weapon": None,
            "armor": None,
            "artifacts": []
        })
        
        # Ensure equipment structure is correct
        if not isinstance(equipment, dict):
            print(f"DEBUG: Invalid equipment structure for user {user_id}: {equipment}")
            equipment = {"weapon": None, "armor": None, "artifacts": []}
        
        if "weapon" not in equipment:
            equipment["weapon"] = None
        if "armor" not in equipment:
            equipment["armor"] = None
        if "artifacts" not in equipment:
            equipment["artifacts"] = []
        elif not isinstance(equipment["artifacts"], list):
            print(f"DEBUG: Invalid artifacts list for user {user_id}: {equipment['artifacts']}")
            equipment["artifacts"] = []
        
        # Ensure artifacts list has exactly 3 slots and clean up None values
        if len(equipment["artifacts"]) < 3:
            while len(equipment["artifacts"]) < 3:
                equipment["artifacts"].append(None)
        elif len(equipment["artifacts"]) > 3:
            equipment["artifacts"] = equipment["artifacts"][:3]
        
        return equipment
    except Exception as e:
        print(f"ERROR in get_user_equipment for user {user_id}: {e}")
        return {"weapon": None, "armor": None, "artifacts": []}

def equip_item(user_id: int, item: dict) -> bool:
    """Equip an item to the user"""
    meta = get_user_meta(user_id)
    if "equipment" not in meta:
        meta["equipment"] = {"weapon": None, "armor": None, "artifacts": []}
    
    if item["type"] == "weapon":
        meta["equipment"]["weapon"] = item
    elif item["type"] == "armor":
        meta["equipment"]["armor"] = item
    elif item["type"] == "artifact":
        # Find first available slot (None or empty)
        artifacts = meta["equipment"]["artifacts"]
        
        # Ensure artifacts list has exactly 3 slots
        while len(artifacts) < 3:
            artifacts.append(None)
        
        # Find first None slot
        slot_index = None
        for i, artifact in enumerate(artifacts):
            if artifact is None:
                slot_index = i
                break
        
        if slot_index is None:
            return False  # All slots are full
        
        meta["equipment"]["artifacts"][slot_index] = item
    
    # Save the updated metadata (not just equipment)
    set_user_meta(user_id, meta)
    
    return True

def unequip_item(user_id: int, item_type: str, item_index: int = None) -> dict:
    """Unequip an item from the user"""
    meta = get_user_meta(user_id)
    if "equipment" not in meta:
        return None
    
    # Ensure equipment structure exists
    if "equipment" not in meta:
        meta["equipment"] = {"weapon": None, "armor": None, "artifacts": []}
    
    if item_type == "weapon":
        item = meta["equipment"]["weapon"]
        if item:
            meta["equipment"]["weapon"] = None
        else:
            return None
    elif item_type == "armor":
        item = meta["equipment"]["armor"]
        if item:
            meta["equipment"]["armor"] = None
        else:
            return None
    elif item_type == "artifact":
        if item_index is None or item_index < 0 or item_index >= len(meta["equipment"]["artifacts"]):
            return None
        if meta["equipment"]["artifacts"][item_index]:
            item = meta["equipment"]["artifacts"][item_index]
            meta["equipment"]["artifacts"][item_index] = None
        else:
            return None
    else:
        return None
    
    # Save the updated metadata (not just equipment)
    set_user_meta(user_id, meta)
    return item

def calculate_combat_stats(user_id: int) -> dict:
    """Calculate user's combat stats from equipment and attributes.
    Robust to partially missing or None equipment entries."""
    try:
        attributes, _ = get_user_attributes(user_id)
        equipment = get_user_equipment(user_id)
        
        # Ensure we have valid data
        if not isinstance(attributes, dict):
            print(f"WARNING: Invalid attributes for user {user_id}: {attributes}")
            attributes = {"strength": 0, "luck": 0, "longevity": 0, "defence": 0}
        
        if not isinstance(equipment, dict):
            print(f"WARNING: Invalid equipment for user {user_id}: {equipment}")
            equipment = {"weapon": None, "armor": None, "artifacts": []}
    except Exception as e:
        print(f"ERROR in calculate_combat_stats for user {user_id}: {e}")
        attributes = {"strength": 0, "luck": 0, "longevity": 0, "defence": 0}
        equipment = {"weapon": None, "armor": None, "artifacts": []}
    
    base_damage = attributes.get("strength", 0) * 2
    base_defense = attributes.get("defence", 0) * 2
    
    # Add weapon damage (guard for None/invalid)
    weapon_damage = 0
    if isinstance(equipment.get("weapon"), dict):
        weapon_damage = int(equipment["weapon"].get("damage", 0))
    
    # Add armor health (guard for None/invalid)
    armor_health = 0
    if isinstance(equipment.get("armor"), dict):
        armor_health = int(equipment["armor"].get("health", 0))
    
    # Add artifact bonuses, ignore None placeholders
    artifact_bonuses = {
        "damage": 0,
        "defense": 0,
        "health": 0,
        "critical_chance": 0
    }
    
    for artifact in equipment.get("artifacts", []):
        if not isinstance(artifact, dict):
            continue
        abilities = artifact.get("abilities", [])
        if "damage" in abilities:
            artifact_bonuses["damage"] += 10
        if "defense" in abilities:
            artifact_bonuses["defense"] += 8
        if "health" in abilities:
            artifact_bonuses["health"] += 50
        if "critical" in abilities:
            artifact_bonuses["critical_chance"] += 5
    
    # Apply Immortal Arts effects
    immortal_effects = get_art_effects(user_id)
    damage_bonus_pct = immortal_effects.get("damage_bonus_pct", 0)
    defense_bonus_pct = immortal_effects.get("defense_bonus_pct", 0)
    health_bonus_pct = immortal_effects.get("health_bonus_pct", 0)
    critical_bonus_pct = immortal_effects.get("critical_bonus_pct", 0)
    
    # Calculate final stats with Immortal Arts bonuses
    final_damage = base_damage + weapon_damage + artifact_bonuses["damage"]
    final_defense = base_defense + artifact_bonuses["defense"]  # No more armor defense
    
    # Debug logging for health calculation
    base_hp = 100
    longevity_points = attributes.get("longevity", 0)
    longevity_bonus = longevity_points * 1  # +1 HP per longevity point
    total_health = base_hp + longevity_bonus + armor_health + artifact_bonuses["health"]
    
    print(f"DEBUG: Health calculation for user {user_id}:")
    print(f"  Base HP: {base_hp}")
    print(f"  Longevity points: {longevity_points}")
    print(f"  Longevity bonus: {longevity_bonus}")
    print(f"  Armor health: {armor_health}")
    print(f"  Artifact health: {artifact_bonuses['health']}")
    print(f"  Total health: {total_health}")
    
    final_health = total_health
    final_critical = min(25, attributes.get("luck", 0) * 2 + artifact_bonuses["critical_chance"])
    
    # Apply percentage bonuses from Immortal Arts
    if damage_bonus_pct > 0:
        final_damage = int(final_damage * (1 + damage_bonus_pct / 100))
    if defense_bonus_pct > 0:
        final_defense = int(final_defense * (1 + defense_bonus_pct / 100))
    if health_bonus_pct > 0:
        final_health = int(final_health * (1 + health_bonus_pct / 100))
    if critical_bonus_pct > 0:
        final_critical = min(50, final_critical + critical_bonus_pct)  # Cap at 50%
    
    return {
        "attack": final_damage,
        "defense": final_defense,
        "hp": final_health,
        "critical_chance": final_critical,
        "dodge": 0.0,  # Add dodge stat
        "total_damage": final_damage,  # Keep for backward compatibility
        "total_defense": final_defense,  # Keep for backward compatibility
        "total_health": final_health,  # Keep for backward compatibility
        "weapon": equipment["weapon"],
        "armor": equipment["armor"],
        "artifacts": equipment["artifacts"],
        "immortal_arts_bonus": {
            "damage_bonus_pct": damage_bonus_pct,
            "defense_bonus_pct": defense_bonus_pct,
            "health_bonus_pct": health_bonus_pct,
            "critical_bonus_pct": critical_bonus_pct
        }
    }

# Party system removed

# -----------------------
# Expedition Encounters
# -----------------------

def generate_expedition_encounter(user_level: int) -> dict:
    """Generate a random expedition encounter based on user level"""
    encounter_type = random.choice(list(ENCOUNTER_TYPES.keys()))
    encounter_data = ENCOUNTER_TYPES[encounter_type]
    
    # Scale difficulty with user level
    level_multiplier = 1 + (user_level - 1) * 0.1
    
    name = random.choice(encounter_data["names"])
    damage = int(encounter_data["base_damage"] * level_multiplier)
    health = int(encounter_data["base_health"] * level_multiplier)
    
    return {
        "type": encounter_type,
        "name": name,
        "damage": damage,
        "health": health,
        "max_health": health,
        "emoji": encounter_data["emoji"],
        "loot_chance": encounter_data["loot_chance"],
        "level": user_level
    }

def resolve_combat_encounter(user_id: int, encounter: dict) -> dict:
    """Resolve a combat encounter and return results"""
    user_stats = calculate_combat_stats(user_id)
    encounter_health = encounter["health"]
    user_health = user_stats["total_health"]
    
    # Simple combat simulation
    rounds = 0
    max_rounds = 10
    
    while encounter_health > 0 and user_health > 0 and rounds < max_rounds:
        rounds += 1
        
        # User attacks
        user_damage = user_stats["total_damage"]
        if random.random() < user_stats["critical_chance"] / 100:
            user_damage *= 2  # Critical hit
        
        encounter_health -= user_damage
        
        # Encounter attacks back if still alive
        if encounter_health > 0:
            encounter_damage = max(1, encounter["damage"] - user_stats["total_defense"])
            user_health -= encounter_damage
    
    # Determine outcome
    victory = encounter_health <= 0
    experience_gained = encounter["level"] * 50 if victory else encounter["level"] * 10
    
    # Generate loot if victorious
    loot = []
    if victory and random.random() < encounter["loot_chance"]:
        # Higher level encounters have better loot chances
        rarity_roll = random.random()
        if rarity_roll < 0.6:
            rarity = "common"
        elif rarity_roll < 0.8:
            rarity = "uncommon"
        elif rarity_roll < 0.9:
            rarity = "rare"
        elif rarity_roll < 0.95:
            rarity = "legendary"
        elif rarity_roll < 0.98:
            rarity = "mythic"
        else:
            rarity = "divine"
        
        # Generate random equipment
        equipment_type = random.choice(["weapon", "armor", "artifact"])
        if equipment_type == "weapon":
            weapon_type = random.choice(list(WEAPON_TYPES.keys()))
            loot.append(generate_weapon(weapon_type, rarity))
        elif equipment_type == "armor":
            armor_type = random.choice(list(ARMOR_TYPES.keys()))
            loot.append(generate_armor(armor_type, rarity))
        else:
            artifact_type = random.choice(list(ARTIFACT_TYPES.keys()))
            loot.append(generate_artifact(artifact_type, rarity))
    
    return {
        "victory": victory,
        "experience_gained": experience_gained,
        "loot": loot,
        "rounds": rounds,
        "user_health_remaining": max(0, user_health),
        "encounter_name": encounter["name"],
        "encounter_emoji": encounter["emoji"]
    }


# ---- Preconfigured special roles (Axes) ----
# Update these IDs to your guild's roles if they differ.
# Axis role IDs removed - use /add_store_item to create custom items with effects

# Optional realm override roles (priority order). If a member has any of these, use the role's
# name as their displayed Realm instead of the level-based realm. Update IDs to match your guild.
REALM_ROLE_IDS_PRIORITY: List[int] = [
    1360612064149901400,
    1360612008344424584,
    1360611957643804856,
]

def get_member_realm_label(member: Optional[discord.Member], level: int) -> str:
    """Return a title label for display. If the member has any of the configured REALM_ROLE_IDS_PRIORITY
    roles, use the first matching role's name. Otherwise, fall back to the level-based title name.
    """
    if member is not None:
        try:
            role_ids = {r.id for r in (member.roles or [])}
            for rid in REALM_ROLE_IDS_PRIORITY:
                if rid in role_ids:
                    role_obj = member.guild.get_role(rid) if member.guild else None
                    if role_obj:
                        return role_obj.name
        except Exception:
            pass
    return get_sect_realm(level)


def is_admin(ctx: commands.Context) -> bool:
    """Check if user has admin permissions"""
    return ctx.author.guild_permissions.administrator


def is_admin_or_owner(ctx: commands.Context) -> bool:
    """Check if user has admin permissions or is bot owner"""
    return ctx.author.guild_permissions.administrator or ctx.author.id == bot.owner_id

# Party system removed

# Party file functions removed

# All party functions removed


async def admin_command_check(interaction: discord.Interaction) -> bool:
    """Check if user can see admin commands"""
    if interaction.guild is None:
        return False
    return interaction.user.guild_permissions.administrator or interaction.user.id == bot.owner_id


def check_use_limit(user_id: int, item_name: str, use_limit: str) -> Tuple[bool, str]:
    """Check if user can use an item based on its use limit"""
    meta = get_user_meta(user_id)
    use_history = meta.get("item_use_history", {})
    item_history = use_history.get(item_name.lower(), {})
    
    now = datetime.now()
    
    if use_limit == "3_per_day":
        # Check daily limit
        today = now.strftime("%Y-%m-%d")
        daily_count = item_history.get("daily", {}).get(today, 0)
        if daily_count >= 3:
            return False, f"You can only use this item 3 times per day. You've used it {daily_count} times today."
        
        # Update count
        if "daily" not in item_history:
            item_history["daily"] = {}
        item_history["daily"][today] = daily_count + 1
        
    elif use_limit == "1_per_week":
        # Check weekly limit
        week_start = (now - timedelta(days=now.weekday())).strftime("%Y-%m-%d")
        weekly_count = item_history.get("weekly", {}).get(week_start, 0)
        if weekly_count >= 1:
            return False, f"You can only use this item once per week. You've already used it this week."
        
        # Update count
        if "weekly" not in item_history:
            item_history["weekly"] = {}
        item_history["weekly"][week_start] = weekly_count + 1
    
    # Save updated history
    use_history[item_name.lower()] = item_history
    meta["item_use_history"] = use_history
    set_user_meta(user_id, meta)
    
    return True, ""


async def execute_external_xp_command(ctx, user_id: int, xp_amount: int):
    """Execute external XP command for moderation bot"""
    try:
        # Get the user mention
        user_mention = f"<@{user_id}>"
        
        # Construct the command in the format the moderation bot expects
        command = f"/moderation xp add {user_mention} {xp_amount}"
        
        # Execute the command in the same channel
        await ctx.send(command)
        
        return True, f"Executed external XP command: {command}"
    except Exception as e:
        return False, f"Failed to execute external XP command: {str(e)}"



def ensure_default_store_items():
    """Seed the store with default working items if they don't already exist.
    Focuses on weapons, armor, artifacts, ores, and loot that actually work in the system.
    """
    store = load_json(STORE_FILE)
    changed = False

    def add_if_missing(key: str, data: dict):
        nonlocal changed
        k = key.lower()
        if k not in store:
            store[k] = data
            changed = True

    # ===== WEAPONS =====
    add_if_missing(
        "iron_sword",
        {
            "price": 5000,
            "description": "A basic iron sword with balanced stats",
            "stock": 100,
            "min_rank": 0,
            "rarity": "common",
            "type": "weapon",
            "weapon_type": "sword",
            "damage": 15,
            "usable": False,
            "consumable": False
        }
    )

    add_if_missing(
        "steel_katana",
        {
            "price": 15000,
            "description": "A sharp steel katana with increased critical chance",
            "stock": 50,
            "min_rank": 1,
            "rarity": "uncommon",
            "type": "weapon",
            "weapon_type": "sword",
            "damage": 25,
            "critical_chance": 5,
            "usable": False,
            "consumable": False
        }
    )

    add_if_missing(
        "thunder_hammer",
        {
            "price": 50000,
            "description": "A powerful hammer that deals massive damage",
            "stock": 25,
            "min_rank": 2,
            "rarity": "rare",
            "type": "weapon",
            "weapon_type": "hammer",
            "damage": 40,
            "usable": False,
            "consumable": False
        }
    )

    # ===== ARMOR =====
    add_if_missing(
        "leather_vest",
        {
            "price": 3000,
            "description": "Light leather armor providing basic protection",
            "stock": 100,
            "min_rank": 0,
            "rarity": "common",
            "type": "armor",
            "armor_type": "leather",
            "health": 25,
            "defense": 5,
            "usable": False,
            "consumable": False
        }
    )

    add_if_missing(
        "chainmail_armor",
        {
            "price": 12000,
            "description": "Medium chainmail armor with good defense",
            "stock": 50,
            "min_rank": 1,
            "rarity": "uncommon",
            "type": "armor",
            "armor_type": "chainmail",
            "health": 60,
            "defense": 15,
            "usable": False,
            "consumable": False
        }
    )

    add_if_missing(
        "plate_armor",
        {
            "price": 35000,
            "description": "Heavy plate armor with maximum protection",
            "stock": 25,
            "min_rank": 2,
            "rarity": "rare",
            "type": "armor",
            "armor_type": "plate",
            "health": 100,
            "defense": 25,
            "usable": False,
            "consumable": False
        }
    )

    # ===== ARTIFACTS =====
    add_if_missing(
        "luck_charm",
        {
            "price": 8000,
            "description": "A small charm that increases luck",
            "stock": 75,
            "min_rank": 0,
            "rarity": "common",
            "type": "artifact",
            "usable": False,
            "consumable": False
        }
    )

    add_if_missing(
        "strength_ring",
        {
            "price": 20000,
            "description": "A ring that enhances physical strength",
            "stock": 40,
            "min_rank": 1,
            "rarity": "uncommon",
            "type": "artifact",
            "usable": False,
            "consumable": False
        }
    )

    add_if_missing(
        "wisdom_amulet",
        {
            "price": 45000,
            "description": "An amulet that grants wisdom and insight",
            "stock": 20,
            "min_rank": 2,
            "rarity": "rare",
            "type": "artifact",
            "usable": False,
            "consumable": False
        }
    )

    # ===== ORES =====
    add_if_missing(
        "iron_ore",
        {
            "price": 500,
            "description": "Basic iron ore for crafting",
            "stock": 200,
            "min_rank": 0,
            "rarity": "common",
            "type": "ore",
            "usable": False,
            "consumable": False
        }
    )

    add_if_missing(
        "copper_ore",
        {
            "price": 800,
            "description": "Copper ore with good conductivity",
            "stock": 150,
            "min_rank": 0,
            "rarity": "uncommon",
            "type": "ore",
            "usable": False,
            "consumable": False
        }
    )

    add_if_missing(
        "silver_ore",
        {
            "price": 2000,
            "description": "Precious silver ore",
            "stock": 75,
            "min_rank": 1,
            "rarity": "rare",
            "type": "ore",
            "usable": False,
            "consumable": False
        }
    )

    # ===== LOOT =====
    add_if_missing(
        "gemstone",
        {
            "price": 1000,
            "description": "A beautiful gemstone with value",
            "stock": 100,
            "min_rank": 0,
            "rarity": "common",
            "type": "loot",
            "usable": False,
            "consumable": False
        }
    )

    add_if_missing(
        "ancient_coin",
        {
            "price": 3000,
            "description": "An ancient coin with historical value",
            "stock": 60,
            "min_rank": 1,
            "rarity": "uncommon",
            "type": "loot",
            "usable": False,
            "consumable": False
        }
    )

    add_if_missing(
        "crystal_shard",
        {
            "price": 8000,
            "description": "A crystal shard with magical properties",
            "stock": 30,
            "min_rank": 2,
            "rarity": "rare",
            "type": "loot",
            "usable": False,
            "consumable": False
        }
    )

    # ===== WORKING CONSUMABLES =====
    add_if_missing(
        "healing_pill",
        {
            "price": 1500,
            "description": "A pill that restores health in PvP battles",
            "stock": 100,
            "min_rank": 0,
            "rarity": "common",
            "type": "consumable",
            "usable": True,
            "consumable": True,
            "effects": {
                "heal": 25
            }
        }
    )

    add_if_missing(
        "strength_potion",
        {
            "price": 5000,
            "description": "A potion that temporarily increases strength",
            "stock": 50,
            "min_rank": 1,
            "rarity": "uncommon",
            "type": "consumable",
            "usable": True,
            "consumable": True,
            "effects": {
                "strength_boost": 5,
                "duration": 3600  # 1 hour
            }
        }
    )

    if changed:
        save_json(STORE_FILE, store)
        print("Default store items updated with working items")


def reset_daily_store_items():
    """Reset daily store items stock and refresh popular items"""
    store = load_json(STORE_FILE)
    changed = False
    
    # Reset stock for popular items
    popular_items = ["iron_sword", "leather_vest", "healing_pill", "iron_ore", "gemstone"]
    
    for item_key in popular_items:
        if item_key in store:
            current_stock = store[item_key].get("stock", 0)
            max_stock = store[item_key].get("max_stock", 100)
            
            if current_stock < max_stock:
                store[item_key]["stock"] = max_stock
                changed = True
    
    if changed:
        save_json(STORE_FILE, store)
        print("Daily store items refreshed")


# Default store seeding disabled per user preference (keep store.json exactly as edited)


# Economy primitives
def _ensure_user_entry(user_id):
    data = load_json(DATA_FILE)
    if str(user_id) not in data:
        data[str(user_id)] = {
            "cash": 0,
            "bank": 0,
            "job": None,
            "last_cultivate": None,
            "last_collect": None,
            "inventory": []
        }
        save_json(DATA_FILE, data)
    return data


def migrate_money_data():
    """Migrate all user money data from economy.json to user_money.json"""
    money_data = load_json(MONEY_FILE)
    economy_data = load_json(DATA_FILE)
    migrated_count = 0
    
    for user_id, user_data in economy_data.items():
        if user_id not in money_data:
            cash = user_data.get("cash", 0)
            bank = user_data.get("bank", 0)
            money_data[user_id] = {"cash": cash, "bank": bank}
            migrated_count += 1
    
    if migrated_count > 0:
        print(f"DEBUG: Migrated {migrated_count} users' money data from economy.json to user_money.json")
        save_json(MONEY_FILE, money_data)
    return migrated_count


def _ensure_money_entry(user_id):
    money_data = load_json(MONEY_FILE)
    if str(user_id) not in money_data:
        # Try to get existing balances from economy.json
        economy_data = load_json(DATA_FILE)
        if str(user_id) in economy_data:
            cash = economy_data[str(user_id)].get("cash", 0)
            bank = economy_data[str(user_id)].get("bank", 0)
            money_data[str(user_id)] = {"cash": cash, "bank": bank}
            print(f"DEBUG: Migrated user {user_id} money data from economy.json to user_money.json")
        else:
            money_data[str(user_id)] = {"cash": 0, "bank": 0}
            print(f"DEBUG: Created new money entry for user {user_id}")
        save_json(MONEY_FILE, money_data)


def get_balances(user_id):
    # Get money from separate money file
    money_data = load_json(MONEY_FILE)
    if str(user_id) not in money_data:
        _ensure_money_entry(user_id)
        money_data = load_json(MONEY_FILE)
    entry = money_data.get(str(user_id), {})
    return int(entry.get("cash", 0)), int(entry.get("bank", 0))


def set_cash(user_id, amount):
    money_data = load_json(MONEY_FILE)
    money_data.setdefault(str(user_id), {"cash": 0, "bank": 0})
    # Allow negative balances for loans and admin purposes
    money_data[str(user_id)]["cash"] = int(amount)
    print(f"DEBUG: set_cash - Setting user {user_id} cash to {amount}")
    save_json(MONEY_FILE, money_data)


def set_bank(user_id, amount):
    money_data = load_json(MONEY_FILE)
    money_data.setdefault(str(user_id), {"cash": 0, "bank": 0})
    # Allow negative balances for loans and admin purposes
    money_data[str(user_id)]["bank"] = int(amount)
    print(f"DEBUG: set_bank - Setting user {user_id} bank to {amount}")
    save_json(MONEY_FILE, money_data)


def add_cash(user_id, amount):
    cash, bank = get_balances(user_id)
    new_amount = cash + int(amount)
    print(f"DEBUG: add_cash - User {user_id} had {cash} cash, adding {amount}, new total: {new_amount}")
    set_cash(user_id, new_amount)
    return new_amount


def add_bank(user_id, amount):
    cash, bank = get_balances(user_id)
    new_amount = bank + int(amount)
    print(f"DEBUG: add_bank - User {user_id} had {bank} bank, adding {amount}, new total: {new_amount}")
    set_bank(user_id, new_amount)
    return new_amount


def fix_old_user_data(user_id: int) -> dict:
    """Fix old user data by ensuring proper structure for equipment, inventory, sect, and job"""
    data = load_json(DATA_FILE)
    user_data = data.get(str(user_id), {})
    
    # Fix inventory structure
    if "inventory" not in user_data:
        user_data["inventory"] = []
    elif isinstance(user_data["inventory"], str):
        # Convert old string inventory to list
        user_data["inventory"] = []
    
    # Fix equipment structure
    if "equipment" not in user_data:
        user_data["equipment"] = {"weapon": None, "armor": None, "artifacts": []}
    elif not isinstance(user_data["equipment"], dict):
        # Reset corrupted equipment
        user_data["equipment"] = {"weapon": None, "armor": None, "artifacts": []}
    else:
        # Ensure all equipment slots exist
        if "weapon" not in user_data["equipment"]:
            user_data["equipment"]["weapon"] = None
        if "armor" not in user_data["equipment"]:
            user_data["equipment"]["armor"] = None
        if "artifacts" not in user_data["equipment"]:
            user_data["equipment"]["artifacts"] = []
        elif not isinstance(user_data["equipment"]["artifacts"], list):
            user_data["equipment"]["artifacts"] = []
    
    # Fix attributes structure
    if "attributes" not in user_data:
        user_data["attributes"] = {"strength": 0, "defence": 0, "longevity": 0, "luck": 0}
    elif not isinstance(user_data["attributes"], dict):
        user_data["attributes"] = {"strength": 0, "defence": 0, "longevity": 0, "luck": 0}
    
    # Fix sect structure - preserve existing sect data
    if "sect" not in user_data:
        user_data["sect"] = None
    if "sect_rank" not in user_data:
        user_data["sect_rank"] = None
    
    # Fix job structure - preserve existing job data
    if "job" not in user_data:
        user_data["job"] = None
    if "selected_job" not in user_data:
        user_data["selected_job"] = None
    
    # Save fixed data
    data[str(user_id)] = user_data
    save_json(DATA_FILE, data)
    return user_data

# This function was duplicated - using the first definition above


# This function was duplicated - using the first definition above


def parse_amount_arg(arg, reference_amount):
    if arg is None:
        return None
    if isinstance(arg, int):
        return arg
    s = str(arg).strip().lower()
    if s == "all":
        return int(reference_amount)
    if s == "half":
        return int(reference_amount // 2)
    
    # Handle shortened number formats (1k, 1m, 1b, etc.)
    if s.endswith('k'):
        try:
            number = float(s[:-1])
            return int(number * 1000)
        except (ValueError, TypeError):
            pass
    elif s.endswith('m'):
        try:
            number = float(s[:-1])
            return int(number * 1000000)
        except (ValueError, TypeError):
            pass
    elif s.endswith('b'):
        try:
            number = float(s[:-1])
            return int(number * 1000000000)
        except (ValueError, TypeError):
            pass
    
    # Handle full number formats (1000, 1000000, 1000000000, etc.)
    try:
        return int(s)
    except (ValueError, TypeError):
        return None


# Test function for amount parsing (can be removed in production)
def test_amount_parsing():
    """Test the amount parsing function with various inputs"""
    test_cases = [
        ("1k", 1000),
        ("10k", 10000),
        ("100k", 100000),
        ("1.5k", 1500),
        ("1m", 1000000),
        ("10m", 10000000),
        ("100m", 100000000),
        ("1.5m", 1500000),
        ("1b", 1000000000),
        ("10b", 10000000000),
        ("100b", 100000000000),
        ("1.5b", 1500000000),
        ("1000", 1000),
        ("1000000", 1000000),
        ("1000000000", 1000000000),
        ("all", 50000),  # Assuming reference_amount is 50000
        ("half", 25000),  # Assuming reference_amount is 50000
        ("invalid", None),
        ("", None),
        (None, None)
    ]
    
    print("Testing amount parsing:")
    for test_input, expected in test_cases:
        result = parse_amount_arg(test_input, 50000)
        status = "✅" if result == expected else "❌"
        print(f"{status} '{test_input}' -> {result} (expected: {expected})")


# Uncomment the line below to test amount parsing
# test_amount_parsing()


# Simple embed helper
async def send_embed(ctx, title: str, description: str = None, color: int = 0x2f3136):
    # Send-once limiter per command invocation
    if getattr(ctx, "_sent_once", False):
        return
    embed = discord.Embed(title=title, color=color)
    if description:
        embed.description = description
    
    # Handle both regular commands and hybrid commands
    if hasattr(ctx, 'interaction') and ctx.interaction:
        # Hybrid command - use interaction response
        if not ctx.interaction.response.is_done():
            await ctx.interaction.response.send_message(embed=embed)
        else:
            await ctx.interaction.followup.send(embed=embed)
    else:
        # Regular command - use ctx.send
        await ctx.send(embed=embed)
    
    setattr(ctx, "_sent_once", True)


async def send_text_once(ctx, content: str):
    if getattr(ctx, "_sent_once", False):
        return
    
    # Handle both regular commands and hybrid commands
    if hasattr(ctx, 'interaction') and ctx.interaction:
        # Hybrid command - use interaction response
        if not ctx.interaction.response.is_done():
            await ctx.interaction.response.send_message(content=content)
        else:
            await ctx.interaction.followup.send(content=content)
    else:
        # Regular command - use ctx.send
        await ctx.send(content)
    
    setattr(ctx, "_sent_once", True)

# Simple cache for last search results used by selection numbers
RECENT_MEMBER_SEARCH = {}

# Loan system constants
LOAN_FILE = os.path.join(DATA_DIR, "loans.json")
LOAN_MIN_AMOUNT = 1000      # Minimum loan amount
LOAN_MAX_AMOUNT = 10000000  # Maximum loan amount (10M)
LOAN_MAX_DURATION_DAYS = 365  # Maximum loan duration
LOAN_DAILY_COLLECTION_RATE = 0.1  # Collect 10% of debt daily when in negative


def resolve_member_argument(ctx, member_or_name):
    """Resolve by mention/id, numeric selection, or substring.
    When ambiguous, caches candidates and returns None (caller should show list)."""
    if not ctx.guild:
        return None
    s = str(member_or_name).strip()
    # numeric selection
    if s.isdigit():
        key = (ctx.guild.id, ctx.author.id, ctx.command.qualified_name)
        ids = RECENT_MEMBER_SEARCH.get(key, [])
        idx = int(s) - 1
        if 0 <= idx < len(ids):
            return ctx.guild.get_member(ctx.guild.id, ids[idx])
        return None
    # mention/id
    digits = ''.join(ch for ch in s if ch.isdigit())
    if digits:
        try:
            mem = ctx.guild.get_member(int(digits))
            if mem:
                return mem
        except Exception:
            pass
    # substring
    matches = [m for m in ctx.guild.members if s.lower() in (m.display_name or m.name).lower()]
    if len(matches) == 1:
        return matches[0]
    if len(matches) > 1:
        RECENT_MEMBER_SEARCH[(ctx.guild.id, ctx.author.id, ctx.command.qualified_name)] = [m.id for m in matches[:10]]
    return None


# -----------------------
# Loan System Functions
# -----------------------

def load_loans():
    """Load loans data from file"""
    try:
        print(f"DEBUG: Loading loans from {LOAN_FILE}")
        if not os.path.exists(LOAN_FILE):
            print(f"DEBUG: Loans file {LOAN_FILE} does not exist, creating empty loans data")
            return {}
        
        loans_data = load_json(LOAN_FILE)
        print(f"DEBUG: Loaded {len(loans_data)} loans")
        print(f"DEBUG: Loans data keys: {list(loans_data.keys()) if loans_data else 'None'}")
        return loans_data
    except Exception as e:
        print(f"Error loading loans: {e}")
        return {}

def save_loans(loans_data):
    """Save loans data to file"""
    try:
        print(f"DEBUG: Saving loans to {LOAN_FILE}")
        print(f"DEBUG: Loans data keys: {list(loans_data.keys())}")
        print(f"DEBUG: Loans data count: {len(loans_data)}")
        
        # Ensure the data directory exists
        os.makedirs(os.path.dirname(LOAN_FILE), exist_ok=True)
        
        save_json(LOAN_FILE, loans_data)
        print(f"DEBUG: Loans saved successfully")
        
        # Verify the save
        if os.path.exists(LOAN_FILE):
            file_size = os.path.getsize(LOAN_FILE)
            print(f"DEBUG: Loans file size: {file_size} bytes")
            return True
        else:
            print(f"ERROR: Loans file was not created!")
            return False
    except Exception as e:
        print(f"Error saving loans: {e}")
        return False

def get_user_loans(user_id: int):
    """Get all loans for a user (as borrower or lender)"""
    loans = load_loans()
    user_loans = {
        "borrowed": [],
        "lent": []
    }
    
    print(f"DEBUG: Getting loans for user {user_id}")
    print(f"DEBUG: Total loans available: {len(loans)}")
    
    for loan_name, loan in loans.items():
        print(f"DEBUG: Checking loan {loan_name}: borrower_id={loan.get('borrower_id')}, lender_id={loan.get('lender_id')}")
        if loan.get("borrower_id") == user_id:
            user_loans["borrowed"].append(loan_name)
            print(f"DEBUG: Added {loan_name} to borrowed loans")
        elif loan.get("lender_id") == user_id:
            user_loans["lent"].append(loan_name)
            print(f"DEBUG: Added {loan_name} to lent loans")
    
    print(f"DEBUG: User {user_id} has {len(user_loans['borrowed'])} borrowed and {len(user_loans['lent'])} lent loans")
    return user_loans

def create_loan(lender_id: int, borrower_id: int, amount: int, duration_days: int, interest_percent: float, description: str = "", loan_name: str = ""):
    """Create a new loan"""
    loans = load_loans()
    
    # Generate unique loan name if none provided
    if not loan_name:
        current_timestamp = int(time.time())
        loan_name = f"Loan_{current_timestamp % 1000000}"
    
    # Calculate total amount to repay from percent
    safe_percent = max(0.0, float(interest_percent))
    interest_amount = int(amount * (safe_percent / 100.0))
    total_to_repay = amount + interest_amount
    
    # Calculate daily payment when in debt
    daily_payment = int(total_to_repay * LOAN_DAILY_COLLECTION_RATE)
    
    # Get current timestamp
    current_timestamp = int(time.time())
    
    loan_data = {
        "loan_name": loan_name,
        "lender_id": lender_id,
        "borrower_id": borrower_id,
        "amount": amount,
        "interest_percent": safe_percent,
        "interest_amount": interest_amount,
        "total_to_repay": total_to_repay,
        "daily_payment": daily_payment,
        "duration_days": duration_days,
        "description": description,
        "created_at": current_timestamp,
        "grace_period_end": int(current_timestamp + 86400),  # 1 day grace period
        "due_date": int(current_timestamp + (duration_days * 86400)),  # 86400 seconds = 1 day
        "status": "active",  # active, repaid, defaulted
        "amount_paid": 0,
        "last_payment": None,
        "debt_collection_started": False  # Track if debt collection has begun
    }
    
    print(f"DEBUG: Creating loan {loan_name}")
    print(f"DEBUG: Loan data: {loan_data}")
    
    loans[loan_name] = loan_data
    save_success = save_loans(loans)
    
    print(f"DEBUG: Loan save success: {save_success}")
    print(f"DEBUG: Total loans after save: {len(loans)}")
    
    # Verify loan was saved
    verify_loans = load_loans()
    if loan_name in verify_loans:
        print(f"DEBUG: Loan {loan_name} successfully verified in saved data")
    else:
        print(f"ERROR: Loan {loan_name} not found in saved data!")
    
    return loan_name, loan_data

def process_loan_payment(loan_name: str, payment_amount: int):
    """Process a loan payment"""
    loans = load_loans()
    if loan_name not in loans:
        return False, "Loan not found"
    
    loan = loans[loan_name]
    if loan["status"] != "active":
        return False, "Loan is not active"
    
    print(f"DEBUG: Processing payment of {payment_amount} for loan {loan_name}")
    print(f"DEBUG: Current amount paid: {loan['amount_paid']}, total to repay: {loan['total_to_repay']}")
    
    # Update payment info using simple integer timestamp
    loan["amount_paid"] += payment_amount
    loan["last_payment"] = int(time.time())
    
    print(f"DEBUG: New amount paid: {loan['amount_paid']}")
    
    # Check if loan is fully repaid
    if loan["amount_paid"] >= loan["total_to_repay"]:
        loan["status"] = "repaid"
        loan["amount_paid"] = loan["total_to_repay"]  # Cap at total amount
        print(f"DEBUG: Loan {loan_name} marked as repaid")
    
    save_success = save_loans(loans)
    if save_success:
        print(f"DEBUG: Loan payment saved successfully")
        return True, "Payment processed"
    else:
        print(f"ERROR: Failed to save loan payment")
        return False, "Failed to save payment"

def collect_debt_daily():
    """Collect debt from users after grace period ends"""
    try:
        loans = load_loans()
        if not loans:
            print("DEBUG: No loans found, skipping debt collection")
            return
            
        active_loans = [loan for loan in loans.values() if loan["status"] == "active"]
        
        print(f"DEBUG: Collecting debt from {len(active_loans)} active loans")
        current_time = int(time.time())
        
        for loan in active_loans:
            try:
                # Validate loan data
                if not all(key in loan for key in ["borrower_id", "lender_id", "amount", "loan_name"]):
                    print(f"ERROR: Invalid loan data for loan {loan.get('loan_name', 'unknown')}")
                    continue
                    
                borrower_id = loan["borrower_id"]
                lender_id = loan["lender_id"]
                grace_period_end = loan.get("grace_period_end", 0)
                debt_collection_started = loan.get("debt_collection_started", False)
                
                print(f"DEBUG: Checking loan {loan['loan_name']} for borrower {borrower_id}")
                print(f"DEBUG: Grace period ends: {grace_period_end}, current time: {current_time}")
                print(f"DEBUG: Debt collection started: {debt_collection_started}")
                
                # Check if grace period has ended
                if current_time >= grace_period_end and not debt_collection_started:
                    print(f"DEBUG: Grace period ended for loan {loan['loan_name']}, starting debt collection")
                    
                    # Start debt collection - deduct the loan amount from borrower's balance
                    borrower_cash, borrower_bank = get_balances(borrower_id)
                    loan_amount = loan["amount"]
                    
                    # Try to deduct from cash first, then bank
                    if borrower_cash >= loan_amount:
                        # Take from cash
                        new_cash = borrower_cash - loan_amount
                        set_cash(borrower_id, new_cash)
                        # Give money to the lender
                        lender_cash, lender_bank = get_balances(lender_id)
                        set_cash(lender_id, lender_cash + loan_amount)
                        print(f"DEBUG: Deducted {loan_amount} from cash for loan {loan['loan_name']}, gave to lender {lender_id}")
                    elif borrower_bank >= loan_amount:
                        # Take from bank
                        new_bank = borrower_bank - loan_amount
                        set_bank(borrower_id, new_bank)
                        # Give money to the lender
                        lender_cash, lender_bank = get_balances(lender_id)
                        set_bank(lender_id, lender_bank + loan_amount)
                        print(f"DEBUG: Deducted {loan_amount} from bank for loan {loan['loan_name']}, gave to lender {lender_id}")
                    else:
                        # User doesn't have enough money, put them into negative balance
                        total_balance = borrower_cash + borrower_bank
                        debt_amount = loan_amount - total_balance
                        set_cash(borrower_id, -debt_amount)
                        # Give whatever money they had to the lender
                        if total_balance > 0:
                            lender_cash, lender_bank = get_balances(lender_id)
                            set_cash(lender_id, lender_cash + total_balance)
                            print(f"DEBUG: Gave {total_balance} to lender {lender_id} from partial payment")
                        print(f"DEBUG: Put user {borrower_id} into negative balance: -{debt_amount}")
                    
                    # Mark debt collection as started
                    loan["debt_collection_started"] = True
                
                # If debt collection has started, collect daily payments
                if loan.get("debt_collection_started", False):
                    borrower_cash, borrower_bank = get_balances(borrower_id)
                    total_balance = borrower_cash + borrower_bank
                    
                    # If user is in negative balance, collect daily payment
                    if total_balance < 0:
                        daily_payment = loan["daily_payment"]
                        print(f"DEBUG: User {borrower_id} in debt, daily payment: {daily_payment}")
                        
                        # Try to collect from cash first, then bank
                        if borrower_cash >= daily_payment:
                            # Take from cash
                            new_cash = borrower_cash - daily_payment
                            set_cash(borrower_id, new_cash)
                            # Give money to the lender
                            lender_cash, lender_bank = get_balances(lender_id)
                            set_cash(lender_id, lender_cash + daily_payment)
                            process_loan_payment(loan["loan_name"], daily_payment)
                            print(f"DEBUG: Collected {daily_payment} from cash for loan {loan['loan_name']}, gave to lender {lender_id}")
                        elif borrower_bank >= daily_payment:
                            # Take from bank
                            new_bank = borrower_bank - daily_payment
                            set_bank(borrower_id, new_bank)
                            # Give money to the lender
                            lender_cash, lender_bank = get_balances(lender_id)
                            set_cash(lender_id, lender_cash + daily_payment)
                            process_loan_payment(loan["loan_name"], daily_payment)
                            print(f"DEBUG: Collected {daily_payment} from bank for loan {loan['loan_name']}, gave to lender {lender_id}")
                        else:
                            # User can't pay, mark as defaulted
                            loan["status"] = "defaulted"
                            print(f"DEBUG: User {borrower_id} can't pay, marking loan {loan['loan_name']} as defaulted")
                
            except Exception as e:
                print(f"ERROR processing loan {loan.get('loan_name', 'unknown')}: {e}")
                continue
                
        save_success = save_loans(loans)
        if save_success:
            print(f"DEBUG: Debt collection completed and saved")
        else:
            print(f"ERROR: Failed to save debt collection results")
            
    except Exception as e:
        print(f"ERROR in collect_debt_daily: {e}")
        import traceback
        traceback.print_exc()

async def debt_collection_task():
    """Background task that runs debt collection every hour"""
    await bot.wait_until_ready()
    
    while not bot.is_closed():
        try:
            print("DEBUG: Running scheduled debt collection...")
            collect_debt_daily()
            
            # Wait 1 hour before next collection
            await asyncio.sleep(3600)  # 3600 seconds = 1 hour
            
        except Exception as e:
            print(f"ERROR in debt collection task: {e}")
            # Wait 1 hour before retrying
            await asyncio.sleep(3600)

async def auto_restock_task():
    """Background task that runs store restocking every 3 days"""
    await bot.wait_until_ready()
    
    # Create restock tracking file if it doesn't exist
    RESTOCK_TRACKING_FILE = os.path.join(DATA_DIR, "restock_tracking.json")
    ensure_file(RESTOCK_TRACKING_FILE, {"last_restock": 0})
    
    while not bot.is_closed():
        try:
            # Check if it's time to restock (every 3 days = 259200 seconds)
            current_time = time.time()
            tracking_data = load_json(RESTOCK_TRACKING_FILE)
            last_restock = tracking_data.get("last_restock", 0)
            
            if current_time - last_restock >= 259200:  # 3 days
                print("DEBUG: Running scheduled store restock...")
                
                # Perform the restock
                store = load_json(STORE_FILE)
                if store:
                    restocked_count = 0
                    total_items = len(store)
                    
                    for item_key, item_data in store.items():
                        current_stock = item_data.get("stock", 0)
                        
                        # Determine max stock based on item type and rarity
                        rarity = item_data.get("rarity", "common").lower()
                        if "axis" in item_key.lower():
                            max_stock = 10  # Axis items are limited
                        elif "role" in item_key.lower():
                            max_stock = 10  # Role items are limited
                        elif "pill" in item_key.lower():
                            max_stock = 50  # Pills are consumables
                        elif rarity in ["legendary", "mythic", "divine"]:
                            max_stock = 25  # High rarity items are limited
                        elif rarity in ["epic", "rare"]:
                            max_stock = 50  # Medium rarity items
                        else:
                            max_stock = 100  # Common items have higher stock
                        
                        # Update the item with max_stock if it doesn't exist
                        if "max_stock" not in item_data:
                            item_data["max_stock"] = max_stock
                        
                        if current_stock < max_stock:
                            store[item_key]["stock"] = max_stock
                            restocked_count += 1
                    
                    # Save the restocked store
                    save_json(STORE_FILE, store)
                    
                    # Update tracking data
                    tracking_data["last_restock"] = current_time
                    save_json(RESTOCK_TRACKING_FILE, tracking_data)
                    
                    print(f"DEBUG: Auto-restock completed. Restocked {restocked_count} out of {total_items} items.")
                    
                    # Try to send notification to a system channel if available
                    try:
                        for guild in bot.guilds:
                            system_channel = guild.system_channel
                            if system_channel:
                                embed = discord.Embed(
                                    title="🔄 Store Auto-Restock Complete",
                                    description=f"The store has been automatically restocked!",
                                    color=0x2ecc71
                                )
                                embed.add_field(name="Items Restocked", value=f"✅ {restocked_count}", inline=True)
                                embed.add_field(name="Total Items", value=f"📦 {total_items}", inline=True)
                                embed.add_field(name="Next Restock", value="🕐 In 3 days", inline=True)
                                embed.set_footer(text="Auto-restock system")
                                
                                await system_channel.send(embed=embed)
                                break  # Only send to first available system channel
                    except Exception as e:
                        print(f"DEBUG: Could not send restock notification: {e}")
                
                else:
                    print("DEBUG: Store is empty, skipping auto-restock")
            
            # Wait 1 hour before checking again
            await asyncio.sleep(3600)  # 3600 seconds = 1 hour
            
        except Exception as e:
            print(f"ERROR in auto-restock task: {e}")
            # Wait 1 hour before retrying
            await asyncio.sleep(3600)

def get_loan_summary(user_id: int):
    """Get loan summary for a user"""
    loans = load_loans()
    user_loans = get_user_loans(user_id)
    
    total_borrowed = 0
    total_lent = 0
    active_borrowed = 0
    active_lent = 0
    
    for loan_name in user_loans["borrowed"]:
        loan = loans[loan_name]
        if loan["status"] == "active":
            active_borrowed += loan["total_to_repay"] - loan["amount_paid"]
        total_borrowed += loan["total_to_repay"]
    
    for loan_name in user_loans["lent"]:
        loan = loans[loan_name]
        if loan["status"] == "active":
            active_lent += loan["total_to_repay"] - loan["amount_paid"]
        total_lent += loan["total_to_repay"]
    
    return {
        "total_borrowed": total_borrowed,
        "total_lent": total_lent,
        "active_borrowed": active_borrowed,
        "active_lent": active_lent,
        "net_position": total_lent - total_borrowed
    }


# -----------------------
# Sect helpers
# -----------------------
SECT_RANKS = [
    "outer disciple",
    "inner disciple",
    "core disciple",
    "outer elder",
    "inner elder",
    "core elder",
    "sect leader",
    "ancestor",
]

# Additional personal bonus by rank (percent)
RANK_BONUS_PCT = {
    "outer disciple": 0,
    "inner disciple": 2,
    "core disciple": 5,
    "outer elder": 8,
    "inner elder": 12,
    "core elder": 20,
    "sect leader": 25,
    "ancestor": 30,
}

# Maximum number of members per rank
RANK_LIMITS = {
    "outer disciple": float('inf'),  # unlimited
    "inner disciple": float('inf'),  # unlimited
    "core disciple": float('inf'),  # unlimited
    "outer elder": 5,
    "inner elder": 3,
    "core elder": 1,
    "sect leader": 1,
    "ancestor": 1,
}

BASE_PROMOTE_XP = 10  # legacy constant (no longer used for rank thresholds)
    # New leveling: each 5 levels → +1 sect position; uses progressive XP system
    # Level 1: 5,000 XP, Level 2: 6,000 XP, Level 3: 7,000 XP, etc.
# Progressive XP system: starts at 5k, increases by fixed amount per level
BASE_XP_PER_LEVEL = 5000
XP_INCREASE_PER_LEVEL = 1000  # Each level requires 1000 more XP than the previous


# -----------------------
# Sect Leveling (XP → Level)
# -----------------------
def get_member_level_and_progress(user_xp: int):
    """Progressive member level: XP requirement increases by fixed amount per level.
    Returns (level, cur_xp_in_level, needed_to_next, next_level_requirement).
    Level starts at 1.
    """
    xp = max(0, int(user_xp))
    
    # Calculate level using progressive formula
    level = 1
    total_required = 0
    
    while True:
        level_xp_required = BASE_XP_PER_LEVEL + (XP_INCREASE_PER_LEVEL * (level - 1))
        if xp < total_required + level_xp_required:
            break
        total_required += level_xp_required
        level += 1
    
    # Calculate current XP in this level
    cur_in_level = xp - total_required
    needed = level_xp_required - cur_in_level
    
    return level, cur_in_level, needed, level_xp_required


def get_xp_for_level(target_level: int) -> int:
    """Calculate total XP needed to reach a specific level"""
    if target_level <= 1:
        return 0
    
    total_xp = 0
    for level in range(1, target_level):
        level_xp_required = BASE_XP_PER_LEVEL + (XP_INCREASE_PER_LEVEL * (level - 1))
        total_xp += level_xp_required
    
    return total_xp


def get_level_xp_requirement(level: int) -> int:
    """Get XP requirement for a specific level"""
    if level <= 1:
        return 0
    return BASE_XP_PER_LEVEL + (XP_INCREASE_PER_LEVEL * (level - 1))


def get_sect_realm(level: int) -> str:
    """Get the title name based on sect level. Aligns with 5-level title progression."""
    if level >= 25:
        return "True Immortal"
    elif level >= 20:
        return "True Person"
    elif level >= 15:
        return "Esteemed One"
    elif level >= 10:
        return "Cultivator"
    else:
        return "Martial Artist"


def get_decorative_title(level: int, sect_name: str = None) -> str:
    """Get decorative title based on level. Works for both sect members and rogue cultivators.
    
    Title Progression (every 5 levels):
    - Level 0-9: Martial Artist
    - Level 10-14: Cultivator  
    - Level 15-19: Esteemed One
    - Level 20-24: True Person
    - Level 25+: True Immortal
    """
    if level >= 25:
        title = "True Immortal"
    elif level >= 20:
        title = "True Person"
    elif level >= 15:
        title = "Esteemed One"
    elif level >= 10:
        title = "Cultivator"
    else:
        title = "Martial Artist"
    
    if sect_name:
        return f"{sect_name} {title} (Level {level})"
    else:
        return f"Rogue {title} (Level {level})"


# -----------------------
# Autocomplete helpers (slash)
# -----------------------
async def sect_name_autocomplete(interaction: discord.Interaction, current: str):
    data = load_json(SECTS_FILE)
    if not isinstance(data, dict):
        return []
    current = (current or "").lower()
    results = []
    for name in data.keys():
        if current in name.lower():
            results.append(app_commands.Choice(name=name, value=name))
            if len(results) >= 10:
                break
    return results


async def sect_position_autocomplete(interaction: discord.Interaction, current: str):
    cur = (current or "").lower()
    results = []
    for r in SECT_RANKS:
        if cur in r.lower():
            results.append(app_commands.Choice(name=r, value=r))
            if len(results) >= 10:
                break
    return results


async def privacy_autocomplete(interaction: discord.Interaction, current: str):
    options = ["public", "private"]
    cur = (current or "").lower()
    return [app_commands.Choice(name=o, value=o) for o in options if cur in o][:2]


async def sect_path_autocomplete(interaction: discord.Interaction, current: str):
    options = ["righteous", "demonic"]
    cur = (current or "").lower()
    return [app_commands.Choice(name=o.title(), value=o) for o in options if cur in o][:2]


async def sect_upgrade_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for sect upgrade types"""
    choices = []
    for upgrade_id, upgrade_data in SECT_SHOP_UPGRADES.items():
        name = upgrade_data["name"]
        emoji = upgrade_data["emoji"]
        choices.append(app_commands.Choice(name=f"{emoji} {name}", value=upgrade_id))
    
    # Filter by current input
    filtered_choices = [choice for choice in choices if current.lower() in choice.name.lower()]
    
    # Return up to 25 choices (Discord limit)
    return filtered_choices[:25]


async def market_item_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for market items"""
    # Load market items
    load_market()
    
    choices = []
    for item in MARKET_ITEMS:
        if item.get("stock", 0) > 0:  # Only show items in stock
            name = item["name"]
            item_type = item.get("type", "unknown")
            rarity = item.get("rarity", "common")
            cost = item.get("cost", 0)
            display_name = f"{name} ({item_type.title()} - {rarity.title()}) - {MONEY_ICON} {cost:,}"
            choices.append(app_commands.Choice(name=display_name, value=name))
    
    # Filter by current input
    filtered_choices = [choice for choice in choices if current.lower() in choice.name.lower()]
    
    # Return up to 25 choices (Discord limit)
    return filtered_choices[:25]


async def rarity_autocomplete(interaction: discord.Interaction, current: str):
    cur = (current or "").lower()
    return [app_commands.Choice(name=r.title(), value=r) for r in RARITY_LIST if cur in r][:10]

# Immortal art admin autocompletes (must be coroutine functions)
async def ia_action_autocomplete(interaction: discord.Interaction, current: str):
    options = ["view", "reroll", "set", "unlock", "reroll_slot"]
    cur = (current or "").lower()
    return [app_commands.Choice(name=o, value=o) for o in options if cur in o][:5]

async def ia_rarity_autocomplete(interaction: discord.Interaction, current: str):
    keys = list(IMMORTAL_ARTS.keys())
    cur = (current or "").lower()
    return [app_commands.Choice(name=k.title(), value=k) for k in keys if cur in k][:10]

async def ia_name_autocomplete(interaction: discord.Interaction, current: str):
    # If rarity is provided in the autocomplete context, filter by it
    try:
        selected_rarity = (interaction.namespace.get("rarity") or "").lower()
    except Exception:
        selected_rarity = ""
    names = []
    if selected_rarity and selected_rarity in IMMORTAL_ARTS:
        names = list(IMMORTAL_ARTS[selected_rarity].keys())
    else:
        # fallback — all names
        for r, arts in IMMORTAL_ARTS.items():
            names.extend(list(arts.keys()))
    cur = (current or "").lower()
    out = []
    for n in names:
        if cur in n.lower():
            out.append(app_commands.Choice(name=n, value=n))
            if len(out) >= 10:
                break
    return out

async def ia_slot_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for immortal art slots"""
    options = [
        app_commands.Choice(name="Slot 1", value=1),
        app_commands.Choice(name="Slot 2", value=2),
        app_commands.Choice(name="Slot 3", value=3)
    ]
    cur = (current or "").lower()
    return [o for o in options if cur in o.name.lower()]


async def job_name_autocomplete(interaction: discord.Interaction, current: str):
    jobs = load_json(JOBS_FILE)
    if not isinstance(jobs, dict):
        return []
    current = (current or "").lower()
    results = []
    for name in jobs.keys():
        if current in name.lower():
            results.append(app_commands.Choice(name=name, value=name))
            if len(results) >= 10:
                break
    return results


async def store_item_autocomplete(interaction: discord.Interaction, current: str):
    store = load_json(STORE_FILE)
    if not isinstance(store, dict):
        return []
    current = (current or "").lower()
    results = []
    for name in store.keys():
        if current in name.lower():
            results.append(app_commands.Choice(name=name.title(), value=name))
            if len(results) >= 10:
                break
    return results


async def use_item_autocomplete(interaction: discord.Interaction, current: str):
    # Autocomplete for use_item command - only shows items that can be used (no sell all options)
    meta = get_user_meta(interaction.user.id)
    user_inv = meta.get("inventory", [])
    if not isinstance(user_inv, list):
        user_inv = []

    current = (current or "").lower()
    results = []
    
    # Debug logging
    print(f"DEBUG: Use item autocomplete called for user {interaction.user.id}")
    print(f"DEBUG: Current input: '{current}'")
    print(f"DEBUG: User inventory: {user_inv}")
    print(f"DEBUG: Inventory type: {type(user_inv)}")
    print(f"DEBUG: Inventory length: {len(user_inv) if isinstance(user_inv, list) else 'N/A'}")
    
    # Add individual items (no "sell all" options for use_item)
    for item in user_inv:
        if isinstance(item, dict) and "name" in item:
            item_name = item["name"]
            # Skip items without names
            if not item_name:
                continue
            # Check if current input matches item name OR if no input is given (show all items)
            if not current or current in item_name.lower():
                # Add item type and rarity info for better identification
                item_type = item.get("type", "unknown")
                rarity = item.get("rarity", "common")
                display_name = f"{item_name.title()} ({item_type.title()} - {rarity.title()})"
                results.append(app_commands.Choice(name=display_name, value=item_name))
                if len(results) >= 10:
                    break
        elif isinstance(item, str):
            # Handle legacy string items
            if not current or current in item.lower():
                results.append(app_commands.Choice(name=item.title(), value=item))
                if len(results) >= 10:
                    break
    
    # Debug logging for results
    print(f"DEBUG: Returning {len(results)} use item autocomplete results")
    print(f"DEBUG: Results: {results}")
    
    return results


async def inventory_item_autocomplete(interaction: discord.Interaction, current: str):
    # Autocomplete from the player's meta inventory in economy.json
    meta = get_user_meta(interaction.user.id)
    user_inv = meta.get("inventory", [])
    if not isinstance(user_inv, list):
        user_inv = []

    current = (current or "").lower()
    results = []
    
    # Debug logging
    print(f"DEBUG: Autocomplete called for user {interaction.user.id}")
    print(f"DEBUG: Current input: '{current}'")
    print(f"DEBUG: User inventory: {user_inv}")
    print(f"DEBUG: Inventory type: {type(user_inv)}")
    print(f"DEBUG: Inventory length: {len(user_inv) if isinstance(user_inv, list) else 'N/A'}")
    
    # Add "sell all" options if user types "all"
    if current.startswith("all"):
        rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine", "primordial"]
        for rarity in rarities:
            if current in f"all {rarity}".lower():
                results.append(app_commands.Choice(name=f"Sell All {rarity.title()} Items", value=f"all {rarity}"))
                if len(results) >= 10:
                    break
    
    # Add "sell all items" option
    if current.lower() in "sell all":
        results.append(app_commands.Choice(name="🔥 SELL ALL ITEMS (Everything!)", value="all"))
    
    # Add individual items
    for item in user_inv:
        if isinstance(item, dict) and "name" in item:
            item_name = item["name"]
            # Skip items without names
            if not item_name:
                continue
            # Check if current input matches item name OR if no input is given (show all items)
            if not current or current in item_name.lower():
                # Add item type and rarity info for better identification
                item_type = item.get("type", "unknown")
                rarity = item.get("rarity", "common")
                display_name = f"{item_name.title()} ({item_type.title()} - {rarity.title()})"
                results.append(app_commands.Choice(name=display_name, value=item_name))
                if len(results) >= 10:
                    break
        elif isinstance(item, str):
            # Handle legacy string items
            if not current or current in item.lower():
                results.append(app_commands.Choice(name=item.title(), value=item))
                if len(results) >= 10:
                    break
    
    # Debug logging for results
    print(f"DEBUG: Returning {len(results)} autocomplete results")
    print(f"DEBUG: Results: {results}")
    
    return results








async def auction_item_autocomplete(interaction: discord.Interaction, current: str):
    try:
        auctions = load_json(AUCTIONS_FILE)
        if not isinstance(auctions, dict):
            return []
        current = (current or "").lower()
        results = []
        for listing_key in auctions.keys():
            item_name = auctions[listing_key].get("item_name", listing_key)
            price = auctions[listing_key].get("price", 0)
            seller = auctions[listing_key].get("seller", 0)
            
            if current in item_name.lower():
                results.append(app_commands.Choice(
                    name=f"{item_name.title()} - {MONEY_ICON} {price}", 
                    value=listing_key
                ))
                if len(results) >= 10:
                    break
        return results
    except Exception as e:
        print(f"Error in auction autocomplete: {e}")
        return []


async def leaderboard_type_autocomplete(interaction: discord.Interaction, current: str):
    options = ["money", "sect"]
    cur = (current or "").lower()
    return [app_commands.Choice(name=o.title(), value=o) for o in options if cur in o][:2]


async def account_type_autocomplete(interaction: discord.Interaction, current: str):
    options = ["wallet", "bank"]
    cur = (current or "").lower()
    return [app_commands.Choice(name=o.title(), value=o) for o in options if cur in o][:2]


async def roulette_choice_autocomplete(interaction: discord.Interaction, current: str):
    # Add individual numbers 0-36
    number_options = [str(i) for i in range(37)]  # 0-36
    other_options = ["red", "black", "green", "1-18", "19-36", "odd", "even", "1st12", "2nd12", "3rd12"]
    options = number_options + other_options
    cur = (current or "").lower()
    return [app_commands.Choice(name=o.title(), value=o) for o in options if cur in o][:10]


async def gamble_game_autocomplete(interaction: discord.Interaction, current: str):
    options = ["roulette", "blackjack"]
    cur = (current or "").lower()
    return [app_commands.Choice(name=o.title(), value=o) for o in options if cur in o][:10]


async def tictactoe_position_autocomplete(interaction: discord.Interaction, current: str):
    options = ["1", "2", "3", "4", "5", "6", "7", "8", "9"]
    cur = (current or "").lower()
    return [app_commands.Choice(name=o, value=o) for o in options if cur in o][:9]


async def amount_autocomplete(interaction: discord.Interaction, current: str):
    options = ["all", "half", "100", "1k", "10k", "100k", "1m", "10m", "100m", "1b", "10b", "1000", "10000", "100000", "1000000", "10000000", "100000000", "1000000000"]
    cur = (current or "").lower()
    return [app_commands.Choice(name=o, value=o) for o in options if cur in o][:7]


async def weapon_name_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for weapon names"""
    current = (current or "").lower()
    results = []
    
    # Predefined weapon names by rarity
    weapon_names = {
        "common": ["Iron Sword", "Wooden Staff", "Stone Axe", "Bone Dagger", "Copper Spear", "Rusty Blade", "Training Sword"],
        "uncommon": ["Steel Sword", "Iron Staff", "Iron Axe", "Steel Dagger", "Iron Spear", "Silver Blade", "Warrior Sword"],
        "rare": ["Mythril Sword", "Silver Staff", "Steel Axe", "Silver Dagger", "Steel Spear", "Gold Blade", "Knight Sword"],
        "legendary": ["Adamantium Sword", "Gold Staff", "Mythril Axe", "Gold Dagger", "Mythril Spear", "Platinum Blade", "Hero Sword"],
        "mythic": ["Divine Blade", "Platinum Staff", "Adamantium Axe", "Platinum Dagger", "Adamantium Spear", "Diamond Blade", "Legend Sword"],
        "divine": ["Celestial Blade", "Diamond Staff", "Divine Axe", "Diamond Dagger", "Divine Spear", "Ethereal Blade", "God Sword"]
    }
    
    for rarity, names in weapon_names.items():
        for name in names:
            if current in name.lower():
                results.append(app_commands.Choice(name=f"{name} ({rarity})", value=name))
                if len(results) >= 10:
                    break
        if len(results) >= 10:
            break
    
    return results


async def loot_name_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for loot item names"""
    current = (current or "").lower()
    results = []
    
    # Predefined loot names by rarity
    loot_names = {
        "common": ["Health Potion", "Mana Potion", "Bread", "Water", "Bandage", "Torch", "Rope"],
        "uncommon": ["Greater Health Potion", "Greater Mana Potion", "Healing Salve", "Mana Crystal", "Food Ration", "Lantern"],
        "rare": ["Superior Health Potion", "Superior Mana Potion", "Elixir of Life", "Mana Gem", "Feast", "Magical Light"],
        "legendary": ["Potion of Immortality", "Mana Essence", "Phoenix Feather", "Dragon Scale", "Golden Apple", "Eternal Flame"],
        "mythic": ["Elixir of the Gods", "Mana Core", "Phoenix Heart", "Dragon Heart", "Tree of Life", "Sun's Light"],
        "divine": ["Essence of Creation", "Mana Source", "Phoenix Soul", "Dragon Soul", "World Tree", "Divine Light"]
    }
    
    for rarity, names in loot_names.items():
        for name in names:
            if current in name.lower():
                results.append(app_commands.Choice(name=f"{name} ({rarity})", value=name))
                if len(results) >= 10:
                    break
        if len(results) >= 10:
            break
    
    return results


async def ore_name_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for ore names"""
    current = (current or "").lower()
    results = []
    
    # Use the ORE_TYPES from the constants
    for rarity, ores in ORE_TYPES.items():
        for ore in ores:
            if current in ore.lower():
                results.append(app_commands.Choice(name=f"{ore} ({rarity})", value=ore))
                if len(results) >= 10:
                    break
        if len(results) >= 10:
            break
    
    return results


async def item_type_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for item types"""
    current = (current or "").lower()
    types = ["weapon", "armor", "artifact", "consumable", "material", "ore", "spirit_beast"]
    
    results = []
    for item_type in types:
        if current in item_type.lower():
            results.append(app_commands.Choice(name=item_type.title(), value=item_type))
    
    return results


async def inventory_filter_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for inventory filter types"""
    current = (current or "").lower()
    filter_types = ["weapon", "armor", "artifact"]
    
    results = []
    for filter_type in filter_types:
        if current in filter_type.lower():
            results.append(app_commands.Choice(name=filter_type.title(), value=filter_type))
    
    return results


async def inventory_item_name_autocomplete(interaction: discord.Interaction, current: str):
    """Dynamic autocomplete for inventory item names based on section"""
    current = (current or "").lower()
    results = []
    
    # Get the current section from the interaction data if available
    # For now, we'll show all available options
    all_names = []
    
    # Add weapon names
    weapon_names = {
        "common": ["Iron Sword", "Wooden Staff", "Stone Axe", "Bone Dagger", "Copper Spear", "Rusty Blade", "Training Sword"],
        "uncommon": ["Steel Sword", "Iron Staff", "Iron Axe", "Steel Dagger", "Iron Spear", "Silver Blade", "Warrior Sword"],
        "rare": ["Mythril Sword", "Silver Staff", "Steel Axe", "Silver Dagger", "Steel Spear", "Gold Blade", "Knight Sword"],
        "legendary": ["Adamantium Sword", "Gold Staff", "Mythril Axe", "Gold Dagger", "Mythril Spear", "Platinum Blade", "Hero Sword"],
        "mythic": ["Divine Blade", "Platinum Staff", "Adamantium Axe", "Platinum Dagger", "Adamantium Spear", "Diamond Blade", "Legend Sword"],
        "divine": ["Celestial Blade", "Diamond Staff", "Divine Axe", "Diamond Dagger", "Divine Spear", "Ethereal Blade", "God Sword"]
    }
    
    # Add artifact names
    artifact_names = {
        "common": ["Lucky Charm", "Healing Stone", "Light Crystal", "Wind Feather", "Earth Fragment"],
        "uncommon": ["Fortune Ring", "Life Stone", "Fire Crystal", "Storm Feather", "Mountain Fragment"],
        "rare": ["Destiny Ring", "Immortality Stone", "Thunder Crystal", "Hurricane Feather", "Volcano Fragment"],
        "legendary": ["Fate Ring", "Eternal Stone", "Lightning Crystal", "Tornado Feather", "Earthquake Fragment"],
        "mythic": ["Time Ring", "Infinite Stone", "Cosmic Crystal", "Space Feather", "Reality Fragment"],
        "divine": ["Creation Ring", "Omnipotent Stone", "Divine Crystal", "God Feather", "Universe Fragment"]
    }
    
    # Add loot names
    loot_names = {
        "common": ["Health Potion", "Mana Potion", "Bread", "Water", "Bandage", "Torch", "Rope"],
        "uncommon": ["Greater Health Potion", "Greater Mana Potion", "Healing Salve", "Mana Crystal", "Food Ration", "Lantern"],
        "rare": ["Superior Health Potion", "Superior Mana Potion", "Elixir of Life", "Mana Gem", "Feast", "Magical Light"],
        "legendary": ["Potion of Immortality", "Mana Essence", "Phoenix Feather", "Dragon Scale", "Golden Apple", "Eternal Flame"],
        "mythic": ["Elixir of the Gods", "Mana Core", "Phoenix Heart", "Dragon Heart", "Tree of Life", "Sun's Light"],
        "divine": ["Essence of Creation", "Mana Source", "Phoenix Soul", "Dragon Soul", "World Tree", "Divine Light"]
    }
    
    # Add weapon names
    for rarity, names in weapon_names.items():
        for name in names:
            all_names.append(f"{name} ({rarity})")
    
    # Add artifact names
    for rarity, names in artifact_names.items():
        for name in names:
            all_names.append(f"{name} ({rarity})")
    
    # Add loot names
    for rarity, names in loot_names.items():
        for name in names:
            all_names.append(f"{name} ({rarity})")
    
    # Add ore names from constants
    for rarity, ores in ORE_TYPES.items():
        for ore in ores:
            all_names.append(f"{ore} ({rarity})")
    
    # Filter by current input
    for name in all_names:
        if current in name.lower():
            results.append(app_commands.Choice(name=name, value=name.split(" (")[0]))  # Remove rarity suffix
            if len(results) >= 10:
                break
    
    return results


async def user_autocomplete(interaction: discord.Interaction, current: str):
    # Get guild members
    guild = interaction.guild
    if not guild:
        return []
    
    current = (current or "").lower()
    results = []
    
    for member in guild.members:
        if current in member.display_name.lower() or current in member.name.lower():
            results.append(app_commands.Choice(name=f"{member.display_name} ({member.name})", value=str(member.id)))
            if len(results) >= 10:
                break
    
    return results

# -----------------------
# Item rarities
RARITY_LIST = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine", "primordial"]
RARITY_SELL_MULTIPLIER = {
    "common": 1.0,
    "uncommon": 1.25,
    "rare": 1.6,
    "epic": 1.0,
    "legendary": 1.0,
    "mythic": 1.0,
    "divine": 1.0,
    "primordial": 1000.0,
}

# Visuals for store
RARITY_EMOJI = {
    "common": "⚪",
    "uncommon": "🟢",
    "rare": "🔵",
    "epic": "🟣",
    "legendary": "🟠",
    "mythic": "🟣",
    "divine": "🔴",
    "primordial": "⚫",
}
RARITY_COLOR = {
    "common": 0x95a5a6,
    "uncommon": 0x2ecc71,
    "rare": 0x3498db,
    "epic": 0x9b59b6,
    "legendary": 0xe67e22,
    "mythic": 0x9b59b6,
    "divine": 0xff0000,
    "primordial": 0x000000,
}

# Item type emojis for display
ITEM_TYPE_EMOJI = {
    "weapon": "⚔️",
    "armor": "🛡️",
    "artifact": "🔮",
    "consumable": "💊",
    "material": "📦",
    "ore": "⛏️",
    "loot": "💎",
    "store_item": "🛒",
    "unknown": "📦"
}

# -----------------------
# Cultivation Loot System
# -----------------------
CULTIVATION_LOOT_ITEMS = {
    "common": {
        "Spirit Stone": {"base_price": 500, "desc": "A basic spirit stone with minimal energy."},
        "Martial Scroll": {"base_price": 800, "desc": "A scroll containing basic martial techniques."},
    },
    "uncommon": {
        "Cultivators Storage Ring": {"base_price": 20000, "desc": "A ring that can store small items."},
        "Flying Sword": {"base_price": 30000, "desc": "A basic flying sword for transportation."},
    },
    "rare": {
        "Monster Blood": {"base_price": 25000, "desc": "Blood from a powerful monster, useful for alchemy."},
        "Heart Path Pills": {"base_price": 35000, "desc": "Pills that strengthen the heart and spirit."},
    },
    "legendary": {
        "Liberation Pills": {"base_price": 100000, "desc": "Pills that can break through cultivation barriers."},
        "Jade": {"base_price": 150000, "desc": "Pure jade with spiritual properties."},
    },
    "mythic": {
        "Daoist Pill": {"base_price": 50000, "desc": "A legendary pill that can grant immense power."},
    },
    "divine": {
        "Splitting Heavens Fragment": {"base_price": 500000, "desc": "A fragment of the legendary Splitting Heavens technique, worth 500,000 stones."},
        "Divine Essence": {"base_price": 750000, "desc": "Pure divine energy that defies mortal comprehension, worth 750,000 stones."},
        "Heaven's Core": {"base_price": 1000000, "desc": "The core of heaven itself, worth 1,000,000 stones."},
        "Omnipotent Essence": {"base_price": 1500000, "desc": "The essence of omnipotent power, worth 1,500,000 stones."},
        "Creation Fragment": {"base_price": 2500000, "desc": "A fragment of creation itself, worth 2,500,000 stones."},
        "Destiny Essence": {"base_price": 5000000, "desc": "The essence of destiny, worth 5,000,000 stones."},
        "Divinity Shard": {"base_price": 10000000, "desc": "A shard of divinity, worth 10,000,000 stones."},
        "Godhood Essence": {"base_price": 25000000, "desc": "The essence of godhood, worth 25,000,000 stones."},
    }
}

# Crafting System
# -----------------------
# Defines the result of combining two items of the same rarity
CRAFTING_RESULTS = {
    "common": {
        "default": {"name": "Refined Spirit Stone", "rarity": "uncommon", "desc": "A refined spirit stone with enhanced energy.", "base_price": 1200}
    },
    "uncommon": {
        "default": {"name": "Spiritual Essence", "rarity": "rare", "desc": "Concentrated spiritual essence from refined materials.", "base_price": 3000}
    },
    "rare": {
        "default": {"name": "Celestial Core", "rarity": "legendary", "desc": "A core infused with celestial energy.", "base_price": 8000}
    },
    "legendary": {
        "default": {"name": "Divine Fragment", "rarity": "mythic", "desc": "A fragment of divine power.", "base_price": 30000}
    },
    "mythic": {
        "default": {"name": "Divine Core", "rarity": "divine", "desc": "A core of divine power beyond mortal comprehension.", "base_price": 100000}
    },
    # Specific combinations (overrides default)
    "specific": {
        "spirit stone+martial scroll": {"name": "Inscribed Spirit Stone", "rarity": "uncommon", "desc": "A spirit stone inscribed with martial techniques.", "base_price": 1600},
        "monster blood+heart path pills": {"name": "Blood Essence Pill", "rarity": "legendary", "desc": "A powerful pill infused with monster blood essence.", "base_price": 12000},
        "liberation pills+jade": {"name": "Jade Immortality Pill", "rarity": "mythic", "desc": "A legendary pill that can grant immortality.", "base_price": 40000}
    }
}

# Quality variation ranges for store items (chance to get higher rarity)
QUALITY_VARIATION_CHANCES = {
    "common": 0.15,      # 15% chance to get uncommon
    "uncommon": 0.12,    # 12% chance to get rare
    "rare": 0.08,        # 8% chance to get legendary
    "epic": 0.12,        # 12% chance to get epic (new tier)
    "legendary": 0.001,  # 0.1% chance to get mythic (SUPER RARE)
    "mythic": 0.0001,   # 0.01% chance to get divine (ALMOST IMPOSSIBLE)
    "divine": 0.0,       # Divine items can't upgrade further
}

async def rarity_autocomplete(interaction: discord.Interaction, current: str):
    cur = (current or "").lower()
    return [app_commands.Choice(name=r.title(), value=r) for r in RARITY_LIST if cur in r][:10]


async def role_action_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for role actions"""
    actions = ["add", "remove", "toggle"]
    cur = (current or "").lower()
    return [app_commands.Choice(name=action.title(), value=action) for action in actions if cur in action][:10]


async def money_action_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for money actions"""
    actions = ["add", "set", "remove"]
    cur = (current or "").lower()
    return [app_commands.Choice(name=action.title(), value=action) for action in actions if cur in action][:10]


async def lender_name_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for lender names in loan commands"""
    user_id = interaction.user.id
    loans = load_loans()
    
    # Get all lenders for this user's active loans
    lender_names = set()
    for loan_name, loan in loans.items():
        if (loan["borrower_id"] == user_id and 
            loan["lender_id"] != user_id and
            loan["status"] == "active"):
            
            lender = interaction.guild.get_member(loan["lender_id"])
            if lender:
                lender_names.add(lender.display_name)
    
    # Filter by current input
    filtered_names = [name for name in lender_names if current.lower() in name.lower()]
    
    # Return up to 25 choices
    return filtered_names[:25]


async def loan_name_autocomplete(interaction: discord.Interaction, current: str) -> List[app_commands.Choice[str]]:
    """Autocomplete for loan names"""
    try:
        user_id = interaction.user.id
        loans = load_loans()
        user_loans = get_user_loans(user_id)
        
        # Get all loan names for this user (both borrowed and lent)
        all_loan_names = []
        for loan_name in user_loans["borrowed"] + user_loans["lent"]:
            if loan_name.lower().startswith(current.lower()):
                all_loan_names.append(loan_name)
        
        # Return up to 25 choices
        return [app_commands.Choice(name=name, value=name) for name in all_loan_names[:25]]
    except Exception as e:
        print(f"Error in loan name autocomplete: {e}")
        return []


# -----------------------
# Immortal Arts system
# -----------------------
# Registry (removed PvP/Fishing/Stealth-only arts)
# Each art maps to a dict with numeric effect keys and a "desc" string.
IMMORTAL_ARTS: Dict[str, Dict[str, Dict[str, float]]] = {
    "common": {
        "Golden Grain": {"work_income_pct": 5, "desc": "Earn +5% more from work commands."},
        "Lucky Palm": {"roulette_payout_pct": 1.0, "desc": "+1% roulette payout boost."},
        "Silver Tongue": {"sell_price_bonus_pct": 3, "desc": "Sell items for +3% more."},
        "Iron Fist": {"blackjack_payout_pct": 2, "desc": "+2% blackjack payout boost."},
        "Spirit Gatherer": {"cultivate_reward_pct": 1, "desc": "+1% extra cultivation gains."},
        "Merchant's Eye": {"buy_price_discount_pct": 2, "desc": "Shop items cost 2% less."},
        "Quick Step": {"work_cooldown_reduction_pct": 5, "desc": "Work cooldown reduced by 5%."},
        "Steady Hand": {"gambling_loss_reduce_pct": 1, "desc": "Lose 1% less when gambling losses occur."},
        "Stone Skin": {"robbery_protection_pct": 2, "desc": "+2% chance to avoid item loss on theft."},
        "Swift Movement": {"work_cooldown_reduction_pct": 3, "desc": "Work cooldown reduced by 3%."},
        "Sharp Mind": {"gambling_payout_pct": 0.5, "desc": "+0.5% gambling payout boost."},
        "Golden Touch": {"sell_price_bonus_pct": 2, "desc": "Sell items for +2% more."},
        "Lucky Charm": {"roulette_payout_pct": 0.8, "desc": "+0.8% roulette payout boost."},
        "Iron Will": {"robbery_protection_pct": 1, "desc": "+1% chance to avoid item loss on theft."},
        "Spirit Sense": {"cultivate_reward_pct": 0.5, "desc": "+0.5% extra cultivation gains."},
        "Copper Fortune": {"work_income_pct": 3, "desc": "+3% income from work commands."},
        "Iron Resolve": {"robbery_protection_pct": 1.5, "desc": "+1.5% chance to avoid item loss on theft."},
        "Stone Wisdom": {"cultivate_reward_pct": 0.8, "desc": "+0.8% extra cultivation gains."},
        "Coal Heart": {"work_cooldown_reduction_pct": 2, "desc": "Work cooldown reduced by 2%."},
        "Tin Touch": {"sell_price_bonus_pct": 1.5, "desc": "Sell items for +1.5% more."},
        "Bronze Luck": {"roulette_payout_pct": 0.6, "desc": "+0.6% roulette payout boost."},
        "Steel Mind": {"gambling_payout_pct": 0.3, "desc": "+0.3% gambling payout boost."},
        "Crystal Sight": {"work_loot_chance_pct": 2, "desc": "+2% chance to find random loot after working."},
        "Mystic Palm": {"buy_price_discount_pct": 1.5, "desc": "Shop items cost 1.5% less."},
        "Spirit Echo": {"cultivate_reward_pct": 0.7, "desc": "+0.7% extra cultivation gains."},
        "Golden Path": {"work_income_pct": 2.5, "desc": "+2.5% income from work commands."},
        "Silver Wind": {"work_cooldown_reduction_pct": 1.5, "desc": "Work cooldown reduced by 1.5%."},
        "Iron Fortune": {"sell_price_bonus_pct": 1.8, "desc": "Sell items for +1.8% more."},
        "Stone Heart": {"robbery_protection_pct": 1.2, "desc": "+1.2% chance to avoid item loss on theft."},
        "Copper Mind": {"gambling_payout_pct": 0.4, "desc": "+0.4% gambling payout boost."},
        "Tin Spirit": {"roulette_payout_pct": 0.7, "desc": "+0.7% roulette payout boost."},
        "Bronze Touch": {"buy_price_discount_pct": 1.2, "desc": "Shop items cost 1.2% less."},
        "Steel Fortune": {"work_loot_chance_pct": 1.5, "desc": "+1.5% chance to find random loot after working."},
        "Crystal Path": {"cultivate_reward_pct": 0.6, "desc": "+0.6% extra cultivation gains."},
        "Iron Fist": {"damage_bonus_pct": 2, "desc": "+2% bonus to attack damage in combat."},
        "Stone Skin": {"defense_bonus_pct": 2, "desc": "+2% bonus to defense in combat."},
        "Vital Essence": {"health_bonus_pct": 3, "desc": "+3% bonus to maximum health."},
        "Lucky Strike": {"critical_bonus_pct": 1, "desc": "+1% bonus to critical hit chance."},
    },
    # Renamed: original 'rare' → 'uncommon'
    "uncommon": {
        "Moonlight Fortune": {"gambling_payout_pct": 1, "desc": "+1% win chance in all gambling games (payout boost)."},
        "Wind Walker": {"work_income_pct": 8, "desc": "Job shift pays +8% more."},
        "Treasure Seeker": {"work_loot_chance_pct": 5, "desc": "+5% chance to find random loot after working."},
        "Heavenly Dealer": {"blackjack_payout_pct": 4, "desc": "+4% higher payout on blackjack wins."},
        "Serpent's Cunning": {"robbery_protection_pct": 3, "desc": "3% less chance to be robbed by players."},
        "Market Dominator": {"buy_price_discount_pct": 4, "desc": "Shop items cost 4% less."},
        "Spirit Weaver": {"cultivate_reward_pct": 3, "desc": "Cultivation gains +3%."},
        "Golden Luck": {"roulette_payout_pct": 1.5, "desc": "+1.5% better odds in roulette (payout boost)."},
        "River Flow": {"work_cooldown_reduction_pct": 10, "desc": "Work cooldown reduced by 10%."},
        "Shadow Step": {"work_cooldown_reduction_pct": 8, "desc": "Work cooldown reduced by 8%."},
        "Crystal Vision": {"gambling_payout_pct": 1.2, "desc": "+1.2% gambling payout boost."},
        "Mystic Shield": {"robbery_protection_pct": 4, "desc": "+4% chance to avoid item loss on theft."},
        "Golden Harvest": {"work_income_pct": 6, "desc": "Job shift pays +6% more."},
        "Lucky Stars": {"roulette_payout_pct": 1.8, "desc": "+1.8% roulette payout boost."},
        "Spirit Guardian": {"cultivate_reward_pct": 2.5, "desc": "Cultivation gains +2.5%."},
        "Merchant's Fortune": {"sell_price_bonus_pct": 5, "desc": "Sell items for +5% more."},
        "Azure Fortune": {"work_income_pct": 7, "desc": "+7% income from work commands."},
        "Crimson Shield": {"robbery_protection_pct": 5, "desc": "+5% chance to avoid item loss on theft."},
        "Emerald Wisdom": {"cultivate_reward_pct": 3.5, "desc": "+3.5% extra cultivation gains."},
        "Sapphire Flow": {"work_cooldown_reduction_pct": 12, "desc": "Work cooldown reduced by 12%."},
        "Ruby Touch": {"sell_price_bonus_pct": 6, "desc": "Sell items for +6% more."},
        "Amethyst Luck": {"roulette_payout_pct": 2.2, "desc": "+2.2% roulette payout boost."},
        "Topaz Mind": {"gambling_payout_pct": 1.8, "desc": "+1.8% gambling payout boost."},
        "Diamond Sight": {"work_loot_chance_pct": 7, "desc": "+7% chance to find random loot after working."},
        "Pearl Palm": {"buy_price_discount_pct": 5, "desc": "Shop items cost 5% less."},
        "Obsidian Echo": {"cultivate_reward_pct": 3.2, "desc": "+3.2% extra cultivation gains."},
        "Jade Path": {"work_income_pct": 9, "desc": "+9% income from work commands."},
        "Onyx Wind": {"work_cooldown_reduction_pct": 9, "desc": "Work cooldown reduced by 9%."},
        "Garnet Fortune": {"sell_price_bonus_pct": 7, "desc": "Sell items for +7% more."},
        "Quartz Heart": {"robbery_protection_pct": 6, "desc": "+6% chance to avoid item loss on theft."},
        "Opal Mind": {"gambling_payout_pct": 2.1, "desc": "+2.1% gambling payout boost."},
        "Turquoise Spirit": {"roulette_payout_pct": 2.5, "desc": "+2.5% roulette payout boost."},
        "Lapis Touch": {"buy_price_discount_pct": 4.5, "desc": "Shop items cost 4.5% less."},
        "Malachite Fortune": {"work_loot_chance_pct": 6, "desc": "+6% chance to find random loot after working."},
        "Agate Path": {"cultivate_reward_pct": 2.8, "desc": "+2.8% extra cultivation gains."},
        "Moonstone Flow": {"work_cooldown_reduction_pct": 11, "desc": "Work cooldown reduced by 11%."},
        "Steel Fist": {"damage_bonus_pct": 4, "desc": "+4% bonus to attack damage in combat."},
        "Iron Hide": {"defense_bonus_pct": 4, "desc": "+4% bonus to defense in combat."},
        "Life Force": {"health_bonus_pct": 6, "desc": "+6% bonus to maximum health."},
        "Precise Strike": {"critical_bonus_pct": 2, "desc": "+2% bonus to critical hit chance."},
    },
    # Renamed: original 'epic' → 'rare'
    "rare": {
        "Celestial Trader": {"sell_price_bonus_pct": 8, "desc": "Sell items for +8% more."},
        "Dragon's Gambit": {"gambling_payout_pct": 3, "desc": "+3% win rate in all gambling (payout boost)."},
        "Heavenly Flow": {"work_cooldown_reduction_pct": 15, "desc": "Job cooldown reduced by 15%."},
        "Ancient Coin": {"gambling_payout_pct": 5, "desc": "All gambling payouts increased by +5%."},
        "Starlight Wisdom": {"cultivate_reward_pct": 6, "desc": "Cultivation gains +6%."},
        "Imperial Fortune": {"roulette_payout_pct": 2, "desc": "+2% roulette payout boost."},
        "Midas Touch": {"global_gold_gain_pct": 3, "desc": "All gold gains increased by +3%."},
        "Thunder Strike": {"work_income_pct": 12, "desc": "Job shift pays +12% more."},
        "Phoenix Rebirth": {"gambling_loss_avoid_chance_pct": 8, "desc": "8% chance to avoid gambling losses."},
        "Crystal Fortune": {"roulette_payout_pct": 2.5, "desc": "+2.5% roulette payout boost."},
        "Shadow Master": {"robbery_protection_pct": 6, "desc": "+6% chance to avoid item loss on theft."},
        "Golden Dragon": {"sell_price_bonus_pct": 10, "desc": "Sell items for +10% more."},
        "Spirit Emperor": {"cultivate_reward_pct": 7, "desc": "Cultivation gains +7%."},
        "Lucky Phoenix": {"gambling_crit_win_chance_pct": 3, "desc": "+3% critical win chance in gambling."},
        "Mystic Trader": {"buy_price_discount_pct": 6, "desc": "Shop items cost 6% less."},
        "Celestial Shield": {"robbery_protection_pct": 8, "desc": "+8% chance to avoid item loss on theft."},
        "Dragon's Breath": {"work_income_pct": 15, "desc": "+15% income from work commands."},
        "Phoenix Wisdom": {"cultivate_reward_pct": 8, "desc": "+8% extra cultivation gains."},
        "Thunder Flow": {"work_cooldown_reduction_pct": 18, "desc": "Work cooldown reduced by 18%."},
        "Lightning Touch": {"sell_price_bonus_pct": 12, "desc": "Sell items for +12% more."},
        "Storm Luck": {"roulette_payout_pct": 3.5, "desc": "+3.5% roulette payout boost."},
        "Wind Mind": {"gambling_payout_pct": 4.2, "desc": "+4.2% gambling payout boost."},
        "Frost Sight": {"work_loot_chance_pct": 12, "desc": "+12% chance to find random loot after working."},
        "Fire Palm": {"buy_price_discount_pct": 8, "desc": "Shop items cost 8% less."},
        "Ice Echo": {"cultivate_reward_pct": 7.5, "desc": "+7.5% extra cultivation gains."},
        "Earth Path": {"work_income_pct": 14, "desc": "+14% income from work commands."},
        "Water Wind": {"work_cooldown_reduction_pct": 16, "desc": "Work cooldown reduced by 16%."},
        "Nature Fortune": {"sell_price_bonus_pct": 11, "desc": "Sell items for +11% more."},
        "Cosmic Heart": {"robbery_protection_pct": 7, "desc": "+7% chance to avoid item loss on theft."},
        "Void Mind": {"gambling_payout_pct": 3.8, "desc": "+3.8% gambling payout boost."},
        "Ethereal Spirit": {"roulette_payout_pct": 4.5, "desc": "+4.5% roulette payout boost."},
        "Quantum Touch": {"buy_price_discount_pct": 7, "desc": "Shop items cost 7% less."},
        "Time Fortune": {"work_loot_chance_pct": 10, "desc": "+10% chance to find random loot after working."},
        "Space Path": {"cultivate_reward_pct": 6.5, "desc": "+6.5% extra cultivation gains."},
        "Reality Flow": {"work_cooldown_reduction_pct": 17, "desc": "Work cooldown reduced by 17%."},
        "Mythril Fist": {"damage_bonus_pct": 8, "desc": "+8% bonus to attack damage in combat."},
        "Adamantium Hide": {"defense_bonus_pct": 8, "desc": "+8% bonus to defense in combat."},
        "Immortal Essence": {"health_bonus_pct": 12, "desc": "+12% bonus to maximum health."},
        "Death Strike": {"critical_bonus_pct": 4, "desc": "+4% bonus to critical hit chance."},
    },
    "epic": {
        "Celestial Fortune": {"sell_price_bonus_pct": 15, "desc": "Sell items for +15% more."},
        "Dragon's Luck": {"gambling_payout_pct": 6, "desc": "+6% win rate in all gambling (payout boost)."},
        "Heavenly Path": {"work_cooldown_reduction_pct": 22, "desc": "Job cooldown reduced by 22%."},
        "Starlight Fortune": {"gambling_payout_pct": 7, "desc": "All gambling payouts increased by +7%."},
        "Ancient Wisdom": {"cultivate_reward_pct": 10, "desc": "Cultivation gains +10%."},
        "Imperial Luck": {"roulette_payout_pct": 5, "desc": "+5% roulette payout boost."},
        "Midas Fortune": {"global_gold_gain_pct": 6, "desc": "All gold gains increased by +6%."},
        "Thunder Path": {"work_income_pct": 18, "desc": "Job shift pays +18% more."},
        "Phoenix Fortune": {"gambling_loss_avoid_chance_pct": 12, "desc": "12% chance to avoid gambling losses."},
        "Crystal Luck": {"roulette_payout_pct": 6, "desc": "+6% roulette payout boost."},
        "Shadow Fortune": {"robbery_protection_pct": 12, "desc": "+12% chance to avoid item loss on theft."},
        "Golden Phoenix": {"sell_price_bonus_pct": 18, "desc": "Sell items for +18% more."},
        "Spirit Fortune": {"cultivate_reward_pct": 12, "desc": "Cultivation gains +12%."},
        "Lucky Dragon": {"gambling_crit_win_chance_pct": 6, "desc": "+6% critical win chance in gambling."},
        "Mystic Fortune": {"buy_price_discount_pct": 10, "desc": "Shop items cost 10% less."},
        "Celestial Shield": {"robbery_protection_pct": 15, "desc": "+15% chance to avoid item loss on theft."},
        "Dragon's Path": {"work_income_pct": 20, "desc": "+20% income from work commands."},
        "Phoenix Wisdom": {"cultivate_reward_pct": 15, "desc": "+15% extra cultivation gains."},
        "Thunder Fortune": {"work_cooldown_reduction_pct": 25, "desc": "Work cooldown reduced by 25%."},
        "Lightning Path": {"sell_price_bonus_pct": 20, "desc": "Sell items for +20% more."},
        "Storm Fortune": {"roulette_payout_pct": 8, "desc": "+8% roulette payout boost."},
        "Wind Path": {"gambling_payout_pct": 8, "desc": "+8% gambling payout boost."},
        "Frost Fortune": {"work_loot_chance_pct": 18, "desc": "+18% chance to find random loot after working."},
        "Fire Path": {"buy_price_discount_pct": 12, "desc": "Shop items cost 12% less."},
        "Ice Fortune": {"cultivate_reward_pct": 12, "desc": "+12% extra cultivation gains."},
        "Earth Fortune": {"work_income_pct": 22, "desc": "+22% income from work commands."},
        "Water Path": {"work_cooldown_reduction_pct": 24, "desc": "Work cooldown reduced by 24%."},
        "Nature Path": {"sell_price_bonus_pct": 19, "desc": "Sell items for +19% more."},
        "Cosmic Fortune": {"robbery_protection_pct": 14, "desc": "+14% chance to avoid item loss on theft."},
        "Void Path": {"gambling_payout_pct": 7, "desc": "+7% gambling payout boost."},
        "Ethereal Fortune": {"roulette_payout_pct": 9, "desc": "+9% roulette payout boost."},
        "Quantum Path": {"buy_price_discount_pct": 11, "desc": "Shop items cost 11% less."},
        "Time Path": {"work_loot_chance_pct": 16, "desc": "+16% chance to find random loot after working."},
        "Space Fortune": {"cultivate_reward_pct": 11, "desc": "+11% extra cultivation gains."},
        "Reality Path": {"work_cooldown_reduction_pct": 23, "desc": "Work cooldown reduced by 23%."},
        "Mythril Path": {"damage_bonus_pct": 12, "desc": "+12% bonus to attack damage in combat."},
        "Adamantium Path": {"defense_bonus_pct": 12, "desc": "+12% bonus to defense in combat."},
        "Immortal Path": {"health_bonus_pct": 18, "desc": "+18% bonus to maximum health."},
        "Death Path": {"critical_bonus_pct": 6, "desc": "+6% bonus to critical hit chance."},
    },
    "legendary": {
        "Purple Soul Filling the Heavens": {"cultivate_reward_pct": 15, "desc": "Cultivation commands give +15% XP and +10% money chance."},
        "Void Gambler": {"blackjack_payout_pct": 8, "roulette_payout_pct": 8, "gambling_crit_win_chance_pct": 8, "desc": "+8% blackjack and roulette payouts, +8% critical win chance."},
        "Emperor's Purse": {"sell_price_bonus_pct": 20, "global_gold_gain_pct": 5, "desc": "Sell prices +20% higher, all earnings +5%."},
        "Cosmic Vision": {"gambling_loss_avoid_chance_pct": 15, "gambling_payout_pct": 10, "desc": "15% chance to avoid gambling losses, +10% gambling payouts."},
        "Sky Emperor": {"work_income_pct": 20, "work_loot_chance_pct": 10, "desc": "Work and job shift give +20% income, +10% loot chance."},
        "Starfall": {"gambling_crit_win_chance_pct": 12, "gambling_payout_pct": 8, "desc": "+12% critical win chance in gambling, +8% gambling payouts."},
        "Tainted Soul Filling The Heavens": {"global_gold_gain_pct": 12, "cultivate_reward_pct": 8, "desc": "All earnings increased by +12%, cultivation +8%."},
        "Eternal Trader": {"buy_price_discount_pct": 15, "sell_price_bonus_pct": 15, "work_income_pct": 10, "desc": "Shop prices -15%, sell prices +15%, work income +10%."},
        "Thunder God": {"work_income_pct": 18, "work_cooldown_reduction_pct": 20, "desc": "+18% work income, -20% work cooldown."},
        "Lucky Dragon": {"gambling_payout_pct": 12, "gambling_crit_win_chance_pct": 8, "desc": "+12% gambling payouts, +8% critical win chance."},
        "Spirit Sovereign": {"cultivate_reward_pct": 18, "global_gold_gain_pct": 8, "desc": "+18% cultivation, +8% all earnings."},
        "Mystic Emperor": {"buy_price_discount_pct": 12, "sell_price_bonus_pct": 18, "desc": "Shop prices -12%, sell prices +18%."},
        "Golden Phoenix": {"roulette_payout_pct": 10, "blackjack_payout_pct": 10, "desc": "+10% roulette and blackjack payouts."},
        "Shadow Lord": {"robbery_protection_pct": 20, "work_loot_chance_pct": 15, "desc": "+20% theft protection, +15% work loot chance."},
        "Cosmic Fortune": {"gambling_loss_avoid_chance_pct": 18, "gambling_payout_pct": 12, "desc": "+18% gambling loss avoidance, +12% gambling payouts."},
        "Luck Path": {"luck_bonus_pct": 25, "gambling_payout_pct": 15, "gambling_crit_win_chance_pct": 10, "work_loot_chance_pct": 20, "desc": "Legendary art of fortune: +25% luck bonus, +15% gambling payouts, +10% critical win chance, +20% work loot chance."},
    },
    "mythic": {
        "Heaven's Mandate": {"all_gains_pct": 25, "desc": "All gains from any source +25%."},
        "Flawless Mantra": {"double_win_chance_pct": 25, "desc": "25% chance to double any gambling winnings."},
        "Impermanence Sword": {"cultivate_reward_pct": 35, "desc": "Cultivation +35%."},
        "The Wheel": {"daily_loss_refund_pct": 75, "desc": "Gambling losses refunded by 75% once per day."},
        "Sunlight Shooting": {"work_income_pct": 30, "sell_price_bonus_pct": 30, "desc": "+30% income from work and shop sales."},
        "Phenomena Extinguishing Mantra": {"gambling_payout_pct": 40, "desc": "+40% payout boost in all gambling games."},
        "Radiance Mantra": {"work_income_pct": 35, "cultivate_reward_pct": 35, "desc": "+35% income from work and cultivation."},
        "Heaven's Thunder": {"work_income_pct": 40, "work_cooldown_reduction_pct": 25, "desc": "+40% work income, -30% work cooldown."},
        "Dragon's Fortune": {"gambling_payout_pct": 40, "gambling_crit_win_chance_pct": 25, "desc": "+40% gambling payouts, +25% critical win chance."},
        "Spirit Ascension": {"cultivate_reward_pct": 40, "global_gold_gain_pct": 20, "desc": "+40% cultivation, +20% all earnings."},
        "Mystic Sovereign": {"buy_price_discount_pct": 25, "sell_price_bonus_pct": 30, "desc": "Shop prices -25%, sell prices +30%."},
        "Golden Ascension": {"roulette_payout_pct": 35, "blackjack_payout_pct": 35, "desc": "+35% roulette and blackjack payouts."},
        "Shadow Ascension": {"robbery_protection_pct": 40, "work_loot_chance_pct": 30, "desc": "+40% theft protection, +30% work loot chance."},
        "Cosmic Ascension": {"gambling_loss_avoid_chance_pct": 35, "gambling_payout_pct": 40, "desc": "+35% gambling loss avoidance, +40% gambling payouts."},
        "Eternal Fortune": {"all_gains_pct": 30, "double_win_chance_pct": 25, "desc": "+30% all gains, +25% double win chance."},
        "Divine Mandate": {"all_gains_pct": 35, "daily_loss_refund_pct": 100, "desc": "+35% all gains, 100% gambling loss refund once per day."},
    },
    "divine": {
        "Splitting Heavens": {
            "all_gains_pct": 30,
            "double_win_chance_pct": 30,
            "cultivate_reward_pct": 30,
            "work_income_pct": 30,
            "sell_price_bonus_pct": 30,
            "gambling_payout_pct": 30,
            "work_cooldown_reduction_pct": 30,
            "gambling_crit_win_chance_pct": 30,
            "global_gold_gain_pct": 30,
            "buy_price_discount_pct": 30,
            "roulette_payout_pct": 30,
            "blackjack_payout_pct": 30,
            "robbery_protection_pct": 30,
            "work_loot_chance_pct": 30,
            "gambling_loss_avoid_chance_pct": 30,
            "desc": "Divine art that grants +30% to ALL effects. The ultimate power beyond mortal comprehension."
        },
    },
}

# Rarity weights for first assignment
IMMORTAL_RARITY_WEIGHTS = [
    ("common", 70),
    ("uncommon", 20),
    ("rare", 8),
    ("epic", 3),
    ("legendary", 1.5),
    ("mythic", 0.01),    # SUPER RARE - almost impossible
    ("divine", 0.001),   # ALMOST IMPOSSIBLE
]

def _choose_weighted(options):
    total = sum(w for _, w in options)
    r = random.uniform(0, total)
    upto = 0
    for value, weight in options:
        if upto + weight >= r:
            return value
        upto += weight
    return options[0][0]


def get_quality_variation(base_rarity: str) -> Tuple[str, bool]:
    """Get a quality variation for store items based on rarity"""
    if base_rarity not in QUALITY_VARIATION_CHANCES:
        return base_rarity, False
    
    upgrade_chance = QUALITY_VARIATION_CHANCES[base_rarity]
    if random.random() < upgrade_chance:
        # Upgrade to next rarity
        rarity_order = ["common", "uncommon", "rare", "legendary", "mythic", "divine"]
        try:
            current_index = rarity_order.index(base_rarity)
            if current_index < len(rarity_order) - 1:
                return rarity_order[current_index + 1], True
        except ValueError:
            pass
    
    return base_rarity, False


def generate_cultivation_loot(user_id: int = None, guild = None) -> Optional[Tuple[str, str, int]]:
    """Generate random cultivation loot with base 25% chance, modified by role bonuses and rarity settings"""
    base_chance = 0.25  # 25% base chance
    forced_rarity = None
    rarity_chance = None
    rarity = None  # Initialize rarity variable
    
    # Apply role-specific bonuses and rarity settings if user_id and guild provided
    if user_id and guild:
        loot_roles = load_json(LOOT_ROLES_FILE)
        member = guild.get_member(user_id)
        
        if member:
            for role in member.roles:
                role_id_str = str(role.id)
                if role_id_str in loot_roles:
                    role_data = loot_roles[role_id_str]
                    
                    # Handle legacy format (just a number)
                    if isinstance(role_data, (int, float)):
                        base_chance += role_data / 100.0
                    else:
                        # New format with dictionary
                        if "chance_bonus" in role_data:
                            base_chance += role_data["chance_bonus"] / 100.0
                        
                        # Check for forced rarity
                        if "forced_rarity" in role_data and forced_rarity is None:
                            forced_rarity = role_data["forced_rarity"]
                        
                        # Check for rarity chance
                        if "rarity_chance" in role_data and rarity_chance is None:
                            rarity_chance = role_data["rarity_chance"]
                    
                    # Cap chance at 100%
                    final_chance = min(1.0, max(0.0, base_chance))
                    
                    if random.random() > final_chance:
                        return None
                    
                    # Determine rarity based on role settings
                    if forced_rarity:
                        # Use forced rarity if specified
                        rarity = forced_rarity
                    elif rarity_chance is not None:
                        # Use rarity chance if specified
                        if random.random() * 100 < rarity_chance:
                            # Get the highest rarity available (but make mythic+ extremely rare)
                            if random.random() < 0.001:  # 0.1% chance for mythic+
                                rarity = "mythic" if random.random() < 0.1 else "divine"
                            else:
                                rarity = "legendary"  # Default to legendary instead of mythic
                        else:
                            # Use normal rarity weights
                            rarity = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
                    else:
                        # Use same rarity weights as Immortal Arts
                        rarity = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
    
    # If rarity is still None (no role bonuses applied), use default rarity selection
    if rarity is None:
        rarity = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
    
    if rarity not in CULTIVATION_LOOT_ITEMS:
        return None
    
    # Choose random item from that rarity
    item_name = random.choice(list(CULTIVATION_LOOT_ITEMS[rarity].keys()))
    item_data = CULTIVATION_LOOT_ITEMS[rarity][item_name]
    
    # Use new direct pricing system instead of base_price
    if item_name in ["Spirit Stone", "Martial Scroll"]:
        # Common items
        sell_price = 300
    elif item_name in ["Cultivators Storage Ring", "Flying Sword"]:
        # Uncommon items
        sell_price = 1000
    elif item_name in ["Monster Blood", "Heart Path Pills"]:
        # Rare items
        sell_price = 20000
    elif item_name in ["Liberation Pills", "Jade"]:
        # Legendary items
        sell_price = 400000
    elif item_name in ["Daoist Pill"]:
        # Mythic items
        sell_price = 4000000
    else:
        # Divine items
        sell_price = 70000000
    
    # Apply randomization based on rarity
    if rarity in ["legendary", "mythic", "divine", "primordial"]:
        random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
        sell_price = int(sell_price * random_factor)
    else:
        random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
        sell_price = int(sell_price * random_factor)
    
    return item_name, rarity, sell_price

def ensure_immortal_art_assigned(user_id: int, guild = None):
    """Ensure the user has an immortal art. Returns (art_dict, is_new)."""
    try:
        meta = get_user_meta(user_id)
        if not meta or not isinstance(meta, dict):
            print(f"DEBUG: Invalid meta for user {user_id} in ensure_immortal_art_assigned: {meta}")
            return {"name": "Basic Spirit", "rarity": "common"}, True
    
        # Initialize immortal arts slots if not exists
        if "immortal_arts" not in meta:
            meta["immortal_arts"] = {
                "slots": [None, None, None],  # 3 slots, first is free
                "rerolls": 3,  # Start with 3 rerolls
                "unlocked_slots": 1  # First slot is unlocked by default
            }
    
        # If no art in first slot, assign one
        if not meta["immortal_arts"]["slots"][0]:
            # Check for role-based Immortal Art rigging
            forced_rarity = None
            if guild:
                member = guild.get_member(user_id)
                if member:
                    try:
                        loot_roles = load_json(LOOT_ROLES_FILE)
                        if isinstance(loot_roles, dict):
                            for role in member.roles:
                                role_id_str = str(role.id)
                                if role_id_str in loot_roles:
                                    role_data = loot_roles[role_id_str]
                                    if isinstance(role_data, dict) and "immortal_art_rig" in role_data:
                                        rig_data = role_data["immortal_art_rig"]
                                        # Check if rig is still active
                                        if "expires" in rig_data:
                                            try:
                                                expires_time = datetime.fromisoformat(rig_data["expires"])
                                                if datetime.now(timezone.utc) < expires_time:
                                                    # Check if we should apply the rigged rarity
                                                    if random.randint(1, 100) <= rig_data.get("chance_percent", 100):
                                                        forced_rarity = rig_data["rarity"]
                                                        break
                                            except (ValueError, TypeError):
                                                # Invalid date format, skip this rig
                                                continue
                    except Exception as e:
                        print(f"DEBUG: Error loading loot roles for user {user_id}: {e}")
        
            if forced_rarity and forced_rarity in IMMORTAL_ARTS:
                rarity = forced_rarity
            else:
                rarity = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
            
            if rarity in IMMORTAL_ARTS and IMMORTAL_ARTS[rarity]:
                name = random.choice(list(IMMORTAL_ARTS[rarity].keys()))
                meta["immortal_arts"]["slots"][0] = {"name": name, "rarity": rarity}
                set_user_meta(user_id, meta)
                return meta["immortal_arts"]["slots"][0], True
            else:
                print(f"DEBUG: Invalid rarity {rarity} or empty IMMORTAL_ARTS[{rarity}] for user {user_id}")
                # Fallback to common
                rarity = "common"
                name = "Basic Spirit"
                meta["immortal_arts"]["slots"][0] = {"name": name, "rarity": rarity}
                set_user_meta(user_id, meta)
                return meta["immortal_arts"]["slots"][0], True
    
        return meta["immortal_arts"]["slots"][0], False
    except Exception as e:
        print(f"ERROR in ensure_immortal_art_assigned for user {user_id}: {e}")
        return {"name": "Basic Spirit", "rarity": "common"}, True

def get_user_immortal_art(user_id: int, guild = None):
    try:
        meta = get_user_meta(user_id)
        if not meta or not isinstance(meta, dict):
            print(f"DEBUG: Invalid meta for user {user_id}: {meta}")
            return {"slots": [None, None, None], "rerolls": 3, "unlocked_slots": 1}
    
        # Handle legacy format (single immortal_art)
        if "immortal_art" in meta and "immortal_arts" not in meta:
            # Migrate to new format
            old_art = meta["immortal_art"]
            meta["immortal_arts"] = {
                "slots": [old_art, None, None],
                "rerolls": 3,
                "unlocked_slots": 1
            }
            del meta["immortal_art"]
            set_user_meta(user_id, meta)
    
        # Ensure immortal arts system is initialized
        if "immortal_arts" not in meta:
            ensure_immortal_art_assigned(user_id, guild)
            meta = get_user_meta(user_id)
    
        immortal_arts = meta.get("immortal_arts")
        if not immortal_arts or not isinstance(immortal_arts, dict):
            print(f"DEBUG: Invalid immortal_arts for user {user_id}: {immortal_arts}")
            return {"slots": [None, None, None], "rerolls": 3, "unlocked_slots": 1}
        
        return immortal_arts
    except Exception as e:
        print(f"ERROR in get_user_immortal_art for user {user_id}: {e}")
        return {"slots": [None, None, None], "rerolls": 3, "unlocked_slots": 1}

def get_art_effects(user_id: int) -> Dict[str, float]:
    """Get combined effects from all active Immortal Art slots."""
    try:
        arts_data = get_user_immortal_art(user_id, None)
        if not arts_data or not isinstance(arts_data, dict):
            print(f"DEBUG: Invalid arts_data for user {user_id}: {arts_data}")
            return {}
        
        slots = arts_data.get("slots", [])
        unlocked_slots = arts_data.get("unlocked_slots", 1)
    
        if not isinstance(slots, list):
            print(f"DEBUG: Invalid slots for user {user_id}: {slots}")
            return {}
        
        combined_effects = {}
    
        # Combine effects from all unlocked slots
        for i in range(min(unlocked_slots, len(slots))):
            if i < len(slots) and slots[i] and isinstance(slots[i], dict):
                art = slots[i]
                name = art.get("name")
                rarity = art.get("rarity")
                if name and rarity and name in IMMORTAL_ARTS.get(rarity, {}):
                    effects = IMMORTAL_ARTS[rarity][name]
                    if isinstance(effects, dict):
                        # Combine effects (add percentages)
                        for effect_key, effect_value in effects.items():
                            if effect_key != "desc" and isinstance(effect_value, (int, float)):  # Skip description and ensure numeric
                                if effect_key in combined_effects:
                                    combined_effects[effect_key] += float(effect_value)
                                else:
                                    combined_effects[effect_key] = float(effect_value)
                    else:
                        print(f"DEBUG: Invalid effects for art {name} (rarity {rarity}): {effects}")
                else:
                    print(f"DEBUG: Invalid art data or missing from IMMORTAL_ARTS: name={name}, rarity={rarity}")
    
        return combined_effects
    except Exception as e:
        print(f"ERROR in get_art_effects for user {user_id}: {e}")
        return {}

def apply_money_bonus_for_keys(user_id: int, base_amount: int, keys: list) -> Tuple[int, int, float]:
    try:
        effects = get_art_effects(user_id)
        if not isinstance(effects, dict):
            print(f"DEBUG: Invalid effects for user {user_id}: {effects}")
            effects = {}
        
        pct = 0.0
        # global boosters
        pct += float(effects.get("all_gains_pct", 0))
        pct += float(effects.get("global_gold_gain_pct", 0))
        for k in keys:
            if isinstance(k, str):
                pct += float(effects.get(k, 0))
    
        # Add temporary boosts from items
        user_meta = get_user_meta(user_id)
        if not user_meta or not isinstance(user_meta, dict):
            print(f"DEBUG: Invalid user_meta for user {user_id}: {user_meta}")
            user_meta = {}
        
        temp_boosts = user_meta.get("temp_boosts", {})
        if not isinstance(temp_boosts, dict):
            print(f"DEBUG: Invalid temp_boosts for user {user_id}: {temp_boosts}")
            temp_boosts = {}
        
        current_time = int(time.time())
    
        # Clean expired boosts and apply active ones
        active_boosts = {}
        for boost_type, boost_data in temp_boosts.items():
            if isinstance(boost_data, dict) and isinstance(boost_data.get("expires", 0), (int, float)):
                if boost_data.get("expires", 0) > current_time:
                    active_boosts[boost_type] = boost_data.get("value", 0)
                    # Check if this boost type matches any of our keys
                    if boost_type in keys or boost_type == "all_gains":
                        pct += float(boost_data.get("value", 0))
    
        # Update temp_boosts with only active ones
        if len(active_boosts) != len(temp_boosts):
            user_meta["temp_boosts"] = active_boosts
            set_user_meta(user_id, user_meta)
    
        bonus = int(round(base_amount * pct / 100.0))
        return base_amount + bonus, bonus, pct
    except Exception as e:
        print(f"ERROR in apply_money_bonus_for_keys for user {user_id}: {e}")
        return base_amount, 0, 0.0

def get_art_effect_value(user_id: int, effect_key: str) -> float:
    """Get a specific effect value from user's Immortal Art."""
    try:
        effects = get_art_effects(user_id)
        if not isinstance(effects, dict):
            print(f"DEBUG: Invalid effects for user {user_id} in get_art_effect_value: {effects}")
            return 0.0
        return float(effects.get(effect_key, 0))
    except Exception as e:
        print(f"ERROR in get_art_effect_value for user {user_id}: {e}")
        return 0.0

def apply_work_cooldown_reduction(user_id: int, base_cooldown_hours: float) -> float:
    """Apply work cooldown reduction from Immortal Arts and equipment."""
    try:
        # Get Immortal Art reduction
        reduction_pct = get_art_effect_value(user_id, "work_cooldown_reduction_pct")
    
        # Get equipment reduction
        passive_effects = calculate_passive_effects(user_id)
        if not isinstance(passive_effects, dict):
            print(f"DEBUG: Invalid passive_effects for user {user_id}: {passive_effects}")
            passive_effects = {}
        
        equipment_reduction_pct = passive_effects.get("work_cooldown_reduction", 0)
    
        # Combine both reductions
        total_reduction_pct = reduction_pct + equipment_reduction_pct
    
        if total_reduction_pct > 0:
            reduction = base_cooldown_hours * (total_reduction_pct / 100.0)
            return max(0.1, base_cooldown_hours - reduction)  # Minimum 6 minutes
        return base_cooldown_hours
    except Exception as e:
        print(f"ERROR in apply_work_cooldown_reduction for user {user_id}: {e}")
        return base_cooldown_hours

def apply_buy_price_discount(user_id: int, base_price: int) -> Tuple[int, int]:
    """Apply buy price discount from Immortal Arts and equipment. Returns (final_price, discount_amount)."""
    try:
        # Get Immortal Art discount
        discount_pct = get_art_effect_value(user_id, "buy_price_discount_pct")
    
        # Get equipment discount
        passive_effects = calculate_passive_effects(user_id)
        if not isinstance(passive_effects, dict):
            print(f"DEBUG: Invalid passive_effects for user {user_id} in apply_buy_price_discount: {passive_effects}")
            passive_effects = {}
        
        equipment_discount_pct = passive_effects.get("shop_discount", 0)
    
        # Combine both discounts
        total_discount_pct = discount_pct + equipment_discount_pct
    
        if total_discount_pct > 0:
            discount = int(round(base_price * (total_discount_pct / 100.0)))
            final_price = max(1, base_price - discount)
            return final_price, discount
        return base_price, 0
    except Exception as e:
        print(f"ERROR in apply_buy_price_discount for user {user_id}: {e}")
        return base_price, 0

def apply_sell_price_bonus(user_id: int, base_price: int) -> Tuple[int, int]:
    """Apply sell price bonus from Immortal Arts and equipment. Returns (final_price, bonus_amount)."""
    try:
        # Get Immortal Art bonus
        bonus_pct = get_art_effect_value(user_id, "sell_price_bonus_pct")
    
        # Get equipment bonus
        passive_effects = calculate_passive_effects(user_id)
        if not isinstance(passive_effects, dict):
            print(f"DEBUG: Invalid passive_effects for user {user_id} in apply_sell_price_bonus: {passive_effects}")
            passive_effects = {}
        
        equipment_bonus_pct = passive_effects.get("sell_bonus", 0)
    
        # Combine both bonuses
        total_bonus_pct = bonus_pct + equipment_bonus_pct
    
        if total_bonus_pct > 0:
            bonus = int(round(base_price * (total_bonus_pct / 100.0)))
            final_price = base_price + bonus
            return final_price, bonus
        return base_price, 0
    except Exception as e:
        print(f"ERROR in apply_sell_price_bonus for user {user_id}: {e}")
        return base_price, 0

def apply_gambling_payout_bonus(user_id: int, base_payout: int, game_type: str = "general") -> Tuple[int, int]:
    """Apply gambling payout bonus from Immortal Arts and equipment. Returns (final_payout, bonus_amount)."""
    try:
        effects = get_art_effects(user_id)
        if not isinstance(effects, dict):
            print(f"DEBUG: Invalid effects for user {user_id} in apply_gambling_payout_bonus: {effects}")
            effects = {}
        
        bonus_pct = 0.0
        
        # General gambling bonus
        bonus_pct += float(effects.get("gambling_payout_pct", 0))
        
        # Game-specific bonuses
        if game_type == "roulette":
            bonus_pct += float(effects.get("roulette_payout_pct", 0))
        elif game_type == "blackjack":
            bonus_pct += float(effects.get("blackjack_payout_pct", 0))
        
        # Apply luck attribute bonus (0.5% per luck point)
        try:
            attributes, _ = get_user_attributes(user_id)
            if isinstance(attributes, dict):
                luck_bonus = attributes.get("luck", 0) * 0.5  # +0.5% per luck point for Immortal Arts
                bonus_pct += luck_bonus
        except Exception as e:
            print(f"ERROR getting user attributes for {user_id}: {e}")
        
        # Apply equipment bonuses
        try:
            passive_effects = calculate_passive_effects(user_id)
            if isinstance(passive_effects, dict):
                if game_type == "roulette" and passive_effects.get("roulette_boost", 0) > 0:
                    bonus_pct += passive_effects["roulette_boost"]
                elif game_type == "blackjack" and passive_effects.get("blackjack_boost", 0) > 0:
                    bonus_pct += passive_effects["blackjack_boost"]
        except Exception as e:
            print(f"ERROR calculating passive effects for {user_id}: {e}")
        
        # NERF: Halve all blackjack bonuses to reduce OP payouts
        if game_type == "blackjack" and bonus_pct > 0:
            bonus_pct = bonus_pct * 0.5
        
        if bonus_pct > 0:
            bonus = int(round(base_payout * (bonus_pct / 100.0)))
            final_payout = base_payout + bonus
            return final_payout, bonus
        return base_payout, 0
    except Exception as e:
        print(f"ERROR in apply_gambling_payout_bonus for user {user_id}: {e}")
        return base_payout, 0

def check_gambling_loss_avoidance(user_id: int) -> bool:
    """Check if user avoids gambling loss due to Immortal Art."""
    avoid_chance = get_art_effect_value(user_id, "gambling_loss_avoid_chance_pct")
    if avoid_chance > 0:
        return random.random() * 100 < avoid_chance
    return False

def check_gambling_crit_win(user_id: int) -> bool:
    """Check if user gets critical win in gambling due to Immortal Art."""
    crit_chance = get_art_effect_value(user_id, "gambling_crit_win_chance_pct")
    if crit_chance > 0:
        return random.random() * 100 < crit_chance
    return False

def check_double_win_chance(user_id: int) -> bool:
    """Check if user doubles gambling winnings due to Immortal Art."""
    double_chance = get_art_effect_value(user_id, "double_win_chance_pct")
    if double_chance > 0:
        return random.random() * 100 < double_chance
    return False

def check_robbery_protection(user_id: int) -> bool:
    """Check if user avoids robbery due to Immortal Art."""
    protection_chance = get_art_effect_value(user_id, "robbery_protection_pct")
    if protection_chance > 0:
        return random.random() * 100 < protection_chance
    return False

def check_work_loot_chance(user_id: int) -> bool:
    """Check if user gets extra loot from work due to Immortal Art."""
    loot_chance = get_art_effect_value(user_id, "work_loot_chance_pct")
    if loot_chance > 0:
        return random.random() * 100 < loot_chance
    return False

def validate_sect_membership(user_id: int, sect_name: str) -> bool:
    """Validate if a user is actually a member or leader of a sect"""
    if not sect_name:
        return False
    
    sects = load_json(SECTS_FILE)
    if sect_name not in sects:
        return False
    
    sect_data = sects[sect_name]
    
    # Convert user_id to int to ensure proper comparison
    user_id = int(user_id)
    
    # Check if user is leader
    leader_id = sect_data.get("leader")
    if leader_id is not None:
        leader_id = int(leader_id)
        if leader_id == user_id:
            return True
    
    # Check if user is member
    members = sect_data.get("members", [])
    if members:
        # Convert all member IDs to int for comparison
        member_ids = [int(mid) if isinstance(mid, str) else mid for mid in members]
        if user_id in member_ids:
            return True
    
    return False


def get_user_sect_and_boost(user_id):
    """Return (sect_name, personal_boost_percent) according to new share rules.

    Rules:
    - Each sect has a base boost percent B stored in sects.json under `boost_percent`.
    - Members receive a fraction of B based on their `sect_rank`:
      - Base share is 1/10 of B for rank index 0 (outer disciple).
      - Each promotion adds another 1/8 of B.
      - The last two ranks (`sect leader`, `ancestor`) receive the full B (100%).
    """
    sects = load_json(SECTS_FILE)
    if not isinstance(sects, dict):
        return None, 0
    meta = get_user_meta(user_id)
    sect_name = meta.get("sect")
    if not sect_name or sect_name not in sects:
        return None, 0
    
    # Validate that user is actually a member or leader of the sect
    if not validate_sect_membership(user_id, sect_name):
        return None, 0
    
    base_boost = int(sects[sect_name].get("boost_percent", 0))

    rank = (meta.get("sect_rank") or SECT_RANKS[0]).lower()
    try:
        idx = SECT_RANKS.index(rank)
    except ValueError:
        idx = 0

    if idx >= len(SECT_RANKS) - 2:
        share = 1.0
    else:
        share = min(1.0, 0.1 + idx * 0.125)

    personal_boost = int(round(base_boost * share))
    return sect_name, max(0, personal_boost)


def calc_with_bonus(base_amount: int, boost_pct: int):
    if boost_pct <= 0:
        return base_amount, 0
    bonus = int(base_amount * boost_pct / 100)
    return base_amount + bonus, bonus


# -----------------------
# Sect XP and Promotion Helpers
# -----------------------
def get_rank_index(rank: str) -> int:
    try:
        return SECT_RANKS.index(rank)
    except ValueError:
        return 0


def get_required_xp_for_rank_index(rank_index: int) -> int:
    """Cumulative XP to reach a given sect position index using the new rule:
    every 5 levels promotes by one position. Uses progressive XP system.
    Rank 0 requires 0; index N requires N*5 levels worth of XP.
    """
    if rank_index <= 0:
        return 0
    target_level = rank_index * 5
    return get_xp_for_level(target_level)


def add_sect_xp(user_id: int, xp: int) -> int:
    meta = get_user_meta(user_id)
    current_xp = int(meta.get("sect_xp", 0))
    current_xp += int(xp)
    meta["sect_xp"] = current_xp
    
    # Check if user leveled up and give attribute points
    old_level, _, _, _ = get_member_level_and_progress(current_xp - xp)
    new_level, _, _, _ = get_member_level_and_progress(current_xp)
    
    if new_level > old_level:
        # Give 1 attribute point per level gained
        levels_gained = new_level - old_level
        attribute_points_gained = levels_gained * 1
        
        current_available = meta.get("available_attribute_points", 0)
        meta["available_attribute_points"] = current_available + attribute_points_gained
    
    set_user_meta(user_id, meta)
    return current_xp


def maybe_promote_member(user_id: int) -> Optional[str]:
    meta = get_user_meta(user_id)
    sect_name = meta.get("sect")
    if not sect_name:
        return None
    
    # Load sect data to check current rank counts
    sects = load_json(SECTS_FILE)
    if sect_name not in sects:
        return None
    
    current_rank = (meta.get("sect_rank") or SECT_RANKS[0]).lower()
    try:
        idx = SECT_RANKS.index(current_rank)
    except ValueError:
        idx = 0
    
    # Last two ranks (sect leader/ancestor) are admin-assignable only
    if idx >= len(SECT_RANKS) - 2:
        return None
    
    xp = int(meta.get("sect_xp", 0))
    # Each rank requires 5 levels → calculate total XP needed
    next_idx = idx + 1
    next_rank = SECT_RANKS[next_idx]
    required = get_required_xp_for_rank_index(next_idx)
    
    if xp >= required:
        # Respect rank limits
        limit = RANK_LIMITS.get(next_rank, float('inf'))
        count = 0
        for member_id in sects[sect_name].get("members", []):
            member_meta = get_user_meta(member_id)
            if (member_meta.get("sect_rank") or SECT_RANKS[0]).lower() == next_rank:
                count += 1
        if count >= limit:
            return None
        meta["sect_rank"] = next_rank
        set_user_meta(user_id, meta)
        return next_rank
    return None


# Bot setup
intents = discord.Intents.default()
intents.message_content = True
intents.members = True

# Create bot with connection resilience
bot = commands.Bot(
    command_prefix="?", 
    intents=intents,
    # Add connection resilience settings
    max_messages=10000,  # Limit message cache to prevent memory issues
    heartbeat_timeout=60.0,  # Increase heartbeat timeout for stability
    guild_ready_timeout=20.0,  # Increase guild ready timeout
    # Enable automatic reconnection
    reconnect=True
)

# If a second token exists, create a lightweight paired bot instance
paired_bot: Optional[commands.Bot] = None
if SECONDARY_BOT_ENABLED:
    paired_bot = commands.Bot(
        command_prefix="?",
        intents=intents,
        max_messages=2000,
        heartbeat_timeout=60.0,
        guild_ready_timeout=20.0,
        reconnect=True
    )

# Alias for clarity when routing actions
PRIMARY_BOT: commands.Bot = bot

# Utility: route admin prefix commands to secondary only, but execute effects on primary
def _is_admin_permission_check(check_callable: Any) -> bool:
    """Best-effort detection for commands.has_permissions(admin=True) predicates."""
    qualname = getattr(check_callable, "__qualname__", "") or ""
    name = getattr(check_callable, "__name__", "") or ""
    text = f"{qualname}.{name}"
    return "has_permissions" in text or "predicate" == name

async def _deny_on_primary_and_hint_secondary(ctx: commands.Context) -> bool:
    if ctx.bot is PRIMARY_BOT and paired_bot is not None:
        try:
            await ctx.send("This admin prefix command is only available on the secondary bot. Use the secondary bot to run it.")
        except Exception:
            pass
        return False
    return True

def prepare_secondary_admin_prefix_commands():
    """Clone admin-only prefix commands to the secondary bot and block them on primary."""
    if paired_bot is None:
        return
    for command in list(PRIMARY_BOT.commands):
        # Skip slash/hybrid commands; only pure prefix commands
        if isinstance(command, commands.HybridCommand):
            continue
        if not isinstance(command, commands.Command):
            continue
        # Heuristic: require an admin permission check among the command's checks
        has_admin_check = any(_is_admin_permission_check(chk) for chk in getattr(command, "checks", []))
        if not has_admin_check:
            continue
        # Add a guard on primary so it cannot run here
        try:
            command.add_check(_deny_on_primary_and_hint_secondary)
        except Exception:
            pass
        # Copy to secondary if not already present
        try:
            exists = paired_bot.get_command(command.qualified_name) is not None
            if not exists:
                paired_bot.add_command(command.copy())
        except Exception:
            # Some commands may not be copyable; skip gracefully
            continue

def get_admin_prefix_command_names() -> List[str]:
    names: List[str] = []
    for command in list(PRIMARY_BOT.commands if paired_bot is None else paired_bot.commands):
        if isinstance(command, commands.HybridCommand):
            continue
        if not isinstance(command, commands.Command):
            continue
        has_admin_check = any(_is_admin_permission_check(chk) for chk in getattr(command, "checks", []))
        if has_admin_check:
            names.append(command.qualified_name)
    return sorted(set(names))[:25]

async def admin_cmd_autocomplete(interaction: discord.Interaction, current: str):
    from discord.app_commands import Choice
    candidates = get_admin_prefix_command_names()
    filtered = [n for n in candidates if current.lower() in n.lower()] if current else candidates
    return [Choice(name=n, value=n) for n in filtered[:25]]

# Add command timeout protection for primary
@bot.before_invoke
async def before_invoke(ctx):
    """Set a timeout for command execution"""
    ctx._command_start_time = time.time()
    ctx._command_timeout = 30  # 30 second timeout for commands

@bot.after_invoke
async def after_invoke(ctx):
    """Log command execution time"""
    if hasattr(ctx, '_command_start_time'):
        execution_time = time.time() - ctx._command_start_time
        if execution_time > 5:  # Log slow commands
            print(f"Slow command {ctx.command.name} took {execution_time:.2f}s")

# Add error handler for application commands
@bot.tree.error
async def on_app_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    """Handle errors in application commands"""
    try:
        if isinstance(error, app_commands.CommandOnCooldown):
            await interaction.response.send_message(
                f"⏰ This command is on cooldown. Try again in {error.retry_after:.1f} seconds.",
                ephemeral=True
            )
        elif isinstance(error, app_commands.MissingPermissions):
            await interaction.response.send_message(
                "❌ You don't have permission to use this command.",
                ephemeral=True
            )
        elif isinstance(error, app_commands.CommandInvokeError):
            # Log the actual error
            print(f"Command error in {interaction.command.name}: {error.original}")
            logging.error(f"Command error in {interaction.command.name}: {error.original}", exc_info=True)
            
            # Send user-friendly error message
            await interaction.response.send_message(
                "❌ An error occurred while executing this command. Please try again later.",
                ephemeral=True
            )
        else:
            # Log unknown errors
            print(f"Unknown app command error: {error}")
            logging.error(f"Unknown app command error: {error}", exc_info=True)
            
            await interaction.response.send_message(
                "❌ An unexpected error occurred. Please try again later.",
                ephemeral=True
            )
    except Exception as e:
        print(f"Error in error handler: {e}")
        try:
            await interaction.response.send_message(
                "❌ An error occurred while handling the command error.",
                ephemeral=True
            )
        except:
            pass

# Add timeout protection for commands
async def with_timeout(coro, timeout_seconds=10):
    """Execute a coroutine with a timeout"""
    try:
        return await asyncio.wait_for(coro, timeout=timeout_seconds)
    except asyncio.TimeoutError:
        print(f"Command timed out after {timeout_seconds} seconds")
        raise TimeoutError(f"Command execution timed out after {timeout_seconds} seconds")
    except Exception as e:
        print(f"Command error: {e}")
        raise


# Command hiding for admin commands
@bot.tree.command(name="admin_commands", description="Show available admin commands")
@app_commands.checks.has_permissions(administrator=True)
async def admin_commands(interaction: discord.Interaction):
    """Show all available admin commands with organized categories"""
    
    # Organized by category for better readability
    categories = {
        "🛡️ **User Management**": [
            "clear_inventory [user] - Clear user inventory",
            "remove_inventory <user> <item> - Remove items from user",
            "remove_from_inventory <user> <item> - Remove specific items from user",
            "equipment_reset <user> - Reset user's equipped items",
            "clear_equipment <user> - Clear user's equipped items (permanently remove)",
            "set_attributes <user> <str> <def> <long> <luck> - Set user attributes",
            "set_rerolls <user> <amount> - Set immortal art rerolls",
            "collect_role <role> <amount> <cooldown_hours> - Set role income and cooldown",
            "inv_add <user> <item> <type> <rarity> - Add items to user",
            "add_to_inventory <user> <item_name> - Add specific item to user",
            "stat_reset <user> - Reset all stat points and give correct amount for level",
            "quest_clear <user> - Clear all quests for a user (fixes corrupted data)",
            "clear_rig <user> - Clear user's rig (equipment setup)"
        ],
        "💰 **Money Management**": [
            "money_set <user> <amount> <wallet/bank> - Set user's money (can be negative)",
            "money_give <user> <amount> <wallet/bank> - Give money to user",
            "money_remove <user> <amount> <wallet/bank> - Remove money from user (can create debt)",
            "set_debt <user> <amount> <wallet/bank> - Put user into debt",
            "debt_status <user> - Check user's debt status",
            "collect_debt - Manually trigger debt collection (Admin only)",
            "reset_economy - Reset ALL users' money to 0 (⚠️ DESTRUCTIVE)"
        ],
        "🎭 **Role Management**": [
            "set_income_role <role> [cooldown] - Set role income collection cooldown",
            "remove_income_role <role> - Remove role from income system",
            "list_income_roles - List all configured income roles"
        ],
        "🏪 **Store & Items**": [
            "store_effects <item> <effect> <value> [duration] - Add effects to items",
            "add_store_item <key> <price> [desc] [rarity] - Add new store item",
            "delete_store_item <name> - Delete store items",
            "set_store_stock <item> <stock> - Set item stock",
            "set_item_usable <item> <true|false> - Toggle item usability",
            "generate_equipment <user> <type> <rarity> - Generate random equipment",
            "restock_store - Restock all store items to maximum stock",
            "restock_status - Check store restock status and schedule",
            "fix_inventory_values - Fix corrupted inventory values"
        ],
        "⚔️ **Sect Management**": [
            "set_sect_position <user> <position> - Set user sect position",
            "kick_sect_member <user> - Kick member from sect",
            "delete_sect - Delete your sect",
            "admin_sect_delete <sect> - Delete ANY sect",
            "admin_sect_kick <user> - Kick user from ANY sect",
            "admin_sect_info <sect> - View detailed info of ANY sect",
            "sect_set_boost <percent> - Set sect money boost",
            "sect_set_level <sect> <level> - Set sect level directly",
            "sect_info <sect> - View detailed sect information",
            "sect_members <sect> - List all sect members",
            "fix_my_sect - Fix your sect's data",
            "fix_sect_job_data - Fix sect job data for all users",
            "reset_sect <sect_name> - Reset sect to level 1 and increase prices 10x (⚠️ DESTRUCTIVE)"
        ],
        "🎲 **System & Debug**": [
            "bot_status <status> [activity] - Change bot status",
            "debug_market - Debug market system",

            "debug_loan - Debug loan system data",


            "set_encounter_chance <percent> - Set expedition encounters",
            "addjob <name> <min> <max> [req] [role] - Add/update job",
            "fix_market - Fix corrupted market items",
            "market_reroll - Manually reroll market items",
            "clean_inventory - Clean up old inventory items (Admin only)",
            "health_sync - Fix all users' HP calculation issues",
            "clean_quests - Clean corrupted quest data for all users",
            "sync - Force sync slash commands",
            "migrate_all_data - Migrate all data to new format",
            "fix_all_user_data - Fix corrupted user data for all users",
            "restore_user_data <user> - Restore user data from backup"
        ],
        "🔮 **Immortal Arts**": [
            "immortal_art_admin <user> <action> <slot> [name] [rarity] - Admin immortal arts system (Hybrid)"
        ],
        "💰 **Loan Management**": [
            "create_test_loan <borrower> [amount] [duration] [interest] - Create test loan for debugging"
        ]
    }
    
    embed = discord.Embed(title="🔧 Admin Commands", color=0x2ecc71)
    embed.description = "**Available Admin Commands** - Use `?command_name` to execute\n\n"
    
    for category, commands in categories.items():
        embed.add_field(
            name=category,
            value="\n".join([f"• `?{cmd.split(' - ')[0]}` - {cmd.split(' - ', 1)[1]}" for cmd in commands]),
        inline=False
    )
    
    # Quick examples
    embed.add_field(
        name="💡 **Quick Examples**",
        value="""• `?inv_add @user sword weapon rare` - Add rare sword
• `?store_effects item add_role 123456789` - Add role effect
• `?bot_status online "Playing Cultivation"` - Set status
• `?generate_equipment @user weapon legendary` - Generate weapon""",
        inline=False
    )
    
    embed.set_footer(text="All admin commands use ? prefix | Use /help for regular commands")
    
    await interaction.response.send_message(embed=embed, ephemeral=True)


# Override command visibility for admin commands
@bot.tree.command(name="help", description="Show available commands")
async def help_command(interaction: discord.Interaction):
    """Show available commands based on user permissions"""
    is_admin_user = await admin_command_check(interaction)
    
    # Basic commands everyone can see
    basic_commands = [
        "balance - Check your balance",
        "daily - Collect daily reward",
        "weekly - Collect weekly reward",
        "job_do - Work your job",
        "cultivate - Cultivate for XP and chance for money",
        "collect_income - Collect passive income",
        "storagering - View your inventory",
        "shop - View store items with pagination",
        "buy_item - Buy an item",
        "sell - Sell items",
        "use_item - Use an item",
        "give_item - Give an item to another user",
        "gifted_items - View items given to you by others",
        "blacksmith - Craft weapons, armor, and artifacts",
        "crafting_guide - View crafting information and recipes",
        "auction_list - List auction items",
        "auction_sell - Sell an auction item",
        "auction_buy - Buy an auction item",
        "auction_cancel - Cancel your auction listing",
        "rob - Attempt to rob another player",
        "deposit - Deposit money to bank",
        "withdraw - Withdraw money from bank",
        "leaderboard - Show leaderboards",
        "status_window - View your cultivation level and attributes",
        "sect_level - View sect progress",
        "sect_shop - View and purchase sect upgrades (Leader only)",
        "sect_boosts - View current sect boosts and bonuses",
        "sect_contribute - Contribute money to your sect",
        "sect_funds - View your sect's current funds",
        "sect_leaderboard - View sect rankings and top 3 bonuses",
        "expedition - Go on cultivator expedition (30min cooldown)",
        "xp_convert - Convert money to XP (1,000 stones = 1 XP, max 1,000 XP per conversion)",

        "sect_list - List public sects to join",
        "sect_join - Join a sect (public or with invite)",
        "position - View your or another member's sect position and boosters",
        "titles - View title progression system and requirements",
        "job_status - View job progress and ranks",
        "reroll - Reroll Immortal Arts",
        "roulette - Play roulette",
        "blackjack - Play blackjack",
        "tictactoe - Play tic-tac-toe",
        "equipment - View your equipped items and combat stats",
        "combat_stats - View detailed combat statistics",
        "equip - Equip an item from your inventory",
        "unequip - Unequip an item",
        "inventory - View your inventory or another user's inventory with equipment filtering",
        "clear_inventory - Clear your entire inventory (Admin only)",
        "add_inventory - Add items to user inventory with autocomplete and organized sections (Admin only)",
        "remove_inventory - Remove an item from a user's inventory (Admin only)",
        "mine - Mine for ores and materials",
        "ore_check - Check your ore inventory and status",
        "store_effects - Add effects to store items (Admin only)",
        "store_list - List all store items (Admin only)",
        "blacksmith - Visit the blacksmith to craft weapons, armor, and artifacts (use /blacksmith <type> <rarity> to craft)",
        "market - View the current market items and reroll options",
        "market_buy - Buy an item from the market",
        "debug_market - Debug market system (Admin only)",
        "test_inventory - Test inventory system with sample items (Admin only)",
        "sell - Sell any item to the merchant for a fair price",
        "tournament_create - Create a PvP tournament (Admin only)",
        "tournament_host - Create tournaments or take control of existing ones (Admin only)",
        "tournament_manage - Manage tournament settings and status (Admin only)",
        "tournament_status - Get detailed status of a specific tournament",
        "tournament_list - List all tournaments",
        "tournament_info - Get detailed info about a tournament",
        "loan_give - Give a loan to another user with customizable terms",
        "loan_pay - Make a payment on your loan",
        "loan_status - View your loan status and summary",
        "loan_details - View detailed information about a specific loan",
        "loan_list - List all your loans (borrowed and lent)",
        "battle - Fight random cultivator bots for rewards (5min cooldown)"
    ]
    
    embed = discord.Embed(title="🤖 Bot Commands", color=0x3498db)
    embed.description = "Available commands:\n\n" + "\n".join([f"• `/{cmd}`" for cmd in basic_commands])
    
    if is_admin_user:
        embed.add_field(
            name="🔧 Admin Commands", 
            value="Use `/admin_commands` to see all admin commands", 
            inline=False
        )
    
    embed.set_footer(text="Use /help for more information")
    
    await interaction.response.send_message(embed=embed, ephemeral=True)


# In-memory recent search cache for numeric selection
# Use plain dict typing to support older Python versions
RECENT_MEMBER_SEARCH = {}


# Message event for job progression (primary)
@bot.event
async def on_message(message):
    try:
        # Ignore bot messages
        if message.author.bot:
            return
        
        # Add message count for job progression
        add_message_count(message.author.id)
        
        # Process commands
        await bot.process_commands(message)
    except Exception as e:
        print(f"Error processing message: {e}")
        logging.error(f"Error processing message: {e}", exc_info=True)
        # Don't let message errors crash the bot

# on_ready
@bot.event
async def on_ready():
    try:
        # Force sync all commands
        synced = await bot.tree.sync()
        print(f"Synced {len(synced)} command(s)")
        logging.info(f"Synced app commands: {len(synced)}")
    except Exception as e:
        print(f"Failed to sync commands: {e}")
        logging.exception("Failed to sync app commands:")

    print(f"Logged in as {bot.user} (ID: {bot.user.id})")
    
    # Migrate money data from economy.json to user_money.json
    migrated_count = migrate_money_data()
    if migrated_count > 0:
        print(f"Migrated {migrated_count} users' money data on startup")
    
    # Initialize market system
    ensure_market_exists()
    print("Market system initialized")
    
    # Using old system - no need to initialize new JSON files
    print("Using legacy data system")
    
    # Set bot status to Do Not Disturb with custom status note above the name
    try:
        # Try to set a custom status that appears above the username
        await bot.change_presence(
            status=discord.Status.dnd,
            activity=discord.Activity(
                type=discord.ActivityType.custom,
                name="discord.gg/rtoc",
                state="discord.gg/rtoc"  # Try both name and state
            )
        )
        print("Bot status set to Do Not Disturb with custom status note 'discord.gg/rtoc' above the name")
    except Exception as e:
        print(f"Failed to set custom status: {e}")
        # Fallback: try without state parameter
        try:
            await bot.change_presence(
                status=discord.Status.dnd,
                activity=discord.Activity(
                    type=discord.ActivityType.custom,
                    name="discord.gg/rtoc"
                )
            )
            print("Bot status set to Do Not Disturb with custom status note 'discord.gg/rtoc' above the name (fallback)")
        except Exception as e2:
            print(f"Failed to set custom status (fallback): {e2}")
            # Final fallback: just set status
            try:
                await bot.change_presence(status=discord.Status.dnd)
                print("Bot status set to Do Not Disturb (final fallback)")
            except Exception as e3:
                print(f"Failed to set bot status (final fallback): {e3}")
    
    if STARTUP_CHANNEL_ID:
        try:
            ch = bot.get_channel(int(STARTUP_CHANNEL_ID))
            if ch:
                await safe_channel_send(ch, "Primary bot is online.")
        except Exception as e:
            print(f"Failed to send startup message: {e}")
            pass

    # Prepare secondary admin prefix commands after primary is ready
    try:
        prepare_secondary_admin_prefix_commands()
    except Exception as e:
        print(f"Failed to prepare secondary admin prefix commands: {e}")

    # Remove any old guild-scoped commands to prevent duplicates in the picker
    try:
        for guild in bot.guilds:
            bot.tree.clear_commands(guild=guild)
            await bot.tree.sync(guild=guild)
        print("Cleared any guild commands to prevent duplicates; using global commands only.")
    except Exception as e:
        print(f"Guild command clear failed: {e}")
    
    # Start background tasks
    bot.loop.create_task(cleanup_expired_temp_roles())
    print("Started background task: cleanup_expired_temp_roles")
    
    # Start debt collection task
    bot.loop.create_task(debt_collection_task())
    print("Started background task: debt_collection_task")
    
    # Start auto-restock task
    bot.loop.create_task(auto_restock_task())
    print("Started background task: auto_restock_task")

# Safe send utility function
async def safe_send(ctx, content=None, embed=None, view=None, ephemeral=False):
    """Safely send a message, handling permission errors gracefully"""
    try:
        if hasattr(ctx, 'interaction') and ctx.interaction:
            # For application commands: respond first if not done, else use followup
            if not ctx.interaction.response.is_done():
                await ctx.interaction.response.send_message(content=content, embed=embed, view=view, ephemeral=ephemeral)
            else:
                await ctx.interaction.followup.send(content=content, embed=embed, view=view, ephemeral=ephemeral)
        elif hasattr(ctx, 'send'):
            # For regular commands, use ctx.send
            await ctx.send(content=content, embed=embed, view=view)
        else:
            print(f"Could not send message: invalid context type {type(ctx)}")
            return False
        return True
    except discord.Forbidden:
        print(f"Missing permissions to send message in channel {getattr(ctx, 'channel', 'unknown')}")
        logging.warning(f"Missing permissions to send message in channel {getattr(ctx, 'channel', 'unknown')}")
        return False
    except discord.HTTPException as e:
        print(f"HTTP error sending message: {e}")
        logging.error(f"HTTP error sending message: {e}")
        return False
    except Exception as e:
        print(f"Error sending message: {e}")
        logging.error(f"Error sending message: {e}")
        return False

async def safe_channel_send(channel, content=None, embed=None, view=None):
    """Safely send a message to a specific channel, handling permission errors gracefully"""
    try:
        if channel and hasattr(channel, 'send'):
            await channel.send(content=content, embed=embed, view=view)
            return True
        else:
            print(f"Invalid channel for sending message: {channel}")
            return False
    except discord.Forbidden:
        print(f"Missing permissions to send message in channel {channel}")
        logging.warning(f"Missing permissions to send message in channel {channel}")
        return False
    except discord.HTTPException as e:
        print(f"HTTP error sending message to channel: {e}")
        logging.error(f"HTTP error sending message to channel: {e}")
        return False
    except Exception as e:
        print(f"Error sending message to channel: {e}")
        logging.error(f"Error sending message to channel: {e}")
        return False

# Monkey patch to automatically handle send errors
def patch_send_methods():
    """Patch all send methods to automatically handle permission errors"""
    import types
    
    # Store original send methods
    original_ctx_send = None
    original_channel_send = None
    original_member_send = None
    
    # Patch Context.send
    if hasattr(commands.Context, 'send'):
        original_ctx_send = commands.Context.send
        async def safe_ctx_send(self, content=None, **kwargs):
            try:
                return await original_ctx_send(self, content, **kwargs)
            except discord.Forbidden:
                print(f"Missing permissions to send message in channel {getattr(self, 'channel', 'unknown')}")
                logging.warning(f"Missing permissions to send message in channel {getattr(self, 'channel', 'unknown')}")
                return None
            except discord.HTTPException as e:
                print(f"HTTP error sending message: {e}")
                logging.error(f"HTTP error sending message: {e}")
                return None
            except Exception as e:
                print(f"Error sending message: {e}")
                logging.error(f"Error sending message: {e}")
                return None
        
        commands.Context.send = safe_ctx_send
    
    # Patch TextChannel.send
    if hasattr(discord.TextChannel, 'send'):
        original_channel_send = discord.TextChannel.send
        async def safe_channel_send_patch(self, content=None, **kwargs):
            try:
                return await original_channel_send(self, content, **kwargs)
            except discord.Forbidden:
                print(f"Missing permissions to send message in channel {self}")
                logging.warning(f"Missing permissions to send message in channel {self}")
                return None
            except discord.HTTPException as e:
                print(f"HTTP error sending message to channel: {e}")
                logging.error(f"HTTP error sending message to channel: {e}")
                return None
            except Exception as e:
                print(f"Error sending message to channel: {e}")
                logging.error(f"Error sending message to channel: {e}")
                return None
        
        discord.TextChannel.send = safe_channel_send_patch
    
    # Patch Member.send (DM)
    if hasattr(discord.Member, 'send'):
        original_member_send = discord.Member.send
        async def safe_member_send_patch(self, content=None, **kwargs):
            try:
                return await original_member_send(self, content, **kwargs)
            except discord.Forbidden:
                print(f"Missing permissions to DM user {self}")
                logging.warning(f"Missing permissions to DM user {self}")
                return None
            except discord.HTTPException as e:
                print(f"HTTP error sending DM: {e}")
                logging.error(f"HTTP error sending DM: {e}")
                return None
            except Exception as e:
                print(f"Error sending DM: {e}")
                logging.error(f"Error sending DM: {e}")
                return None
        
        discord.Member.send = safe_member_send_patch
    
    print("Send methods patched for automatic error handling")

# Apply the patches
patch_send_methods()

# Additional error handling for common permission issues
async def log_permission_issues():
    """Log information about bot permissions to help debug issues"""
    print("=== Bot Permission Check ===")
    try:
        for guild in bot.guilds:
            print(f"Guild: {guild.name} (ID: {guild.id})")
            bot_member = guild.get_member(bot.user.id)
            if bot_member:
                print(f"  Bot permissions: {bot_member.guild_permissions}")
                print(f"  Bot roles: {[role.name for role in bot_member.roles]}")
            else:
                print("  Bot member not found in guild")
            
            # Check channel permissions
            for channel in guild.text_channels:
                if channel.permissions_for(guild.me).send_messages:
                    print(f"  ✅ Can send in: #{channel.name}")
                else:
                    print(f"  ❌ Cannot send in: #{channel.name}")
            print()
    except Exception as e:
        print(f"Error checking permissions: {e}")
        logging.error(f"Error checking permissions: {e}")

# Schedule permission check after bot is ready
bot.add_listener(log_permission_issues, 'on_ready')

# Add error handlers to prevent crashes
@bot.event
async def on_error(event, *args, **kwargs):
    """Global error handler to prevent crashes"""
    print(f"Error in {event}: {args}")
    logging.error(f"Error in {event}: {args}", exc_info=True)
    
    # Handle specific WebSocket errors
    if "sequence" in str(args).lower() or "websocket" in str(args).lower():
        print("WebSocket error detected, attempting to reconnect...")
        try:
            await bot.close()
            print("Bot closed, restarting...")
        except:
            pass

@bot.event
async def on_command_error(ctx, error):
    """Handle command errors gracefully"""
    if isinstance(error, commands.CommandNotFound):
        return  # Ignore unknown commands
    
    print(f"Command error in {ctx.command}: {error}")
    logging.error(f"Command error in {ctx.command}: {error}", exc_info=True)
    
    # Send user-friendly error message
    try:
        await safe_send(ctx, embed=discord.Embed(title="❌ Error", description=f"An error occurred: {str(error)}", color=0xe74c3c))
    except:
        pass  # Don't let error handling cause more errors

@bot.event
async def on_disconnect():
    """Handle disconnection gracefully"""
    print("Bot disconnected from Discord. Attempting to reconnect...")
    logging.warning("Bot disconnected from Discord")

@bot.event
async def on_resumed():
    """Handle reconnection"""
    print("Bot resumed connection to Discord")
    logging.info("Bot resumed connection to Discord")

@bot.event
async def on_connect():
    """Handle successful connection"""
    print("Bot connected to Discord")
    logging.info("Bot connected to Discord")








# Admin: Change bot status
@bot.command(name="bot_status")
@commands.has_permissions(administrator=True)
async def bot_status(ctx, status: str = "dnd", *, activity: str = "discord.gg/rtoc"):
    """Change bot status (online, idle, dnd, invisible) and activity text"""
    
    # Map status string to discord.Status enum
    status_map = {
        "online": discord.Status.online,
        "idle": discord.Status.idle,
        "dnd": discord.Status.dnd,
        "invisible": discord.Status.invisible
    }
    
    if status.lower() not in status_map:
        await send_embed(ctx, "❌ Invalid Status", "Valid statuses: online, idle, dnd, invisible", 0xe74c3c)
        return
    
    try:
        # Set the bot status and activity
        await bot.change_presence(
            status=status_map[status.lower()],
            activity=discord.Activity(
                type=discord.ActivityType.playing,
                name=activity
            )
        )
        
        embed = discord.Embed(title="🤖 Bot Status Updated", color=0x2ecc71)
        embed.description = f"**Status:** {status.title()}\n**Activity:** Playing {activity}"
        embed.set_footer(text=f"Changed by {ctx.author.display_name}")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "❌ Error", f"Failed to change bot status: {str(e)}", 0xe74c3c)


@bot.command(name="bot_note")
@commands.has_permissions(administrator=True)
async def bot_note(ctx, *, note: str):
    """Change the bot's custom status note (what shows above the name)"""
    try:
        # Try to set a custom status note above the username while maintaining DND status
        await bot.change_presence(
            status=discord.Status.dnd,  # Keep DND status
            activity=discord.Activity(
                type=discord.ActivityType.custom,
                name=note,
                state=note  # Try both name and state
            )
        )
        
        embed = discord.Embed(title="🤖 Bot Note Updated", color=0x2ecc71)
        embed.description = f"**New Status Note:** {note} (above the name)\n**Status:** Do Not Disturb (red dot)"
        embed.set_footer(text=f"Changed by {ctx.author.display_name}")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        # Fallback: try without state parameter
        try:
            await bot.change_presence(
                status=discord.Status.dnd,  # Keep DND status
                activity=discord.Activity(
                    type=discord.ActivityType.custom,
                    name=note
                )
            )
            
            embed = discord.Embed(title="🤖 Bot Note Updated (Fallback)", color=0xf39c12)
            embed.description = f"**New Status Note:** {note} (above the name) - fallback method\n**Status:** Do Not Disturb (red dot)"
            embed.set_footer(text=f"Changed by {ctx.author.display_name}")
            
            await ctx.send(embed=embed)
            
        except Exception as e2:
            await send_embed(ctx, "❌ Error", f"Failed to change bot note: {str(e2)}", 0xe74c3c)


@bot.command(name="servers")
@commands.has_permissions(administrator=True)
async def servers(ctx):
    """Show all servers the bot is in (Admin only)"""
    try:
        embed = discord.Embed(title="🏠 Bot Servers", color=0x3498db)
        embed.description = f"Bot is currently in **{len(bot.guilds)}** servers"
        
        # Sort servers by member count (largest first)
        sorted_guilds = sorted(bot.guilds, key=lambda g: g.member_count, reverse=True)
        
        server_list = ""
        total_members = 0
        
        for i, guild in enumerate(sorted_guilds[:25], 1):  # Show top 25 servers
            member_count = guild.member_count
            total_members += member_count
            
            # Get server owner
            owner = guild.owner
            owner_name = owner.display_name if owner else "Unknown"
            
            # Get bot's role in this server
            bot_member = guild.get_member(bot.user.id)
            bot_role = bot_member.top_role.name if bot_member and bot_member.top_role else "No Role"
            
            server_list += f"**{i}.** {guild.name}\n"
            server_list += f"   👥 **Members:** {member_count:,}\n"
            server_list += f"   👑 **Owner:** {owner_name}\n"
            server_list += f"   🤖 **Bot Role:** {bot_role}\n"
            server_list += f"   🆔 **ID:** {guild.id}\n\n"
        
        if len(sorted_guilds) > 25:
            server_list += f"... and **{len(sorted_guilds) - 25}** more servers"
        
        embed.add_field(
            name="📊 Server Statistics", 
            value=f"**Total Servers:** {len(bot.guilds):,}\n**Total Members:** {total_members:,}",
            inline=False
        )
        
        embed.add_field(
            name="🏆 Top Servers by Member Count", 
            value=server_list,
            inline=False
        )
        
        embed.set_footer(text=f"Requested by {ctx.author.display_name}")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "❌ Error", f"Failed to get server list: {str(e)}", 0xe74c3c)
        logging.error(f"Failed to get server list: {e}", exc_info=True)


# Admin: force sync slash commands if commands look outdated
@bot.tree.command(name="sync", description="Admin: force sync slash commands")
@app_commands.checks.has_permissions(administrator=True)
async def sync_commands(interaction: discord.Interaction, scope: str = "global"):
    """scope options: 'guild', 'global' (default), 'full' (clear and resync)"""
    try:
        chosen = scope.lower()
        if chosen == "full":
            # Clear guild and global then resync everything globally
            bot.tree.clear_commands(guild=interaction.guild)
            bot.tree.clear_commands(guild=None)
            synced = await bot.tree.sync()
            await interaction.response.send_message(f"Fully resynced {len(synced)} global commands.", ephemeral=True)
            return
        if chosen == "global":
            synced = await bot.tree.sync()
            await interaction.response.send_message(f"Synced {len(synced)} global commands.", ephemeral=True)
            return
        # default to guild scope
        synced = await bot.tree.sync(guild=interaction.guild)
        await interaction.response.send_message(f"Synced {len(synced)} commands for this guild.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"Sync failed: {e}", ephemeral=True)


# -----------------------
# Part 2/6 - Jobs, Work, Cultivate, Collect, Store basics
# (Paste after Part 1 content)
# -----------------------

# Daily and Weekly Commands
@bot.hybrid_command(name="daily", description="Collect your daily reward")
async def daily(ctx):
    await ctx.defer()
    current_timestamp = int(time.time())
    meta = get_user_meta(ctx.author.id)

    last_daily = meta.get("last_daily")
    
    # Handle both integer timestamps and legacy ISO strings
    if isinstance(last_daily, (int, float)):
        last_daily_timestamp = int(last_daily)
    elif last_daily:
        try:
            last_daily_dt = datetime.fromisoformat(last_daily)
            last_daily_timestamp = int(last_daily_dt.timestamp())
        except (ValueError, TypeError):
            last_daily_timestamp = 0
    else:
        last_daily_timestamp = 0

    # Check if 24 hours have passed since last claim (86400 seconds = 24 hours)
    cooldown_seconds = 86400
    if last_daily_timestamp > 0 and current_timestamp < last_daily_timestamp + cooldown_seconds:
        remaining_seconds = (last_daily_timestamp + cooldown_seconds) - current_timestamp
        hours = remaining_seconds // 3600
        minutes = (remaining_seconds % 3600) // 60
        seconds = remaining_seconds % 60
        
        next_available_timestamp = last_daily_timestamp + cooldown_seconds

        embed = discord.Embed(title="Daily Reward", color=0xe74c3c)
        embed.description = f"⏳ You've already claimed your daily reward."
        embed.add_field(name="Time Remaining", value=f"{hours}h {minutes}m {seconds}s", inline=True)
        embed.add_field(name="Available At", value=f"<t:{next_available_timestamp}:R> at <t:{next_available_timestamp}:t>", inline=True)
        embed.set_footer(text=f"Available again at <t:{next_available_timestamp}:F>")
        await ctx.send(embed=embed)
        return

    # Fixed reward of 50,000 spirit stones
    reward = 50000

    # Apply sect bonus if applicable
    sect_data = load_json(SECTS_FILE)
    user_sect = get_user_meta(ctx.author.id).get("sect")
    bonus = 0
    boost_pct = 0
    if user_sect and isinstance(sect_data, dict) and user_sect in sect_data:
        boost_pct = int(sect_data[user_sect].get("boost_percent", 0))
        if boost_pct > 0:
            bonus = int(reward * boost_pct / 100)
    total_after_sect = reward + bonus
    
    # Apply sect shop daily bonus boosts
    total_after_sect, sect_bonus, sect_boost_pct = apply_sect_boosts_to_income(ctx.author.id, total_after_sect)
    
    total_after_sect, art_bonus, art_pct = apply_money_bonus_for_keys(ctx.author.id, total_after_sect, ["global_gold_gain_pct"]) 
    add_cash(ctx.author.id, total_after_sect)
    
    # Give daily immortal art rerolls
    daily_rerolls = 3
    meta = get_user_meta(ctx.author.id)
    if "immortal_arts" not in meta:
        meta["immortal_arts"] = {"rerolls": 0, "slots": [], "unlocked_slots": 1}
    
    current_rerolls = meta["immortal_arts"].get("rerolls", 0)
    meta["immortal_arts"]["rerolls"] = current_rerolls + daily_rerolls
    
    # Update last daily and immortal arts
    meta["last_daily"] = current_timestamp
    set_user_meta(ctx.author.id, meta)
    
    # Reset daily store items (like rerolls)
    reset_daily_store_items()

    # Calculate next available time
    next_available_timestamp = current_timestamp + cooldown_seconds

    embed = discord.Embed(title="Daily Reward", color=0x00ff00)
    desc = f"You claimed your daily reward!"
    
    # Show base reward
    desc += f"\n\n**Daily reward: {MONEY_ICON} {reward:,}**"
    
    # Show sect bonus
    if bonus > 0 and user_sect:
        desc += f"\n**Sect bonus from {user_sect}: {MONEY_ICON} {bonus} (+{boost_pct}%)**"
    
    # Show Immortal Art bonus
    if art_bonus > 0:
        desc += f"\n**Immortal Art bonus: {MONEY_ICON} {art_bonus} (+{art_pct:.1f}%)**"
    
    desc += f"\n\n**Total: {MONEY_ICON} {total_after_sect:,}**"
    desc += f"\n🎲 **Daily Rerolls: +{daily_rerolls} immortal art rerolls**"
    desc += f"\n🎲 **Total Rerolls: {meta['immortal_arts']['rerolls']}**"
    
    embed.description = desc
    embed.add_field(name="Next Available", value=f"<t:{next_available_timestamp}:R> at <t:{next_available_timestamp}:t>", inline=True)
    embed.add_field(name="🎲 Rerolls", value=f"Daily: +{daily_rerolls} | Total: {meta['immortal_arts']['rerolls']}", inline=True)
    embed.set_footer(text=f"Available again at <t:{next_available_timestamp}:F>")
    await ctx.send(embed=embed)





# -----------------------
# Status Window with Attributes System
# -----------------------

def get_user_attributes(user_id: int) -> dict:
    """Get user's attribute points and available points to allocate"""
    try:
        meta = get_user_meta(user_id)
        if not meta or not isinstance(meta, dict):
            print(f"DEBUG: Invalid meta for user {user_id}: {meta}")
            return {
                "strength": 0,
                "luck": 0,
                "longevity": 0,
                "defence": 0
            }, 0
        
        attributes = meta.get("attributes", {
            "strength": 0,
            "luck": 0,
            "longevity": 0,
            "defence": 0
        })
        
        if not isinstance(attributes, dict):
            print(f"DEBUG: Invalid attributes for user {user_id}: {attributes}")
            attributes = {
                "strength": 0,
                "luck": 0,
                "longevity": 0,
                "defence": 0
            }
        
        available_points = meta.get("available_attribute_points", 0)
        if not isinstance(available_points, (int, float)):
            print(f"DEBUG: Invalid available_points for user {user_id}: {available_points}")
            available_points = 0
        
        return attributes, available_points
    except Exception as e:
        print(f"ERROR in get_user_attributes for user {user_id}: {e}")
        return {
            "strength": 0,
            "luck": 0,
            "longevity": 0,
            "defence": 0
        }, 0


def add_attribute_point(user_id: int, attribute: str) -> bool:
    """Add a point to a specific attribute if user has points available"""
    meta = get_user_meta(user_id)
    available_points = meta.get("available_attribute_points", 0)
    
    if available_points <= 0:
        return False
    
    if attribute not in ["strength", "luck", "longevity", "defence"]:
        return False
    
    attributes = meta.get("attributes", {
        "strength": 0,
        "luck": 0,
        "longevity": 0,
        "defence": 0
    })
    
    attributes[attribute] += 1
    meta["attributes"] = attributes
    meta["available_attribute_points"] = available_points - 1
    set_user_meta(user_id, meta)
    return True


def calculate_attribute_points_from_level(level: int) -> int:
    """Calculate how many attribute points a user should have based on their level"""
    # Each level gives 1 attribute point
    return level


class AttributeView(discord.ui.View):
    """View for allocating attribute points"""
    
    def __init__(self, user_id: int):
        super().__init__(timeout=300)  # 5 minutes timeout
        self.user_id = user_id
    
    @discord.ui.button(label="Strength +1", style=discord.ButtonStyle.primary, custom_id="strength", row=0)
    async def strength_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("This status window is not yours!", ephemeral=True)
            return
        
        success = add_attribute_point(self.user_id, "strength")
        if success:
            await interaction.response.send_message("+1 Strength point added!", ephemeral=True)
            # Update the original message with new stats
            await self.update_status_message(interaction)
        else:
            await interaction.response.send_message("No attribute points available!", ephemeral=True)
    
    @discord.ui.button(label="Luck +1", style=discord.ButtonStyle.success, custom_id="luck", row=0)
    async def luck_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("This status window is not yours!", ephemeral=True)
            return
        
        success = add_attribute_point(self.user_id, "luck")
        if success:
            await interaction.response.send_message("+1 Luck point added!", ephemeral=True)
            await self.update_status_message(interaction)
        else:
            await interaction.response.send_message("No attribute points available!", ephemeral=True)
    
    @discord.ui.button(label="Longevity +1", style=discord.ButtonStyle.secondary, custom_id="longevity", row=1)
    async def longevity_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("This status window is not yours!", ephemeral=True)
            return
        
        success = add_attribute_point(self.user_id, "longevity")
        if success:
            await interaction.response.send_message("+1 Longevity point added!", ephemeral=True)
            await self.update_status_message(interaction)
        else:
            await interaction.response.send_message("No attribute points available!", ephemeral=True)
    
    @discord.ui.button(label="Defence +1", style=discord.ButtonStyle.danger, custom_id="defence", row=1)
    async def defence_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("This status window is not yours!", ephemeral=True)
            return
        
        success = add_attribute_point(self.user_id, "defence")
        if success:
            await interaction.response.send_message("+1 Defence point added!", ephemeral=True)
            await self.update_status_message(interaction)
        else:
            await interaction.response.send_message("No attribute points available!", ephemeral=True)
    
    async def update_status_message(self, interaction: discord.Interaction):
        """Update the status message with current stats"""
        try:
            # Get updated stats
            attributes, available_points = get_user_attributes(self.user_id)
            meta = get_user_meta(self.user_id)
            user_xp = int(meta.get("sect_xp", 0))
            level, cur_xp, needed, req = get_member_level_and_progress(user_xp)
            
            # Calculate expected attribute points
            expected_points = calculate_attribute_points_from_level(level)
            total_allocated = sum(attributes.values())
            
            # Create updated embed
            embed = discord.Embed(title="Status Window", color=0x9b59b6, description="Your cultivation progress and attribute allocation")
            embed.set_author(name=interaction.user.display_name, icon_url=interaction.user.display_avatar.url)
            
            # Sect Level Info
            embed.add_field(
                name="Sect Level", 
                value=f"**Level:** {level}\n**XP:** {cur_xp:,}/{req:,}\n**Next Level:** {needed:,} XP needed", 
                inline=False
            )
            
            # Attributes
            embed.add_field(
                name="Strength", 
                value=f"**{attributes['strength']}** points", 
                inline=True
            )
            embed.add_field(
                name="Luck", 
                value=f"**{attributes['luck']}** points", 
                inline=True
            )
            embed.add_field(
                name="Longevity", 
                value=f"**{attributes['longevity']}** points", 
                inline=True
            )
            embed.add_field(
                name="Defence", 
                value=f"**{attributes['defence']}** points", 
                inline=True
            )
            
            # Available Points
            embed.add_field(
                name="Available Points", 
                value=f"**{available_points}** points to allocate", 
                inline=False
            )
            
            # Progress info
            if total_allocated < expected_points:
                embed.add_field(
                    name="Progress", 
                    value=f"**{total_allocated}/{expected_points}** points allocated\nYou have **{expected_points - total_allocated}** unallocated points!", 
                    inline=False
                )
                embed.set_footer(text="Click the buttons below to allocate your attribute points")
            else:
                embed.add_field(
                    name="Progress", 
                    value=f"**{total_allocated}/{expected_points}** points allocated\n✅ All points allocated for your level!", 
                    inline=False
                )
                embed.set_footer(text="All attribute points allocated for your current level")
            
            # Update the message
            await interaction.message.edit(embed=embed, view=self)
            
        except Exception as e:
            await interaction.followup.send(f"❌ Error updating status: {str(e)}", ephemeral=True)


@bot.hybrid_command(name="status_window", description="View your cultivation level, XP progress, and attributes (works for all users)")
async def status_window(ctx):
    """Display status window with cultivation level, XP progress, and attributes"""
    meta = get_user_meta(ctx.author.id)
    user_xp = int(meta.get("sect_xp", 0))
    level, cur_xp, needed, req = get_member_level_and_progress(user_xp)
    
    # Get current attributes and available points
    attributes, available_points = get_user_attributes(ctx.author.id)
    
    # Calculate expected attribute points based on level
    expected_points = calculate_attribute_points_from_level(level)
    total_allocated = sum(attributes.values())
    
    # If user has fewer points than they should, give them the missing ones
    if total_allocated + available_points < expected_points:
        missing_points = expected_points - total_allocated - available_points
        meta["available_attribute_points"] = available_points + missing_points
        set_user_meta(ctx.author.id, meta)
        available_points += missing_points
    
    # Also check if user needs initial attribute points for their current level
    if total_allocated == 0 and available_points == 0:
        # Give points for current level (new users)
        initial_points = expected_points
        meta["available_attribute_points"] = initial_points
        set_user_meta(ctx.author.id, meta)
        available_points = initial_points
    
    # Create the status embed
    embed = discord.Embed(title="Status Window", color=0x9b59b6, description="Your cultivation progress and attribute allocation")
    embed.set_author(name=ctx.author.display_name, icon_url=ctx.author.display_avatar.url)
    
    # Attribute System Description
    embed.add_field(
        name="📊 Attribute System", 
        value="Each attribute point provides specific bonuses to different game mechanics. Allocate your points wisely!", 
        inline=False
    )
    
    # Cultivation Level Info
    sect_name = meta.get("sect")
    
    # Clean up corrupted sect data
    if sect_name:
        sects_data = load_json(SECTS_FILE)
        if sect_name not in sects_data or ctx.author.id not in sects_data.get(sect_name, {}).get("members", []):
            meta["sect"] = None
            meta["sect_rank"] = None
            set_user_meta(ctx.author.id, meta)
            sect_name = None
    
    level_title = "Sect Level" if sect_name else "Cultivation Level"
    embed.add_field(
        name=level_title, 
        value=f"**Level:** {level}\n**XP:** {cur_xp:,}/{req:,}\n**Next Level:** {needed:,} XP needed", 
        inline=False
    )
    
    # Decorative Title
    decorative_title = get_decorative_title(level, sect_name)
    embed.add_field(
        name="Title", 
        value=f"**{decorative_title}**", 
        inline=False
    )
    
    # Attributes with descriptions
    embed.add_field(
        name="⚔️ Strength", 
        value=f"**{attributes['strength']}** points\n*Increases attack damage in PvP battles (+2 damage per point)*", 
        inline=True
    )
    embed.add_field(
        name="🍀 Luck", 
        value=f"**{attributes['luck']}** points\n*Increases gambling payouts and PvP success rate (+1% payout, +0.25% success per point)*", 
        inline=True
    )
    embed.add_field(
        name="❤️ Longevity", 
                        value=f"**{attributes['longevity']}** points\n*Increases maximum HP in PvP battles (+1 HP per point)*", 
        inline=True
    )
    embed.add_field(
        name="🛡️ Defence", 
        value=f"**{attributes['defence']}** points\n*Reduces damage taken when countering in PvP (+5% damage reduction per point)*", 
        inline=True
    )
    
    # Available Points
    embed.add_field(
        name="Available Points", 
        value=f"**{available_points}** points to allocate", 
        inline=False
    )
    
    # Progress info
    if total_allocated < expected_points:
        embed.add_field(
            name="Progress", 
            value=f"**{total_allocated}/{expected_points}** points allocated\nYou have **{expected_points - total_allocated}** unallocated points!", 
            inline=False
        )
    else:
        embed.add_field(
            name="Progress", 
            value=f"**{total_allocated}/{expected_points}** points allocated\n✅ All points allocated for your level!", 
            inline=False
        )
    
    # Create view with buttons if user has points to allocate
    view = AttributeView(ctx.author.id) if available_points > 0 else None
    
    # Add footer with instructions
    if available_points > 0:
        footer_text = "Click the buttons below to allocate your attribute points"
    else:
        footer_text = "All attribute points allocated for your current level"
    
    # Add helpful note for users not in a sect
    if not sect_name:
        footer_text += " • Use /expedition to gain XP even without sect membership"
    
    footer_text += " • Each attribute provides specific bonuses to different game mechanics"
    embed.set_footer(text=footer_text)
    
    await ctx.send(embed=embed, view=view)


# -----------------------
# Shortened Status Command
# -----------------------

@bot.command(name="status", aliases=["s"])
async def status_short(ctx):
    """Shortened prefix command for status_window"""
    await status_window(ctx)


# -----------------------
# Expedition Command
# -----------------------

def get_expedition_rewards(user_id: int) -> dict:
    """Get expedition rewards based on user's attributes and sect level"""
    attributes, _ = get_user_attributes(user_id)
    meta = get_user_meta(user_id)
    user_xp = int(meta.get("sect_xp", 0))
    level, _, _, _ = get_member_level_and_progress(user_xp)
    
    # Base rewards (3x boost applied)
    base_money = random.randint(1500, 6000)  # 3x boost from 500-2000
    base_xp = random.randint(100, 500)
    
    # Attribute bonuses
    strength_bonus = attributes.get("strength", 0) * 50  # +50 money per strength
    luck_bonus = attributes.get("luck", 0) * 100  # +100 money per luck
    longevity_bonus = attributes.get("longevity", 0) * 1  # +1 HP per longevity point
    
    # Level bonuses
    level_bonus = level * 25  # +25 money per level
    
    # Calculate final rewards
    final_money = base_money + strength_bonus + luck_bonus + level_bonus
    final_xp = base_xp + longevity_bonus
    
    # Determine if user gets special rewards
    special_rewards = []
    
    # Storage ring chance (5% base + 1% per luck point)
    storage_ring_chance = 5 + attributes.get("luck", 0)
    if random.randint(1, 100) <= storage_ring_chance:
        storage_ring = {
            "name": "Storage Ring",
            "type": "artifact",
            "description": "A magical ring that increases your storage capacity",
            "storage_bonus": random.randint(5, 15),
            "rarity": "rare",
            "value": 80000,  # Use new pricing: rare artifact = 80k
            "emoji": "💍"
        }
        special_rewards.append(storage_ring)
    
    # Immortal Art reroll chance (2% base + 0.5% per luck point)
    reroll_chance = 2 + (attributes.get("luck", 0) * 0.5)
    if random.randint(1, 100) <= reroll_chance:
        special_rewards.append("immortal_art_reroll")
    
    # Rare loot chance (10% base + 2% per luck point)
    loot_chance = 10 + (attributes.get("luck", 0) * 2)
    if random.randint(1, 100) <= loot_chance:
        loot_items = [
            "Ancient Scroll", "Spirit Crystal", "Cultivation Pill", "Mystic Herb",
            "Dragon Scale", "Phoenix Feather", "Void Essence", "Celestial Fragment"
        ]
        loot_item = random.choice(loot_items)
        special_rewards.append({
            "type": "loot", 
            "item": loot_item, 
            "rarity": "rare",
            "value": 20000  # Use new pricing: rare loot = 20k
        })
    
    # Ore chance (20% base + 3% per luck point)
    ore_chance = 20 + (attributes.get("luck", 0) * 3)
    if random.randint(1, 100) <= ore_chance:
        # Weighted rarity selection - make mythic and divine extremely rare
        if random.random() < 0.02:  # 2% chance for legendary
            if random.random() < 0.05:  # 5% chance for mythic (when legendary is rolled)
                if random.random() < 0.005:  # 0.5% chance for divine (when mythic is rolled)
                    ore_rarity = "divine"
                    ore_names = ["Divine Ore", "Creation Metal", "Genesis Stone"]
                    ore_value = 100000000  # Use new pricing: divine ore = 100M
                else:
                    ore_rarity = "mythic"
                    ore_names = ["Void Ore", "Ethereal Ore", "Cosmic Metal"]
                    ore_value = 10000000  # Use new pricing: mythic ore = 10M
            else:
                ore_rarity = "legendary"
                ore_names = ["Dragon Ore", "Phoenix Ore", "Star Metal"]
                ore_value = 600000  # Use new pricing: legendary ore = 600k
        else:
            # Common rarities only
            ore_rarities = ["common", "uncommon", "rare"]
            ore_rarity = random.choice(ore_rarities)
            ore_names = {
                "common": ["Iron Ore", "Copper Ore", "Stone"],
                "uncommon": ["Silver Ore", "Gold Ore", "Coal"],
                "rare": ["Mithril Ore", "Adamantite Ore", "Crystal"]
            }
            ore_value = {"common": 450, "uncommon": 1300, "rare": 30000}[ore_rarity]  # Use new pricing
        
        # Handle both list and dictionary cases for ore_names
        if isinstance(ore_names, list):
            ore_name = random.choice(ore_names)
        else:
            # If ore_names is a dictionary, choose from the appropriate rarity list
            ore_name = random.choice(ore_names.get(ore_rarity, ["Unknown Ore"]))
        
        special_rewards.append({
            "type": "ore", 
            "item": ore_name, 
            "rarity": ore_rarity,
            "value": ore_value
        })
    
    # Material chance (15% base + 2% per luck point)
    material_chance = 15 + (attributes.get("luck", 0) * 2)
    if random.randint(1, 100) <= material_chance:
        # Weighted rarity selection - make epic extremely rare
        if random.random() < 0.05:  # 5% chance for epic (when material is rolled)
            material_rarity = "epic"
        else:
            material_rarities = ["common", "uncommon", "rare"]
            material_rarity = random.choice(material_rarities)
        
        material_names = {
            "common": ["Basic Cloth", "Simple Leather", "Weak Thread"],
            "uncommon": ["Quality Fabric", "Sturdy Leather", "Strong Thread"],
            "rare": ["Enchanted Silk", "Mystic Leather", "Magical Thread"],
            "epic": ["Tungsten Silk", "Platinum Leather", "Enchanted Thread"]
        }
        
        material_name = random.choice(material_names.get(material_rarity, ["Unknown Material"]))
        material_value = {"common": 500, "uncommon": 2500, "rare": 12500, "epic": 25000}[material_rarity]
        
        special_rewards.append({
            "type": "material", 
            "item": material_name, 
            "rarity": material_rarity,
            "value": material_value
        })
    
    # Legendary loot chance (0.5% base + 0.1% per luck point) - EXTREMELY RARE
    legendary_loot_chance = 0.5 + (attributes.get("luck", 0) * 0.1)
    if random.random() * 100 <= legendary_loot_chance:
        # Weighted selection for legendary+
        if random.random() < 0.05:  # 5% chance for mythic (when legendary is rolled)
            if random.random() < 0.005:  # 0.5% chance for divine (when mythic is rolled)
                rarity = "divine"
                legendary_items = [
                    "Splitting Heavens Fragment", "Divine Essence", "Heaven's Core",
                    "Omnipotent Essence", "Creation Fragment", "Destiny Essence"
                ]
                item_value = 1000000  # Divine items worth 1 million
            else:
                rarity = "mythic"
                legendary_items = [
                    "Mythic Sword", "Ethereal Armor", "Void Artifact", "Cosmic Relic"
                ]
                item_value = 500000  # Mythic items worth 500k
        else:
            rarity = "legendary"
            legendary_items = [
                "Legendary Sword", "Mythic Armor", "Divine Artifact", "Cosmic Relic"
            ]
            item_value = 100000  # Legendary items worth 100k
        
        legendary_item = random.choice(legendary_items)
        special_rewards.append({
            "type": "loot", 
            "item": legendary_item, 
            "rarity": rarity,
            "value": item_value
        })
    
    result = {
        "money": final_money,
        "xp": final_xp,
        "special_rewards": special_rewards,
        "attributes_used": {
            "strength": attributes.get("strength", 0),
            "luck": attributes.get("luck", 0),
            "longevity": attributes.get("longevity", 0)
        }
    }
    
    print(f"DEBUG: get_expedition_rewards returning: {result}")
    return result


@bot.hybrid_command(name="expedition", description="Go on a cultivator expedition to find treasures and gain XP")
async def expedition(ctx):
    """Go on a cultivator expedition with various rewards and encounters"""
    user_id = ctx.author.id
    
    # Check cooldown
    meta = get_user_meta(user_id)
    last_expedition = meta.get("last_expedition")
    
    if last_expedition:
        try:
            # Handle both integer timestamps and legacy ISO strings
            if isinstance(last_expedition, (int, float)):
                last_expedition_timestamp = int(last_expedition)
            else:
                last_expedition_dt = datetime.fromisoformat(last_expedition)
                last_expedition_timestamp = int(last_expedition_dt.timestamp())
            
            cooldown_seconds = 30 * 60  # 30 minutes in seconds
            current_timestamp = int(time.time())
            
            if current_timestamp < last_expedition_timestamp + cooldown_seconds:
                remaining_seconds = (last_expedition_timestamp + cooldown_seconds) - current_timestamp
                minutes = remaining_seconds // 60
                seconds = remaining_seconds % 60
                
                embed = discord.Embed(
                    title="Expedition Cooldown", 
                    description=f"You must wait before going on another expedition.",
                    color=0xe74c3c
                )
                embed.add_field(
                    name="Time Remaining", 
                    value=f"{minutes}m {seconds}s", 
                    inline=False
                )
                await ctx.send(embed=embed)
                return
        except:
            pass
    
    # Check if user has enough money for expedition (optional cost)
    expedition_cost = 100
    cash, bank = get_balances(user_id)
    
    if cash < expedition_cost:
        embed = discord.Embed(
            title="Expedition Failed", 
            description=f"You need {MONEY_ICON} {expedition_cost} to go on an expedition.",
            color=0xe74c3c
        )
        await ctx.send(embed=embed)
        return
    
    # Deduct expedition cost
    set_cash(user_id, cash - expedition_cost)
    
    # Get expedition rewards
    try:
        rewards = get_expedition_rewards(user_id)
        print(f"DEBUG: Expedition rewards received: {rewards}")
        print(f"DEBUG: Rewards type: {type(rewards)}")
        print(f"DEBUG: Rewards keys: {list(rewards.keys()) if isinstance(rewards, dict) else 'Not a dict'}")
        
        # Ensure rewards has the expected structure
        if not isinstance(rewards, dict):
            print(f"ERROR: get_expedition_rewards returned non-dict: {type(rewards)}")
            rewards = {"money": 1000, "xp": 100, "special_rewards": [], "attributes_used": {"strength": 0, "luck": 0, "longevity": 0}}
        elif "attributes_used" not in rewards:
            print(f"ERROR: rewards missing attributes_used: {rewards}")
            rewards["attributes_used"] = {"strength": 0, "luck": 0, "longevity": 0}
        
        # Check for encounters (configurable chance)
        encounter_occurred = False
        encounter_result = None
        if random.random() < EXPEDITION_ENCOUNTER_CHANCE:
            encounter_occurred = True
            # Get user level for encounter scaling
            user_level, _, _, _ = get_member_level_and_progress(int(meta.get("sect_xp", 0)))
            encounter = generate_expedition_encounter(user_level)
            encounter_result = resolve_combat_encounter(user_id, encounter)
            
            # Add encounter XP to rewards
            rewards["xp"] += encounter_result["experience_gained"]
    except Exception as e:
        print(f"ERROR: Failed to get expedition rewards: {e}")
        print(f"ERROR: Traceback: {traceback.format_exc()}")
        # Fallback rewards
        rewards = {"money": 1000, "xp": 100, "special_rewards": [], "attributes_used": {"strength": 0, "luck": 0, "longevity": 0}}
        encounter_occurred = False
        encounter_result = None
    
    # Apply rewards
    add_cash(user_id, rewards["money"])
    add_sect_xp(user_id, rewards["xp"])
    
    # Add special rewards to inventory and update expedition time
    meta["last_expedition"] = int(time.time())
    
    if rewards["special_rewards"]:
        print(f"DEBUG: Expedition special rewards: {rewards['special_rewards']}")
        
        for reward in rewards["special_rewards"]:
            if isinstance(reward, dict):
                if reward.get("name") == "Storage Ring":
                    # Storage ring is a special item
                    add_item_to_inventory(user_id, reward)
                    print(f"DEBUG: Added Storage Ring to inventory")
                elif reward.get("type") in ["loot", "ore", "material"]:
                    # Regular loot items, ore, and materials
                    inventory_item = {
                        "name": reward.get("item", "Unknown Item"),
                        "type": reward.get("type", "item"),
                        "rarity": reward.get("rarity", "common"),
                        "value": reward.get("value", 0),
                        "description": f"A {reward.get('rarity', 'common')} {reward.get('type', 'item')} found during expedition",
                        "added_by": user_id,
                        "added_at": int(time.time()),
                        "source": "expedition"
                    }
                    add_item_to_inventory(user_id, inventory_item)
                    print(f"DEBUG: Added {reward.get('type')} item '{reward.get('item')}' to inventory")
            elif reward == "immortal_art_reroll":
                # Add reroll to user's Immortal Arts
                if "immortal_arts" not in meta:
                    meta["immortal_arts"] = {"rerolls": 0, "slots": [], "unlocked_slots": 1}
                current_rerolls = meta["immortal_arts"].get("rerolls", 0)
                meta["immortal_arts"]["rerolls"] = current_rerolls + 1
                print(f"DEBUG: Added 1 reroll to user {user_id}, total: {meta['immortal_arts']['rerolls']}")
    
    # Save updated meta (but don't overwrite inventory that was updated by add_item_to_inventory)
    # Only save the meta fields that weren't updated by add_item_to_inventory
    current_meta = get_user_meta(user_id)
    current_meta["last_expedition"] = meta["last_expedition"]
    if "immortal_arts" in meta:
        current_meta["immortal_arts"] = meta["immortal_arts"]
    set_user_meta(user_id, current_meta)
    
    # Verify items were added to inventory
    final_meta = get_user_meta(user_id)
    if "inventory" in final_meta:
        print(f"DEBUG: Final inventory count: {len(final_meta['inventory'])}")
        for item in final_meta['inventory']:
            if item.get("source") == "expedition":
                print(f"DEBUG: Found expedition item: {item['name']} (x{item.get('amount', 1)})")
    
    # Create expedition results embed
    embed = discord.Embed(
        title="Expedition Results", 
        description="Your cultivator expedition has concluded!",
        color=0x2ecc71
    )
    embed.set_author(name=ctx.author.display_name, icon_url=ctx.author.display_avatar.url)
    
    # Basic rewards
    embed.add_field(
        name="Wealth Gained", 
        value=f"**{MONEY_ICON} {rewards['money']:,}** (Cost: {MONEY_ICON} {expedition_cost})", 
        inline=True
    )
    embed.add_field(
        name="Experience Gained", 
        value=f"**{rewards['xp']:,}** cultivation XP", 
        inline=True
    )
    
    # Show encounter results if one occurred
    if encounter_occurred and encounter_result:
        try:
            encounter_emoji = encounter_result.get("encounter_emoji", "⚔️")
            encounter_name = encounter_result.get("encounter_name", "Unknown Enemy")
            
            if encounter_result.get("victory", False):
                embed.add_field(
                    name=f"⚔️ Combat Victory! {encounter_emoji}",
                    value=f"You defeated the **{encounter_name}** in {encounter_result.get('rounds', 0)} rounds!\n"
                          f"**Combat XP:** +{encounter_result.get('experience_gained', 0) - rewards.get('xp', 0) + encounter_result.get('experience_gained', 0)}\n"
                          f"**Health Remaining:** {encounter_result.get('user_health_remaining', 0)}",
                    inline=False
                )
                
                # Show loot if any
                if encounter_result.get("loot") and isinstance(encounter_result["loot"], list):
                    try:
                        loot_text = ""
                        for item in encounter_result["loot"]:
                            if not isinstance(item, dict):
                                print(f"DEBUG: Skipping non-dict loot item: {item}")
                                continue
                            
                            rarity_emoji = RARITY_EMOJI.get(item.get("rarity", "common"), "⚪")
                            loot_text += f"{rarity_emoji} **{item.get('name', 'Unknown')}** ({item.get('rarity', 'common').title()})\n"
                            loot_text += f"   {item.get('emoji', '📦')} {item.get('description', 'No description')}\n"
                            if item.get("type") == "weapon":
                                loot_text += f"   ⚔️ Damage: {item.get('damage', 0)}\n"
                            elif item.get("type") == "armor":
                                loot_text += f"   🛡️ Health: {item.get('health', 0)}\n"
                            elif item.get("type") == "artifact":
                                abilities = item.get("abilities", [])
                                if isinstance(abilities, list):
                                    loot_text += f"   ✨ Abilities: {', '.join(abilities)}\n"
                                else:
                                    loot_text += f"   ✨ Abilities: None\n"
                            loot_text += f"   💰 Value: {MONEY_ICON} {item.get('value', 0):,}\n\n"
                        
                        if loot_text.strip():
                            embed.add_field(
                                name="🎁 Equipment Found!",
                                value=loot_text.strip(),
                                inline=False
                            )
                        
                        # Add items to inventory using stacking function
                        for item in encounter_result["loot"]:
                            if isinstance(item, dict):
                                add_item_to_inventory(user_id, item)
                            else:
                                print(f"DEBUG: Skipping non-dict loot item for inventory: {item}")
                        # No need to save here since add_item_to_inventory handles it
                    except Exception as e:
                        print(f"ERROR: Failed to process encounter loot: {e}")
                        print(f"DEBUG: encounter_result: {encounter_result}")
                        print(f"DEBUG: loot: {encounter_result.get('loot')}")
                else:
                    print(f"DEBUG: No loot or invalid loot format: {encounter_result.get('loot')}")
            else:
                embed.add_field(
                    name=f"💀 Combat Defeat {encounter_emoji}",
                    value=f"You were defeated by the **{encounter_name}**!\n"
                          f"**Combat XP:** +{encounter_result.get('experience_gained', 0)}\n"
                          f"**Health Remaining:** {encounter_result.get('user_health_remaining', 0)}",
                    inline=False
                )
        except Exception as e:
            print(f"ERROR: Failed to process encounter result: {e}")
            print(f"DEBUG: encounter_result: {encounter_result}")
            embed.add_field(
                name="❌ Combat Error",
                value="An error occurred while processing combat results.",
                inline=False
            )
    
    # Show new title if user leveled up
    new_meta = get_user_meta(user_id)
    new_level, _, _, _ = get_member_level_and_progress(int(new_meta.get("sect_xp", 0)))
    sect_name = new_meta.get("sect")
    new_title = get_decorative_title(new_level, sect_name)
    embed.add_field(
        name="Current Title", 
        value=f"**{new_title}**", 
        inline=False
    )
    
    # Attribute bonuses used
    try:
        attributes_used = rewards.get('attributes_used', {})
        attr_info = f"**Strength:** +{attributes_used.get('strength', 0)} bonus\n"
        attr_info += f"**Luck:** +{attributes_used.get('luck', 0)} bonus\n"
        attr_info += f"**Longevity:** +{attributes_used.get('longevity', 0)} bonus"
        
        embed.add_field(
            name="Attribute Bonuses", 
            value=attr_info, 
            inline=False
        )
    except Exception as e:
        print(f"DEBUG: Error getting attribute bonuses: {e}")
        print(f"DEBUG: rewards structure: {rewards}")
        embed.add_field(
            name="Attribute Bonuses", 
            value="**Strength:** +0 bonus\n**Luck:** +0 bonus\n**Longevity:** +0 bonus", 
            inline=False
        )
    
    # Special rewards
    if rewards["special_rewards"]:
        special_text = ""
        for reward in rewards["special_rewards"]:
            if isinstance(reward, dict):
                if reward.get("name") == "Storage Ring":
                    special_text += f"**Storage Ring** (+{reward['storage_bonus']} storage)\n"
                elif reward.get("type") == "loot":
                    if reward["rarity"] == "rare":
                        rarity_emoji = "🔵"
                    elif reward["rarity"] == "legendary":
                        rarity_emoji = "🟠"
                    elif reward["rarity"] == "divine":
                        rarity_emoji = "🔴"
                    else:
                        rarity_emoji = "⚪"
                    special_text += f"{rarity_emoji} **{reward['item']}** ({reward['rarity'].title()})\n"
                elif reward.get("type") == "ore":
                    rarity_emoji = RARITY_EMOJI.get(reward["rarity"], "⚪")
                    special_text += f"{rarity_emoji} **{reward['item']}** ({reward['rarity'].title()}) - Value: {MONEY_ICON} {reward['value']:,}\n"
                elif reward.get("type") == "material":
                    rarity_emoji = RARITY_EMOJI.get(reward["rarity"], "⚪")
                    special_text += f"{rarity_emoji} **{reward['item']}** ({reward['rarity'].title()}) - Value: {MONEY_ICON} {reward['value']:,}\n"
            elif reward == "immortal_art_reroll":
                special_text += "**Immortal Art Reroll** (use `/reroll` command)\n"
        
        embed.add_field(
            name="Special Rewards", 
            value=special_text.strip(), 
            inline=False
        )
    else:
        embed.add_field(
            name="Special Rewards", 
            value="No special rewards this time.", 
            inline=False
        )
    
    # Add footer with cooldown info and helpful note
    footer_text = "Expedition cooldown: 30 minutes"
    if not meta.get("sect"):
        footer_text += " • XP gained even without sect membership"
    embed.set_footer(text=footer_text)
    
    await ctx.send(embed=embed)





# -----------------------
# Random Cultivator Battle Command
# -----------------------

def generate_cultivator_bot(user_stats: dict) -> dict:
    """Generate a random cultivator bot based on user's combat stats"""
    # Calculate user's combat power rating
    user_power = user_stats["total_damage"] + user_stats["total_defense"] + user_stats["total_health"]
    
    # Determine bot tier based on user power
    if user_power < 100:
        tier = "novice"
        power_multiplier = 0.5
        base_rewards = {"money": 300, "xp": 50, "loot_chance": 0.3}  # 3x boost
    elif user_power < 300:
        tier = "apprentice"
        power_multiplier = 0.8
        base_rewards = {"money": 750, "xp": 100, "loot_chance": 0.4}  # 3x boost
    elif user_power < 600:
        tier = "disciple"
        power_multiplier = 1.0
        base_rewards = {"money": 1500, "xp": 200, "loot_chance": 0.5}  # 3x boost
    elif user_power < 1000:
        tier = "core"
        power_multiplier = 1.3
        base_rewards = {"money": 3000, "xp": 400, "loot_chance": 0.6}  # 3x boost
    elif user_power < 2000:
        tier = "elder"
        power_multiplier = 1.6
        base_rewards = {"money": 6000, "xp": 800, "loot_chance": 0.7}  # 3x boost
    else:
        tier = "master"
        power_multiplier = 2.0
        base_rewards = {"money": 15000, "xp": 1500, "loot_chance": 0.8}  # 3x boost
    
    # Generate bot stats based on tier
    bot_damage = int(user_stats["total_damage"] * power_multiplier * random.uniform(0.8, 1.2))
    bot_defense = int(user_stats["total_defense"] * power_multiplier * random.uniform(0.8, 1.2))
    bot_health = int(user_stats["total_health"] * power_multiplier * random.uniform(0.8, 1.2))
    
    # Bot names by tier
    tier_names = {
        "novice": ["Young Disciple", "Novice Cultivator", "Spirit Seeker", "Qi Gatherer"],
        "apprentice": ["Apprentice Warrior", "Spirit Disciple", "Qi Practitioner", "Cultivation Student"],
        "disciple": ["Core Disciple", "Spirit Warrior", "Qi Master", "Cultivation Adept"],
        "core": ["Core Elder", "Spirit Master", "Qi Grandmaster", "Cultivation Expert"],
        "elder": ["Sect Elder", "Spirit Grandmaster", "Qi Sage", "Cultivation Master"],
        "master": ["Sect Master", "Spirit Sage", "Qi Immortal", "Cultivation Grandmaster"]
    }
    
    bot_name = random.choice(tier_names[tier])
    
    return {
        "name": bot_name,
        "tier": tier,
        "damage": bot_damage,
        "defense": bot_defense,
        "health": bot_health,
        "power_multiplier": power_multiplier,
        "base_rewards": base_rewards
    }

def resolve_cultivator_battle(user_stats: dict, bot_stats: dict) -> dict:
    """Resolve a battle between user and cultivator bot"""
    user_health = user_stats["total_health"]
    bot_health = bot_stats["health"]
    
    # Simple turn-based combat
    rounds = 0
    max_rounds = 15
    
    while user_health > 0 and bot_health > 0 and rounds < max_rounds:
        rounds += 1
        
        # User attacks
        user_damage = max(1, user_stats["total_damage"] - bot_stats["defense"])
        if random.random() < user_stats["critical_chance"] / 100:
            user_damage *= 2  # Critical hit
        bot_health -= user_damage
        
        # Bot attacks back if still alive
        if bot_health > 0:
            bot_damage = max(1, bot_stats["damage"] - user_stats["total_defense"])
            user_health -= bot_damage
    
    # Determine outcome
    victory = bot_health <= 0
    user_health_remaining = max(0, user_health)
    
    # Calculate rewards based on performance
    final_money = 0
    performance_multiplier = 1.0
    
    if victory:
        # Base rewards from bot tier
        base_money = bot_stats["base_rewards"]["money"]
        
        # Performance bonus (more health remaining = better bonus)
        health_percentage = user_health_remaining / user_stats["total_health"]
        performance_multiplier = 1.0 + (health_percentage * 0.5)  # Up to 1.5x bonus
        
        final_money = int(base_money * performance_multiplier)
        
        # Generate loot based on tier and performance
        loot = []
        loot_chance = bot_stats["base_rewards"]["loot_chance"] * performance_multiplier
        
        if random.random() < loot_chance:
            # Determine loot rarity based on tier
            tier_rarity_chances = {
                "novice": {"common": 0.8, "uncommon": 0.2},
                "apprentice": {"common": 0.6, "uncommon": 0.3, "rare": 0.1},
                "disciple": {"common": 0.4, "uncommon": 0.4, "rare": 0.2},
                "core": {"common": 0.2, "uncommon": 0.4, "rare": 0.3, "legendary": 0.1},
                "elder": {"common": 0.1, "uncommon": 0.3, "rare": 0.3, "epic": 0.2, "legendary": 0.1},
                "master": {"common": 0.05, "uncommon": 0.2, "rare": 0.3, "epic": 0.3, "legendary": 0.1, "mythic": 0.05}
            }
            
            rarity_roll = random.random()
            cumulative = 0
            selected_rarity = "common"
            
            for rarity, chance in tier_rarity_chances[bot_stats["tier"]].items():
                cumulative += chance
                if rarity_roll <= cumulative:
                    selected_rarity = rarity
                    break
            
            # Generate loot item
            loot_types = ["ore", "loot", "weapon", "armor", "artifact"]
            loot_type = random.choice(loot_types)
            
            if loot_type == "ore":
                # Get a random ore from the selected rarity
                if selected_rarity in ORE_TYPES:
                    ore_name = random.choice(ORE_TYPES[selected_rarity])
                    # Use new direct pricing system for ore
                    if selected_rarity == "common":
                        ore_value = 450
                    elif selected_rarity == "uncommon":
                        ore_value = 1300
                    elif selected_rarity == "rare":
                        ore_value = 30000
                    elif selected_rarity == "epic":
                        ore_value = 120000
                    elif selected_rarity == "legendary":
                        ore_value = 600000
                    elif selected_rarity == "mythic":
                        ore_value = 10000000
                    else:  # divine
                        ore_value = 100000000
                    
                    # Apply randomization
                    if selected_rarity in ["legendary", "mythic", "divine", "primordial"]:
                        random_factor = 0.85 + (random.random() * 0.3)
                        ore_value = int(ore_value * random_factor)
                    else:
                        random_factor = 0.925 + (random.random() * 0.15)
                        ore_value = int(ore_value * random_factor)
                    
                    loot.append({
                        "type": "ore",
                        "name": ore_name,
                        "rarity": selected_rarity,
                        "value": ore_value
                    })
            elif loot_type == "loot":
                # Get a random loot item from the selected rarity
                if selected_rarity in CULTIVATION_LOOT_ITEMS:
                    loot_name = random.choice(list(CULTIVATION_LOOT_ITEMS[selected_rarity].keys()))
                    # Use new direct pricing system
                    if selected_rarity == "common":
                        loot_value = 300
                    elif selected_rarity == "uncommon":
                        loot_value = 1000
                    elif selected_rarity == "rare":
                        loot_value = 20000
                    elif selected_rarity == "epic":
                        loot_value = 70000
                    elif selected_rarity == "legendary":
                        loot_value = 400000
                    elif selected_rarity == "mythic":
                        loot_value = 4000000
                    else:  # divine
                        loot_value = 70000000
                    
                    # Apply randomization
                    if selected_rarity in ["legendary", "mythic", "divine", "primordial"]:
                        random_factor = 0.85 + (random.random() * 0.3)
                        loot_value = int(loot_value * random_factor)
                    else:
                        random_factor = 0.925 + (random.random() * 0.15)
                        loot_value = int(loot_value * random_factor)
                    
                    loot.append({
                        "type": "loot",
                        "name": loot_name,
                        "rarity": selected_rarity,
                        "value": loot_value
                    })
            else:
                # Equipment
                if loot_type == "weapon":
                    weapon_type = random.choice(list(WEAPON_TYPES.keys()))
                    loot.append(generate_weapon(weapon_type, selected_rarity))
                elif loot_type == "armor":
                    armor_type = random.choice(list(ARMOR_TYPES.keys()))
                    loot.append(generate_armor(armor_type, selected_rarity))
                else:
                    artifact_type = random.choice(list(ARTIFACT_TYPES.keys()))
                    loot.append(generate_artifact(artifact_type, selected_rarity))
        else:
            # No loot generated
            pass
    else:
        final_money = 0
        loot = []
    
    return {
        "victory": victory,
        "money_gained": final_money,
        "loot": loot,
        "rounds": rounds,
        "user_health_remaining": user_health_remaining,
        "bot_name": bot_stats["name"],
        "bot_tier": bot_stats["tier"],
        "performance_multiplier": 1.0 + (user_health_remaining / user_stats["total_health"] * 0.5) if victory else 1.0
    }

# Removed cultivator_battle command to reduce command count


@bot.hybrid_command(name="battle", description="Fight a random cultivator bot for rewards")
async def battle(ctx):
    """Fight random cultivator bots for rewards"""
    try:
        user_id = ctx.author.id
        user_stats = load_user_stats(user_id)
        user_equipment = get_user_equipment(user_id)
        
        # Check cooldown (5 minutes)
        current_time = time.time()
        last_battle = user_stats.get("last_battle", 0)
        cooldown_seconds = 300  # 5 minutes
        
        if current_time - last_battle < cooldown_seconds:
            remaining = cooldown_seconds - (current_time - last_battle)
            minutes = remaining // 60
            seconds = remaining % 60
            await send_embed(ctx, "⏳ Battle Cooldown", f"You must wait **{minutes}m {seconds}s** before battling again.", 0xe74c3c)
            return
        
        # Generate random bot opponent
        bot_tiers = ["novice", "apprentice", "disciple", "core", "elder", "master"]
        bot_tier = random.choice(bot_tiers)
        bot_name = f"{bot_tier.title()} Cultivator"
        
        # Calculate bot stats based on tier
        tier_multiplier = bot_tiers.index(bot_tier) + 1
        bot_stats = {
            "name": bot_name,
            "tier": bot_tier,  # Already lowercase for rarity matching
            "health": 100 + (tier_multiplier * 50),
            "damage": 10 + (tier_multiplier * 5),
            "defense": 5 + (tier_multiplier * 3),
            "base_rewards": {
                "money": 1000 + (tier_multiplier * 500),
                "loot_chance": 0.3 + (tier_multiplier * 0.05)  # Higher tier = better loot chance
            }
        }
        
        # Calculate user combat stats
        user_combat_stats = calculate_combat_stats(user_id)
        
        # Simulate battle
        battle_result = resolve_cultivator_battle(user_combat_stats, bot_stats)
        
        # Determine rewards
        if battle_result["victory"]:
            money_gained = battle_result["money_gained"]
            
            # Add money using the proper function
            add_cash(user_id, money_gained)
            
            # Update user stats for display purposes
            user_stats["cash"] = user_stats.get("cash", 0) + money_gained
        
            embed = discord.Embed(
                title="⚔️ Battle Victory!",
                description=f"You defeated **{bot_name}**!",
                color=0x2ecc71
            )
            embed.add_field(name="💰 Reward", value=f"{MONEY_ICON} {money_gained:,}", inline=True)
            embed.add_field(name="🏆 Performance", value=f"Multiplier: {battle_result['performance_multiplier']:.2f}x", inline=True)
            
            # Generate battle loot (replacing XP rewards)
            loot_result = generate_cultivation_loot(user_id, ctx.guild)
            
            if loot_result:
                item_name, rarity, base_price = loot_result
                
                # Add to user's inventory using the proper function
                inventory_item = {
                    "name": item_name,
                    "rarity": rarity,
                    "type": "artifact",  # Battle loot items are artifacts
                    "description": f"A {rarity} quality {item_name} found during battle",
                    "value": base_price,
                    "added_by": user_id,
                    "added_at": int(time.time()),
                    "source": "battle"
                }
                
                # Use add_item_to_inventory to properly add the item
                add_item_to_inventory(user_id, inventory_item)
                
                # Add loot information to embed
                rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
                rarity_color = RARITY_COLOR.get(rarity, 0x2ecc71)
                
                embed.add_field(name="🎁 Battle Loot Found!", value=f"{rarity_emoji} **{item_name}** ({rarity.title()})\nSell Value: {MONEY_ICON} {base_price:,}", inline=False)
                embed.set_footer(text="Item added to your inventory • Battle cooldown: 5 minutes")
            else:
                embed.set_footer(text="Battle cooldown: 5 minutes")
        else:
            embed = discord.Embed(
                title="💀 Battle Defeat",
                description=f"You were defeated by **{bot_name}**!",
                color=0xe74c3c
            )
            embed.add_field(name="💡 Tip", value="Try upgrading your equipment or cultivating more XP!", inline=False)
            embed.set_footer(text="Battle cooldown: 5 minutes")

        # Update cooldown and save all changes at once (after preparing embed)
        user_stats["last_battle"] = current_time
        save_user_stats(user_id, user_stats)

        embed.add_field(name="⚔️ Battle Stats", value=f"**Your Health:** {battle_result['user_health_remaining']}/{user_combat_stats['total_health']}\n**Bot Health:** 0/{bot_stats['health']}", inline=False)
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Error in battle command: {e}")
        await send_embed(ctx, "Battle Error", f"An error occurred during the battle: {str(e)}", 0xe74c3c)


# -----------------------
# Equipment Management Commands
# -----------------------

@bot.hybrid_command(name="equipment", description="View equipped items and combat stats")
async def equipment(ctx, user: discord.Member = None):
    """View equipped items and combat statistics.
    Handles None placeholders and missing fields gracefully."""
    try:
        # Check if this is a slash command
        is_slash = hasattr(ctx, 'interaction') and ctx.interaction is not None
        
        if is_slash:
            try:
                await ctx.defer()
            except Exception as defer_error:
                print(f"Failed to defer equipment command: {defer_error}")
                is_slash = False
        
        target_user = user or ctx.author
        user_id = target_user.id
        equipment = get_user_equipment(user_id)
        combat_stats = calculate_combat_stats(user_id)
        
        embed = discord.Embed(
            title="⚔️ Equipment & Combat Stats",
            description=f"Combat statistics for {target_user.display_name}",
            color=0x3498db
        )
        
        # Weapon slot
        weapon = equipment.get("weapon")
        if isinstance(weapon, dict):
            rarity_emoji = RARITY_EMOJI.get(weapon.get("rarity", "common"), "⚪")
            
            weapon_value = f"Damage: **{weapon.get('damage', 'N/A')}**\n"
            weapon_value += f"Type: {weapon.get('weapon_type', 'Unknown').title()}\n"
            weapon_value += f"Description: {weapon.get('description', 'No description')}\n"
            weapon_value += f"Value: {MONEY_ICON} {weapon.get('value', 0):,}"
            
            # Add bonus effects if present
            if "critical_chance" in weapon:
                weapon_value += f"\n🎯 **Critical Chance:** +{weapon['critical_chance']}%"
            if "lifesteal" in weapon:
                weapon_value += f"\n💉 **Lifesteal:** +{weapon['lifesteal']}%"
            if "passive_income" in weapon:
                weapon_value += f"\n💰 **Daily Income:** +{MONEY_ICON} {weapon['passive_income']:,}"
            
            embed.add_field(
                name=f"⚔️ Weapon: {rarity_emoji} {weapon.get('name', 'Unknown')}",
                value=weapon_value,
                inline=False
            )
        else:
            embed.add_field(name="⚔️ Weapon", value="No weapon equipped", inline=True)
        
        # Armor slot
        armor = equipment.get("armor")
        if isinstance(armor, dict):
            rarity_emoji = RARITY_EMOJI.get(armor.get("rarity", "common"), "⚪")
            
            armor_value = f"Health: **{armor.get('health', 'N/A')}**\n"
            armor_value += f"Type: {armor.get('armor_type', 'Unknown').title()}\n"
            armor_value += f"Description: {armor.get('description', 'No description')}\n"
            armor_value += f"Value: {MONEY_ICON} {armor.get('value', 0):,}"
            
            # Add bonus effects if present
            if "damage_reduction" in armor:
                armor_value += f"\n🛡️ **Damage Reduction:** +{armor['damage_reduction']}%"
            if "health_boost" in armor:
                armor_value += f"\n❤️ **Health Boost:** +{armor['health_boost']}%"
            if "passive_income" in armor:
                armor_value += f"\n💰 **Daily Income:** +{MONEY_ICON} {armor['passive_income']:,}"
            
            embed.add_field(
                name=f"🛡️ Armor: {rarity_emoji} {armor.get('name', 'Unknown')}",
                value=armor_value,
                inline=False
            )
        else:
            embed.add_field(name="🛡️ Armor", value="No armor equipped", inline=True)
        
        # Artifacts
        artifacts = equipment.get("artifacts", [])
        valid_artifacts = [a for a in artifacts if isinstance(a, dict)]
        
        if valid_artifacts:
            artifacts_text = f"**Artifact Slots:** {len(valid_artifacts)}/3\n\n"
            for i, artifact in enumerate(valid_artifacts):
                rarity_emoji = RARITY_EMOJI.get(artifact.get("rarity", "common"), "⚪")
                artifacts_text += f"{rarity_emoji} **{artifact.get('name', 'Unknown')}**\n"
                artifacts_text += f"   {artifact.get('description', 'No description')}\n"
                artifacts_text += f"   💰 Value: {MONEY_ICON} {artifact.get('value', 0):,}\n\n"
            
            embed.add_field(name="✨ Artifacts", value=artifacts_text, inline=False)
        else:
            embed.add_field(name="✨ Artifacts", value="No artifacts equipped", inline=True)
        
        # Combat stats
        if combat_stats:
            stats_text = f"**Attack:** {combat_stats.get('attack', 0):,}\n"
            stats_text += f"**Defense:** {combat_stats.get('defense', 0):,}\n"
            stats_text += f"**HP:** {combat_stats.get('hp', 0):,}\n"
            stats_text += f"**Critical Chance:** {combat_stats.get('critical_chance', 0):.1f}%\n"
            stats_text += f"**Dodge:** {combat_stats.get('dodge', 0):.1f}%"
            
            embed.add_field(name="⚔️ Combat Stats", value=stats_text, inline=False)
        
        embed.set_footer(text="Use /inventory to view all your items • Use /equip to equip items • Use /unequip to unequip items • Maximum 3 artifacts")
        
        # Send response based on command type
        if is_slash and hasattr(ctx, 'followup'):
            await ctx.followup.send(embed=embed)
        else:
            await ctx.send(embed=embed)
            
    except Exception as e:
        print(f"Error in equipment command: {e}")
        import traceback
        traceback.print_exc()
        
        error_msg = f"❌ An error occurred while loading equipment: {str(e)}"
        
        try:
            if is_slash and hasattr(ctx, 'followup'):
                await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
            else:
                await send_embed(ctx, "Error", error_msg, color=0xe74c3c)
        except Exception as send_error:
            print(f"Failed to send error message: {send_error}")
            try:
                await ctx.send(error_msg)
            except Exception as final_error:
                print(f"Final fallback failed: {final_error}")
                if "immunity_chance" in armor:
                    armor_value += f"\n   ✨ **Immunity Chance:** +{armor['immunity_chance']}%"
                if "work_cooldown_reduction" in armor:
                    armor_value += f"\n   ⏰ **Work Cooldown:** -{armor['work_cooldown_reduction']}%"
                if "cultivation_boost" in armor:
                    armor_value += f"\n   🌱 **Cultivation:** +{armor['cultivation_boost']}%"
                if "roulette_boost" in armor:
                    armor_value += f"\n   🎰 **Roulette:** +{armor['roulette_boost']}%"
                if "gambling_loss_reduction" in armor:
                    armor_value += f"\n   🎲 **Loss Reduction:** +{armor['gambling_loss_reduction']}%"
                if "passive_income" in armor:
                    armor_value += f"\n   💰 **Daily Income:** +{MONEY_ICON} {armor['passive_income']:,}"
            else:
                # Show basic bonuses for non-legendary items
                if "damage_reduction" in armor:
                    armor_value += f"\n🛡️ **Damage Reduction:** +{armor['damage_reduction']}%"
                if "health_boost" in armor:
                    armor_value += f"\n❤️ **Health Boost:** +{armor['health_boost']}%"
                if "immunity_chance" in armor:
                    armor_value += f"\n✨ **Immunity Chance:** +{armor['immunity_chance']}%"
                if "passive_income" in armor:
                    armor_value += f"\n💰 **Daily Income:** +{armor['passive_income']:,}"
            
            embed.add_field(
                name=f"🛡️ Armor: {rarity_emoji} {armor.get('name', 'Unknown')}",
                value=armor_value,
                inline=False
            )
        else:
            embed.add_field(name="🛡️ Armor", value="No armor equipped", inline=True)
        
        # Artifacts (Limited to 3)
        valid_artifacts = [a for a in equipment.get("artifacts", []) if isinstance(a, dict)]
        if valid_artifacts:
            artifacts_text = f"**Artifact Slots:** {len(valid_artifacts)}/3\n\n"
            for i, artifact in enumerate(valid_artifacts):
                rarity_emoji = RARITY_EMOJI.get(artifact.get("rarity", "common"), "⚪")
                artifacts_text += f"{rarity_emoji} **{artifact.get('name', 'Unknown')}**\n"
                artifacts_text += f"   {artifact.get('description', 'No description')}\n"
                artifacts_text += f"   💰 Value: {MONEY_ICON} {artifact.get('value', 0):,}\n\n"
            
            embed.add_field(name="✨ Artifacts", value=artifacts_text, inline=False)
        else:
            embed.add_field(name="✨ Artifacts", value="No artifacts equipped", inline=True)
        
        # Combat stats
        if combat_stats:
            stats_text = f"**Attack:** {combat_stats.get('attack', 0):,}\n"
            stats_text += f"**Defense:** {combat_stats.get('defense', 0):,}\n"
            stats_text += f"**HP:** {combat_stats.get('hp', 0):,}\n"
            stats_text += f"**Critical Chance:** {combat_stats.get('critical_chance', 0):.1f}%\n"
            stats_text += f"**Dodge:** {combat_stats.get('dodge', 0):.1f}%"
            
            embed.add_field(name="⚔️ Combat Stats", value=stats_text, inline=False)
        
        embed.set_footer(text="Use /inventory to view all your items • Use /equip to equip items • Use /unequip to unequip items • Maximum 3 artifacts")
        
        # Send response based on command type
        if is_slash and hasattr(ctx, 'followup'):
            await ctx.followup.send(embed=embed)
        else:
            await ctx.send(embed=embed)
            
    except Exception as e:
        print(f"Error in equipment command: {e}")
        import traceback
        traceback.print_exc()
        
        error_msg = f"❌ An error occurred while loading equipment: {str(e)}"
        
        try:
            if is_slash and hasattr(ctx, 'followup'):
                await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
            else:
                await send_embed(ctx, "Error", error_msg, color=0xe74c3c)
        except Exception as send_error:
            print(f"Failed to send error message: {send_error}")
            try:
                await ctx.send(error_msg)
            except Exception as final_error:
                print(f"Final fallback failed: {final_error}")


async def equipment_autocomplete(interaction: discord.Interaction, current: str) -> list[app_commands.Choice[str]]:
    """Autocomplete for equipment items in inventory"""
    user_id = interaction.user.id
    meta = get_user_meta(user_id)
    inventory = meta.get("inventory", [])
    
    equipment_items = []
    for i, item in enumerate(inventory):
        if isinstance(item, dict) and item.get("type") in ["weapon", "armor", "artifact"]:
            rarity_emoji = RARITY_EMOJI.get(item.get("rarity", "common"), "⚪")
            display_name = f"{rarity_emoji} {item.get('name', 'Unknown')} ({item.get('type', 'unknown')})"
            equipment_items.append(app_commands.Choice(name=display_name, value=str(i + 1)))
    
    # Filter by current input
    if current:
        equipment_items = [item for item in equipment_items if current.lower() in item.name.lower()]
    
    return equipment_items[:25]  # Discord limit


@bot.hybrid_command(name="equip", description="Equip an item from your inventory by name")
@app_commands.autocomplete(item_name=inventory_item_autocomplete)
async def equip_item_cmd(ctx, *, item_name: str):
    """Equip an item from your inventory by name"""
    user_id = ctx.author.id
    
    # Get user's inventory
    meta = get_user_meta(user_id)
    inventory = meta.get("inventory", [])
    
    if not inventory:
        await send_embed(ctx, "Empty Inventory", "You don't have any items to equip.", 0xe67e22)
        return
    
    # Find item by name (case-insensitive)
    item = None
    for inv_item in inventory:
        if inv_item.get("name", "").lower() == item_name.lower():
            item = inv_item
            break
    
    if not item:
        await send_embed(ctx, "Item Not Found", f"Could not find '{item_name}' in your inventory.", 0xe74c3c)
        return
    
    # Check if item is equipment
    if item.get("type") not in ["weapon", "armor", "artifact"]:
        await send_embed(ctx, "Not Equipment", "This item cannot be equipped.", 0xe67e22)
        return
    
    # Try to equip the item
    success = equip_item(user_id, item)
    
    if success:
        # Remove from inventory
        inventory.remove(item)
        meta["inventory"] = inventory
        
        # Save the updated inventory while preserving existing data
        meta = get_user_meta(user_id)
        meta["inventory"] = inventory
        set_user_meta(user_id, meta)
        
        rarity_emoji = RARITY_EMOJI.get(item.get("rarity", "common"), "⚪")
        embed = discord.Embed(
            title="✅ Item Equipped!",
            description=f"Successfully equipped {rarity_emoji} **{item['name']}**",
            color=0x2ecc71
        )
        
        if item["type"] == "weapon":
            damage = item.get("damage", 0)
            embed.add_field(name="⚔️ Weapon Stats", value=f"Damage: **{damage}**", inline=True)
            if damage >= 50:
                embed.add_field(name="🌟 Power Level", value="Legendary Power", inline=True)
            elif damage >= 30:
                embed.add_field(name="✨ Power Level", value="Exceptional Power", inline=True)
            elif damage >= 15:
                embed.add_field(name="⚡ Power Level", value="Good Power", inline=True)
            else:
                embed.add_field(name="🔨 Power Level", value="Basic Power", inline=True)
            
            # Show economic bonuses if present
            if item.get("rarity") in ["legendary", "mythic", "divine"]:
                economic_effects = []
                if "work_income_boost" in item:
                    economic_effects.append(f"Work Income +{item['work_income_boost']}%")
                if "blackjack_boost" in item:
                    economic_effects.append(f"Blackjack +{item['blackjack_boost']}%")
                if "shop_discount" in item:
                    economic_effects.append(f"Shop Discount -{item['shop_discount']}%")
                if "sell_bonus" in item:
                    economic_effects.append(f"Sell Bonus +{item['sell_bonus']}%")
                
                if economic_effects:
                    embed.add_field(name="💰 Economic Bonuses", value="\n".join(economic_effects), inline=False)
        elif item["type"] == "armor":
            health = item.get("health", 0)
            embed.add_field(name="🛡️ Armor Stats", value=f"Health: **{health}**", inline=True)
            if health >= 200:
                embed.add_field(name="🌟 Protection", value="Legendary Protection", inline=True)
            elif health >= 120:
                embed.add_field(name="✨ Protection", value="Exceptional Protection", inline=True)
            elif health >= 60:
                embed.add_field(name="⚡ Protection", value="Good Protection", inline=True)
            else:
                embed.add_field(name="🛡️ Protection", value="Basic Protection", inline=True)
            
            # Show economic bonuses if present
            if item.get("rarity") in ["legendary", "mythic", "divine"]:
                economic_effects = []
                if "work_cooldown_reduction" in item:
                    economic_effects.append(f"Work Cooldown -{item['work_cooldown_reduction']}%")
                if "cultivation_boost" in item:
                    economic_effects.append(f"Cultivation +{item['cultivation_boost']}%")
                if "roulette_boost" in item:
                    economic_effects.append(f"Roulette +{item['roulette_boost']}%")
                if "gambling_loss_reduction" in item:
                    economic_effects.append(f"Loss Reduction +{item['gambling_loss_reduction']}%")
                
                if economic_effects:
                    embed.add_field(name="💰 Economic Bonuses", value="\n".join(economic_effects), inline=False)
        elif item["type"] == "artifact":
            abilities = item.get("abilities", [])
            embed.add_field(name="✨ Abilities", value=", ".join(abilities), inline=True)
            embed.add_field(name="🎯 Effects", value="Economic & Combat Enhancement", inline=True)
            
            # Show economic bonuses if present
            if item.get("rarity") in ["legendary", "mythic", "divine"]:
                economic_effects = []
                if "work_income_boost" in item:
                    economic_effects.append(f"Work Income +{item['work_income_boost']}%")
                if "blackjack_boost" in item:
                    economic_effects.append(f"Blackjack +{item['blackjack_boost']}%")
                if "shop_discount" in item:
                    economic_effects.append(f"Shop Discount -{item['shop_discount']}%")
                if "sell_bonus" in item:
                    economic_effects.append(f"Sell Bonus +{item['sell_bonus']}%")
                if "roulette_boost" in item:
                    economic_effects.append(f"Roulette +{item['roulette_boost']}%")
                
                if economic_effects:
                    embed.add_field(name="💰 Economic Bonuses", value="\n".join(economic_effects), inline=False)
        
        embed.set_footer(text="Use /equipment to view your current equipment")
        await ctx.send(embed=embed)
    else:
        if item["type"] == "artifact":
            await send_embed(ctx, "Artifact Limit Reached", "You can only equip up to 3 artifacts. Unequip one first.", 0xe74c3c)
        else:
            await send_embed(ctx, "Equip Failed", "Failed to equip this item.", 0xe74c3c)


@bot.hybrid_command(name="unequip", description="Unequip an item from your equipment")
async def unequip_item_cmd(ctx, item_type: str, artifact_index: int = None):
    """Unequip an item from your equipment by type
    
    For artifacts, you can specify an index (1, 2, or 3) to unequip a specific one.
    Example: /unequip artifact 2
    """
    user_id = ctx.author.id
    
    if item_type not in ["weapon", "armor", "artifact"]:
        await send_embed(ctx, "Invalid Type", "Please specify: weapon, armor, or artifact", 0xe74c3c)
        return
    
    # For artifacts, require an index
    if item_type == "artifact" and artifact_index is None:
        await send_embed(ctx, "Artifact Index Required", "For artifacts, please specify an index (1, 2, or 3). Example: /unequip artifact 2", 0xe74c3c)
        return
    
    # Convert 1-based index to 0-based for artifacts
    if item_type == "artifact" and artifact_index is not None:
        artifact_index = artifact_index - 1
        if artifact_index < 0 or artifact_index > 2:
            await send_embed(ctx, "Invalid Index", "Artifact index must be 1, 2, or 3", 0xe74c3c)
            return
    
    # Check if user has any equipment to unequip
    equipment = get_user_equipment(user_id)
    if not equipment:
        await send_embed(ctx, "No Equipment", "You don't have any equipment to unequip.", 0xe67e22)
        return
    
    # Validate that the specific item type exists
    if item_type == "weapon" and not equipment.get("weapon"):
        await send_embed(ctx, "No Weapon", "You don't have a weapon equipped.", 0xe67e22)
        return
    elif item_type == "armor" and not equipment.get("armor"):
        await send_embed(ctx, "No Armor", "You don't have armor equipped.", 0xe67e22)
        return
    elif item_type == "artifact":
        if not equipment.get("artifacts") or not equipment["artifacts"][artifact_index]:
            await send_embed(ctx, "No Artifact", f"You don't have an artifact equipped at position {artifact_index + 1}.", 0xe67e22)
            return
    
    # Unequip the item
    item = unequip_item(user_id, item_type, artifact_index)
    
    if not item:
        # Provide more specific error messages
        if item_type == "artifact":
            await send_embed(ctx, "Unequip Failed", f"No artifact found at position {artifact_index + 1}. Check your equipment with `/equipment`.", 0xe74c3c)
        else:
            await send_embed(ctx, "Unequip Failed", f"No {item_type} found to unequip. Check your equipment with `/equipment`.", 0xe74c3c)
        return
    
    # Add back to inventory
    meta = get_user_meta(user_id)
    inventory = meta.get("inventory", [])
    inventory.append(item)
    meta["inventory"] = inventory
    set_user_meta(user_id, meta)
    
    rarity_emoji = RARITY_EMOJI.get(item.get("rarity", "common"), "⚪")
    embed = discord.Embed(
        title="✅ Item Unequipped!",
        description=f"Successfully unequipped {rarity_emoji} **{item['name']}**",
        color=0x2ecc71
    )
    
    # Add item stats info
    if item.get("type") == "weapon":
        damage = item.get("damage", 0)
        embed.add_field(name="⚔️ Weapon Stats", value=f"Damage: **{damage}**", inline=True)
    elif item.get("type") == "armor":
        health = item.get("health", 0)
        embed.add_field(name="🛡️ Armor Stats", value=f"Health: **{health}**", inline=True)
    elif item.get("type") == "artifact":
        abilities = item.get("abilities", [])
        embed.add_field(name="✨ Abilities", value=", ".join(abilities), inline=True)
    
    embed.set_footer(text="Item has been returned to your inventory")
    await ctx.send(embed=embed)


# -----------------------
# Equipment Reset Command
# -----------------------

@bot.command(name="equipment_reset")
@commands.has_permissions(administrator=True)
async def equipment_reset(ctx, user: discord.Member):
    """Reset all equipped items for a user (Admin only)"""
    user_id = user.id
    
    # Get current equipment
    equipment = get_user_equipment(user_id)
    
    # Check if user has any equipment
    has_equipment = any([
        equipment.get("weapon"),
        equipment.get("armor"),
        equipment.get("artifacts")
    ])
    
    if not has_equipment:
        await send_embed(ctx, "No Equipment", f"{user.display_name} has no equipment to reset.", 0xe67e22)
        return
    
    # Get user meta to add items back to inventory
    meta = get_user_meta(user_id)
    inventory = meta.get("inventory", [])
    
    # Collect all equipped items
    reset_items = []
    
    # Reset weapon
    if equipment.get("weapon"):
        reset_items.append(equipment["weapon"])
        equipment["weapon"] = None
    
    # Reset armor
    if equipment.get("armor"):
        reset_items.append(equipment["armor"])
        equipment["armor"] = None
    
    # Reset artifacts
    if equipment.get("artifacts"):
        for artifact in equipment["artifacts"]:
            if artifact:
                reset_items.append(artifact)
        equipment["artifacts"] = [None, None, None]
    
    # Save reset equipment
    meta["equipment"] = equipment
    set_user_meta(user_id, meta)
    
    # Add items back to inventory
    for item in reset_items:
        inventory.append(item)
    
    # Save updated inventory
    meta["inventory"] = inventory
    set_user_meta(user_id, meta)
    
    # Create response embed
    embed = discord.Embed(title="🔄 Equipment Reset Complete!", color=0x2ecc71)
    embed.description = f"Successfully reset all equipment for {user.mention}"
    
    if reset_items:
        embed.add_field(
            name="📦 Items Returned to Inventory", 
            value=f"**{len(reset_items)}** items have been returned to {user.display_name}'s inventory",
            inline=False
        )
        
        # List the items that were reset
        item_list = []
        for item in reset_items:
            rarity_emoji = RARITY_EMOJI.get(item.get("rarity", "common"), "⚪")
            item_type = item.get("type", "unknown").title()
            item_list.append(f"{rarity_emoji} **{item['name']}** ({item_type})")
        
        embed.add_field(
            name="🔧 Reset Items",
            value="\n".join(item_list),
            inline=False
        )
    
    embed.add_field(name="👤 Target User", value=user.mention, inline=True)
    embed.add_field(name="👑 Admin", value=ctx.author.mention, inline=True)
    embed.set_footer(text=f"Use ?equipment to view {user.display_name}'s equipment status")
    
    await ctx.send(embed=embed)


@bot.command(name="clear_equipment")
@commands.has_permissions(administrator=True)
async def clear_equipment(ctx, user: discord.Member):
    """Clear all equipped items for a user (Admin only) - Items are NOT returned to inventory"""
    user_id = user.id
    
    # Get current equipment
    equipment = get_user_equipment(user_id)
    
    # Check if user has any equipment
    has_equipment = any([
        equipment.get("weapon"),
        equipment.get("armor"),
        equipment.get("artifacts")
    ])
    
    if not has_equipment:
        await send_embed(ctx, "No Equipment", f"{user.display_name} has no equipment to clear.", 0xe67e22)
        return
    
    # Get user meta to clear equipment
    meta = get_user_meta(user_id)
    
    # Collect all equipped items for display
    cleared_items = []
    
    # Clear weapon
    if equipment.get("weapon"):
        cleared_items.append(equipment["weapon"])
        equipment["weapon"] = None
    
    # Clear armor
    if equipment.get("armor"):
        cleared_items.append(equipment["armor"])
        equipment["armor"] = None
    
    # Clear artifacts
    if equipment.get("artifacts"):
        for artifact in equipment["artifacts"]:
            if artifact:
                cleared_items.append(artifact)
        equipment["artifacts"] = [None, None, None]
    
    # Save cleared equipment
    meta["equipment"] = equipment
    set_user_meta(user_id, meta)
    
    # Create response embed
    embed = discord.Embed(title="🗑️ Equipment Cleared!", color=0xe74c3c)
    embed.description = f"Successfully cleared all equipment for {user.mention}"
    
    if cleared_items:
        embed.add_field(
            name="⚠️ Items Removed", 
            value=f"**{len(cleared_items)}** items have been permanently removed from {user.display_name}'s equipment",
            inline=False
        )
        
        # List the items that were cleared
        item_list = []
        for item in cleared_items:
            rarity_emoji = RARITY_EMOJI.get(item.get("rarity", "common"), "⚪")
            item_type = item.get("type", "unknown").title()
            item_list.append(f"{rarity_emoji} **{item['name']}** ({item_type})")
        
        embed.add_field(
            name="🔧 Cleared Items",
            value="\n".join(item_list),
            inline=False
        )
    
    embed.add_field(name="👤 Target User", value=user.mention, inline=True)
    embed.add_field(name="👑 Admin", value=ctx.author.mention, inline=True)
    embed.set_footer(text=f"⚠️ Items were permanently removed, not returned to inventory")
    
    await ctx.send(embed=embed)


@bot.command(name="health_sync")
@commands.has_permissions(administrator=True)
async def health_sync(ctx):
    """Sync all users' health values to fix HP calculation issues from updates (Admin only)"""
    
    # Get all users from economy data
    data = load_json(DATA_FILE)
    users = list(data.keys())
    
    if not users:
        await send_embed(ctx, "No Users", "No users found to sync.", 0xe67e22)
        return
    
    synced_count = 0
    errors = []
    
    embed = discord.Embed(title="🔄 Health Sync Progress", color=0x3498db)
    embed.description = f"Syncing health values for **{len(users)}** users..."
    
    progress_msg = await ctx.send(embed=embed)
    
    for i, user_id in enumerate(users):
        try:
            # Get user meta and equipment
            user_meta = get_user_meta(user_id)
            equipment = get_user_equipment(user_id)
            
            # Calculate correct base HP from level and attributes
            # We need to simulate the level-based HP calculation
            base_hp = 100  # Default base HP for level 0
            
            # Get user attributes
            attributes, _ = get_user_attributes(user_id)
            longevity_bonus = attributes.get("longevity", 0) * 1  # +1 HP per longevity point
            
            # Calculate correct total HP
            correct_hp = base_hp + longevity_bonus
            
            # Add equipment bonuses
            if equipment.get("armor") and isinstance(equipment["armor"], dict):
                correct_hp += equipment["armor"].get("health", 0)
            
            if equipment.get("artifacts"):
                for artifact in equipment["artifacts"]:
                    if artifact and isinstance(artifact, dict):
                        correct_hp += artifact.get("health", 0)
            
            # Update user meta with correct HP calculation
            user_meta["corrected_hp"] = correct_hp
            set_user_meta(user_id, user_meta)
            
            synced_count += 1
            
            # Update progress every 10 users
            if i % 10 == 0:
                embed.description = f"Syncing health values... **{i}/{len(users)}** users processed"
                embed.add_field(name="Progress", value=f"✅ **{synced_count}** users synced\n❌ **{len(errors)}** errors", inline=False)
                await progress_msg.edit(embed=embed)
                
        except Exception as e:
            errors.append(f"User {user_id}: {str(e)}")
            print(f"Error syncing health for user {user_id}: {e}")
    
    # Final results
    embed = discord.Embed(title="✅ Health Sync Complete!", color=0x2ecc71)
    embed.description = f"Successfully synced health values for **{synced_count}** users"
    
    if errors:
        embed.add_field(name="❌ Errors", value=f"**{len(errors)}** users had errors during sync", inline=False)
        # Show first few errors
        error_display = "\n".join(errors[:5])
        if len(errors) > 5:
            error_display += f"\n... and {len(errors) - 5} more errors"
        embed.add_field(name="Error Details", value=error_display, inline=False)
    
    embed.add_field(name="📊 Results", value=f"✅ **Successfully synced:** {synced_count}\n❌ **Errors:** {len(errors)}\n👑 **Admin:** {ctx.author.mention}", inline=False)
    embed.set_footer(text="Health values have been corrected for all users")
    
    await progress_msg.edit(embed=embed)


# -----------------------
# Inventory Management Commands
# -----------------------

@bot.command(name="inv_add")
@commands.has_permissions(administrator=True)
async def inv_add_cmd(ctx, user: discord.Member, item_name: str, item_type: str, rarity: str = "common"):
    """Add an item to a user's inventory (Admin only)"""
    user_id = user.id
    
    # Validate item type
    if item_type.lower() not in ["weapon", "armor", "artifact", "material"]:
        await send_embed(ctx, "Invalid Item Type", "Available types: weapon, armor, artifact, material", 0xe74c3c)
        return
    
    # Validate rarity for equipment
    valid_rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]
    if item_type.lower() != "material" and rarity.lower() not in valid_rarities:
        available_rarities = ", ".join(valid_rarities)
        await send_embed(ctx, "Invalid Rarity", f"Available rarities: {available_rarities}", 0xe74c3c)
        return
    
    # Generate or create the item
    if item_type.lower() == "material":
        item = item_name
    elif item_type.lower() == "weapon":
        if item_name.lower() not in WEAPON_TYPES:
            available_types = ", ".join(WEAPON_TYPES.keys())
            await send_embed(ctx, "Invalid Weapon Type", f"Available types: {available_types}", 0xe74c3c)
            return
        item = generate_weapon(item_name.lower(), rarity.lower())
    elif item_type.lower() == "armor":
        if item_name.lower() not in ARMOR_TYPES:
            available_types = ", ".join(ARMOR_TYPES.keys())
            await send_embed(ctx, "Invalid Armor Type", f"Available types: {available_types}", 0xe74c3c)
            return
        item = generate_armor(item_name.lower(), rarity.lower())
    else:  # artifact
        if item_name.lower() not in ARTIFACT_TYPES:
            available_types = ", ".join(ARTIFACT_TYPES.keys())
            await send_embed(ctx, "Invalid Artifact Type", f"Available types: {available_types}", 0xe74c3c)
            return
        item = generate_artifact(item_name.lower(), rarity.lower())
    
    # Add to user's inventory
    meta = get_user_meta(user_id)
    inventory = meta.get("inventory", [])
    inventory.append(item)
    meta["inventory"] = inventory
    set_user_meta(user_id, meta)
    
    # Create success embed
    if item_type.lower() == "material":
        embed = discord.Embed(
            title="✅ Material Added!",
            description=f"Successfully added **{item_name}** to {user.mention}'s inventory",
            color=0x2ecc71
        )
        embed.add_field(name="📦 Item", value=item_name, inline=True)
        embed.add_field(name="📊 Type", value="Material", inline=True)
    else:
        rarity_emoji = RARITY_EMOJI.get(rarity.lower(), "⚪")
        embed = discord.Embed(
            title="✅ Equipment Added!",
            description=f"Successfully added {rarity_emoji} **{item['name']}** to {user.mention}'s inventory",
            color=0x2ecc71
        )
        
        if item_type.lower() == "weapon":
            embed.add_field(name="⚔️ Weapon Stats", value=f"Damage: {item['damage']}", inline=True)
        elif item_type.lower() == "armor":
            embed.add_field(name="🛡️ Armor Stats", value=f"Health: {item['health']}", inline=True)
        elif item_type.lower() == "artifact":
            embed.add_field(name="✨ Abilities", value=", ".join(item["abilities"]), inline=True)
        
        embed.add_field(name="💰 Value", value=f"{MONEY_ICON} {item['value']:,}", inline=True)
        embed.add_field(name="📊 Type", value=item_type.title(), inline=True)
    
    embed.add_field(name="👤 User", value=user.mention, inline=True)
    embed.add_field(name="👑 Admin", value=ctx.author.mention, inline=True)
    
    embed.set_footer(text=f"Item added to {user.display_name}'s inventory")
    await ctx.send(embed=embed)

# Autocomplete functions for crafting commands


async def rarity_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for rarity levels"""
    rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]
    return [app_commands.Choice(name=rarity.title(), value=rarity) for rarity in rarities if current.lower() in rarity.lower()]

async def craft_type_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for craft types"""
    craft_types = ["weapon", "armor", "artifact"]
    return [app_commands.Choice(name=craft_type.title(), value=craft_type) for craft_type in craft_types if current.lower() in craft_type.lower()]

async def weapon_type_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for weapon types"""
    choices = list(WEAPON_TYPES.keys())
    return [app_commands.Choice(name=choice.title(), value=choice) for choice in choices if current.lower() in choice.lower()]

async def armor_type_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for armor types"""
    choices = list(ARMOR_TYPES.keys())
    return [app_commands.Choice(name=choice.title(), value=choice) for choice in choices if current.lower() in choice.lower()]

async def artifact_type_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for artifact types"""
    choices = list(ARTIFACT_TYPES.keys())
    return [app_commands.Choice(name=choice.title(), value=choice) for choice in choices if current.lower() in choice.lower()]

class InventoryPaginator(discord.ui.View):
    """Simple paginator for inventory items with ◀️ ▶️ buttons (10 items per page)."""
    def __init__(self, items: list[dict], target_user: discord.Member, filter_type: str | None, author_id: int):
        super().__init__(timeout=120)
        self.items = items
        self.target_user = target_user
        self.filter_type = filter_type
        self.author_id = author_id
        self.page = 0
        self.items_per_page = 10
        self.total_pages = max(1, (len(self.items) + self.items_per_page - 1) // self.items_per_page)

    def _summarize_item(self, item: dict) -> str:
        item_type = item.get("type", "item")
        amount = item.get("amount", 1)
        
        if item_type == "weapon":
            dmg = item.get("damage", 0)
            summary = f"⚔️ Weapon • DMG {dmg}"
        elif item_type == "armor":
            hp = item.get("health", 0)
            hp = item.get("health", 0)
            defense = item.get("defense", 0)
            summary = f"🛡️ Armor • HP {hp} • DEF {defense}"
        elif item_type == "artifact":
            abilities = ", ".join(item.get("abilities", [])[:3]) or "None"
            summary = f"✨ Artifact • {abilities}"
        elif item_type == "ore":
            summary = f"⛏️ Ore"
        else:
            summary = "📦 Item"
        
        # Show amount for stacked items
        if amount > 1:
            summary += f" • **x{amount}**"
        
        # Show item effects for legendary+ items
        if item.get("rarity") in ["legendary", "mythic", "divine"]:
            effects = []
            if item.get("damage_boost"):
                effects.append(f"DMG +{item['damage_boost']}%")
            if item.get("defense_boost"):
                effects.append(f"DEF +{item['defense_boost']}%")
            if item.get("health_boost"):
                effects.append(f"HP +{item['health_boost']}%")
            if item.get("roulette_boost"):
                effects.append(f"Roulette +{item['roulette_boost']}%")
            if item.get("xp_boost"):
                effects.append(f"XP +{item['xp_boost']}%")
            if item.get("blackjack_boost"):
                effects.append(f"Blackjack +{item['blackjack_boost']}%")
            if item.get("luck_boost"):
                effects.append(f"Luck +{item['luck_boost']}%")
            if item.get("cultivation_boost"):
                effects.append(f"Cultivation +{item['cultivation_boost']}%")
            if item.get("shop_discount"):
                effects.append(f"Shop -{item['shop_discount']}%")
            
            if effects:
                summary += f"\n**Effects:** {', '.join(effects)}"
        
        if "value" in item:
            # Show the base price (what the item is worth)
            base_value = item['value']
            rarity = item.get("rarity", "common").lower()
            item_type = item.get("type", "item")
            
            # Calculate sell price using new direct pricing system
            if item_type == "weapon":
                weapon_sell_prices = {
                    "common": 1200, "uncommon": 5600, "rare": 60000, "epic": 240000,
                    "legendary": 2000000, "mythic": 35000000, "divine": 400000000, "primordial": 1000000000
                }
                sell_price = weapon_sell_prices.get(rarity, 1200)
            elif item_type == "armor":
                armor_sell_prices = {
                    "common": 1300, "uncommon": 5800, "rare": 70000, "epic": 320000,
                    "legendary": 3000000, "mythic": 45000000, "divine": 400000000, "primordial": 1000000000
                }
                sell_price = armor_sell_prices.get(rarity, 1300)
            elif item_type == "artifact":
                artifact_sell_prices = {
                    "common": 1500, "uncommon": 6000, "rare": 80000, "epic": 360000,
                    "legendary": 4000000, "mythic": 55000000, "divine": 400000000, "primordial": 1000000000
                }
                sell_price = artifact_sell_prices.get(rarity, 1500)
            elif item_type == "ore":
                ore_sell_prices = {
                    "common": 450, "uncommon": 1300, "rare": 30000, "epic": 120000,
                    "legendary": 600000, "mythic": 10000000, "divine": 100000000, "primordial": 1000000000
                }
                sell_price = ore_sell_prices.get(rarity, 450)
            else:
                loot_sell_prices = {
                    "common": 300, "uncommon": 1000, "rare": 20000, "epic": 70000,
                    "legendary": 400000, "mythic": 4000000, "divine": 70000000, "primordial": 1000000000
                }
                sell_price = loot_sell_prices.get(rarity, 300)
            
            # Show both base price and sell price
            summary += f" • Base: {MONEY_ICON} {base_value:,} | Sell: {MONEY_ICON} {sell_price:,}"
        return summary

    def _build_embed(self) -> discord.Embed:
        start = self.page * self.items_per_page
        end = min(start + self.items_per_page, len(self.items))
        visible_items = self.items[start:end]

        title_prefix = f"{self.filter_type.title()} " if self.filter_type else ""
        
        # Calculate total items including stacked amounts
        total_items = sum(item.get("amount", 1) for item in self.items)
        unique_items = len(self.items)
        
        embed = discord.Embed(
            title=f"📦 {title_prefix}Inventory - {self.target_user.display_name}",
            description=f"Total items: {total_items:,} • Unique items: {unique_items} • Page {self.page + 1}/{self.total_pages}",
            color=0x3498db
        )
        embed.set_thumbnail(url=self.target_user.display_avatar.url)

        for idx, item in enumerate(visible_items, start=start + 1):
            rarity = item.get("rarity", "common")
            rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
            name = item.get("name", "Unknown")
            amount = item.get("amount", 1)
            
            # Show amount in name for stacked items
            display_name = f"{name} (x{amount})" if amount > 1 else name
            
            embed.add_field(
                name=f"{idx}. {rarity_emoji} {display_name}",
                value=self._summarize_item(item),
                inline=False
            )

        embed.set_footer(text="Use ◀️ ▶️ to switch pages • Use /equip <item_name> to equip items")
        # Update button disabled state
        self.prev_button.disabled = self.page == 0
        self.next_button.disabled = self.page >= self.total_pages - 1
        return embed

    async def _ensure_owner(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id == self.author_id or interaction.user.guild_permissions.administrator:
            return True
        await interaction.response.send_message("This paginator isn't yours.", ephemeral=True)
        return False

    @discord.ui.button(label="◀️", style=discord.ButtonStyle.secondary)
    async def prev_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self._ensure_owner(interaction):
            return
        if self.page > 0:
            self.page -= 1
        await interaction.response.edit_message(embed=self._build_embed(), view=self)

    @discord.ui.button(label="▶️", style=discord.ButtonStyle.secondary)
    async def next_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self._ensure_owner(interaction):
            return
        if self.page < self.total_pages - 1:
            self.page += 1
        await interaction.response.edit_message(embed=self._build_embed(), view=self)


@bot.hybrid_command(name="inventory", description="View your inventory or another user's inventory organized by rarity and type")
@app_commands.autocomplete(filter_type=inventory_filter_autocomplete)
async def inventory_cmd(ctx, filter_type: str = None, user: discord.Member = None):
    """View your inventory or another user's inventory organized by rarity and type with detailed descriptions"""
    try:

        # Determine which user's inventory to show
        if user:
            user_id = user.id
            target_user = user
            # Check if user has permission to view other users' inventories
            if not ctx.author.guild_permissions.administrator and ctx.author.id != user.id:
                await send_embed(ctx, "Access Denied", "You can only view your own inventory unless you're an administrator.", 0xe74c3c)
                return
        else:
            user_id = ctx.author.id
            target_user = ctx.author
        
        meta = get_user_meta(user_id)
        
        try:
            # Clean up old inventory items first
            clean_user_inventory(user_id)
            
            # Fix any items with 0 or missing values
            fix_inventory_item_values(user_id)
        except Exception as e:
            print(f"Warning: Could not clean/fix inventory for user {user_id}: {e}")
            # Continue without cleanup
        
        # Get cleaned inventory
        meta = get_user_meta(user_id)  # Reload after cleanup
        inventory = meta.get("inventory", [])
        
        # Calculate total items including stacked amounts
        total_items = sum(item.get("amount", 1) for item in inventory if isinstance(item, dict))
        print(f"Inventory command - User: {user_id}, Meta keys: {list(meta.keys())}, Inventory: {len(inventory)} unique items, {total_items} total items")
    
        if not inventory:
            await send_embed(ctx, "Empty Inventory", "Your inventory is empty.", 0xe67e22)
            return
    except Exception as e:
        print(f"Inventory command error: {e}")
        await send_embed(ctx, "Inventory Error", f"An error occurred while loading inventory: {str(e)}", 0xe74c3c)
        return
    
    # Filter inventory if requested and clean up old string items
    filtered_inventory = []
    for item in inventory:
        # Skip old string items and ensure item is a dictionary
        if isinstance(item, str):
            print(f"Skipping old string item: {item}")
            continue
        if not isinstance(item, dict):
            print(f"Skipping invalid item type: {type(item)}")
            continue
        if "name" not in item or "type" not in item:
            print(f"Skipping item missing required fields: {item}")
            continue
            
        # Add valid items to filtered inventory
        filtered_inventory.append(item)
    
    if filter_type and filter_type.lower() in ["weapon", "armor", "artifact"]:
        filtered_inventory = [item for item in filtered_inventory if item.get("type") == filter_type.lower()]
        title = f"📦 {filter_type.title()} Inventory - {target_user.display_name}"
        if not filtered_inventory:
            await send_embed(ctx, title, f"{target_user.display_name} doesn't have any {filter_type}s in their inventory.", 0xe67e22)
            return
    else:
        title = f"📦 Inventory - {target_user.display_name}"
    
    if not filtered_inventory:
        await send_embed(ctx, "Empty Inventory", f"{target_user.display_name}'s inventory is empty or contains only invalid items.", 0xe67e22)
        return
    
    # Build ordered list by rarity desc, then type, then name
    rarity_order = {"divine": 6, "mythic": 5, "legendary": 4, "epic": 3, "rare": 2, "uncommon": 1, "common": 0}
    type_order = {"weapon": 0, "armor": 1, "artifact": 2, "ore": 3, "case": 4}
    ordered_items = sorted(
        filtered_inventory,
        key=lambda it: (
            -rarity_order.get(it.get("rarity", "common"), 0),
            type_order.get(it.get("type", "other"), 9),
            str(it.get("name", "")).lower()
        )
    )

    view = InventoryPaginator(ordered_items, target_user, filter_type, ctx.author.id)
    embed = view._build_embed()
    await ctx.send(embed=embed, view=view)


# -----------------------
# Shortened Inventory Command
# -----------------------

@bot.command(name="inv", aliases=["i"])
async def inv_short(ctx, filter_type: str = None, user: discord.Member = None):
    """Shortened inventory command - same as ?inventory"""
    await inventory_cmd(ctx, filter_type, user)


# -----------------------
# Clear Inventory Command
# -----------------------

@bot.command(name="fix_inventory_values")
@commands.has_permissions(administrator=True)
async def fix_inventory_values_cmd(ctx, user: discord.Member = None):
    """Fix inventory item values - Admin only. Fixes items with 0 or missing values."""
    
    # Check if user is admin
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command requires administrator permissions.", 0xe74c3c)
        return
    
    # Determine which user's inventory to fix
    if user:
        user_id = user.id
        target_user = user
    else:
        user_id = ctx.author.id
        target_user = ctx.author
    
    # Fix the inventory
    fix_inventory_item_values(user_id)
    
    await send_embed(ctx, "Inventory Values Fixed", f"Fixed inventory item values for {target_user.display_name}.", 0x2ecc71)

@bot.command(name="clear_inventory")
@commands.has_permissions(administrator=True)
async def clear_inventory_cmd(ctx, user: discord.Member = None):
    """Clear inventory - Admin only. Leave user empty to clear your own inventory."""
    
    # Check if user is admin
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        # If no user specified, clear own inventory
        if user is None:
            user = ctx.author
        
        user_id = user.id
        meta = get_user_meta(user_id)
        
        # Clear inventory
        meta["inventory"] = []
        set_user_meta(user_id, meta)
        
        embed = discord.Embed(title="🗑️ Inventory Cleared!", color=0x2ecc71)
        embed.description = f"{user.mention}'s inventory has been completely cleared!"
        embed.add_field(name="Status", value="All items removed", inline=True)
        embed.add_field(name="Target User", value=user.mention, inline=True)
        embed.add_field(name="Admin", value=ctx.author.mention, inline=True)
        embed.set_footer(text="Use /inventory to confirm the inventory is empty")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Clear Inventory Error", f"Error clearing inventory: {str(e)}", 0xe74c3c)


# -----------------------
# Add/Remove Inventory Commands
# -----------------------

# Autocomplete functions for add_inventory command
async def section_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for inventory sections"""
    sections = ["weapons", "loot", "ore", "custom"]
    return [app_commands.Choice(name=section.title(), value=section) for section in sections if current.lower() in section.lower()]

async def admin_rarity_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for admin rarities including primordial rarity"""
    rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine", "primordial"]
    return [app_commands.Choice(name=rarity.title(), value=rarity) for rarity in rarities if current.lower() in rarity.lower()]

async def item_type_autocomplete(interaction: discord.Interaction, current: str):
    """Autocomplete for item types"""
    types = ["weapon", "armor", "artifact", "consumable", "material", "ore", "spirit_beast"]
    return [app_commands.Choice(name=type_name.title(), value=type_name) for type_name in types if current.lower() in type_name.lower()]

@bot.hybrid_command(name="add_inventory", description="Add items to user inventory (Admin only)")
@app_commands.describe(
    section="Section to add items to (weapons, loot, ore, custom)",
    user="The user to add items to",
    item_name="Name of the item to add",
    rarity="Rarity of the item (common, uncommon, rare, epic, legendary, mythic, divine, primordial)",
    item_type="Type for custom items (weapon, armor, artifact, consumable, material, ore, spirit_beast)",
    win_rate="Win rate for spirit beasts (1-100, only for spirit_beast type)"
)
@app_commands.autocomplete(section=section_autocomplete, rarity=admin_rarity_autocomplete, item_type=item_type_autocomplete)
@app_commands.checks.has_permissions(administrator=True)
async def add_inventory(ctx, section: str, user: discord.Member, item_name: str, rarity: str, item_type: str = None, win_rate: int = None):
    """Add an item to a user's inventory - Admin only
    
    Usage:
    /add_inventory weapons <user> <weapon_name> <rarity>
    /add_inventory loot <user> <item_name> <rarity>
    /add_inventory ore <user> <ore_name> <rarity>
    /add_inventory custom <user> <item_name> <rarity> <type>
    """
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    # If no arguments, show the menu
    if section is None:
        embed = discord.Embed(title="📦 Inventory Add Menu", description="Choose a section to add items:", color=0x2ecc71)
        
        embed.add_field(name="⚔️ Weapons", value="`/add_inventory weapons <user> <weapon_name> <rarity>`\n"
                      "**Examples:**\n"
                      "• `/add_inventory weapons @user Iron Sword common`\n"
                      "• `/add_inventory weapons @user Mythril Axe legendary`\n"
                      "• `/add_inventory weapons @user Divine Blade divine`", inline=False)
        
        embed.add_field(name="💎 Loot Items", value="`/add_inventory loot <user> <item_name> <rarity>`\n"
                      "**Examples:**\n"
                      "• `/add_inventory loot @user Health Potion common`\n"
                      "• `/add_inventory loot @user Mana Crystal rare`\n"
                      "• `/add_inventory loot @user Phoenix Feather mythic`", inline=False)
        
        embed.add_field(name="⛏️ Ore", value="`/add_inventory ore <user> <ore_name> <rarity>`\n"
                      "**Examples:**\n"
                      "• `/add_inventory ore @user Iron Ore common`\n"
                      "• `/add_inventory ore @user Adamantium Ore legendary`\n"
                      "• `/add_inventory ore @user Divine Essence divine`", inline=False)
        
        embed.add_field(name="🔧 Custom Items", value="`/add_inventory custom <user> <item_name> <rarity> <type> [win_rate]`\n"
                      "**Types:** weapon, armor, artifact, consumable, material, ore, spirit_beast\n"
                      "**Example:** `/add_inventory custom @user Custom Item rare artifact`\n"
                      "**Spirit Beast:** `/add_inventory custom @user Spirit Wolf rare spirit_beast 75` (75% win rate)", inline=False)
        
        embed.add_field(name="📋 Quick Commands", value="**Common Items:**\n"
                      "• `/add_inventory weapons @user Iron Sword common`\n"
                      "• `/add_inventory loot @user Health Potion common`\n"
                      "• `/add_inventory ore @user Iron Ore common`", inline=False)
        
        embed.set_footer(text="All rarities: common, uncommon, rare, epic, legendary, mythic, divine, primordial")
        await ctx.send(embed=embed)
        return
    
    # Show available items for the selected section
    if section and not user and not item_name and not rarity:
        await show_section_items(ctx, section)
        return
    
    # Validate section
    valid_sections = ["weapons", "loot", "ore", "custom"]
    if section.lower() not in valid_sections:
        await send_embed(ctx, "Invalid Section", f"Valid sections: {', '.join(valid_sections)}\nUse `?add_inventory` to see the menu.", 0xe74c3c)
        return
    
    # Check if we have enough arguments for the section
    if section.lower() in ["weapons", "loot", "ore"]:
        if not all([user, item_name, rarity]):
            await send_embed(ctx, "Missing Arguments", f"Usage: `?add_inventory {section} <user> <item_name> <rarity>`", 0xe74c3c)
            return
    elif section.lower() == "custom":
        if not all([user, item_name, rarity, item_type]):
            await send_embed(ctx, "Missing Arguments", f"Usage: `?add_inventory custom <user> <item_name> <rarity> <type> [win_rate]`", 0xe74c3c)
            return
        
        # Validate win_rate for spirit beasts
        if item_type.lower() == "spirit_beast":
            if win_rate is None:
                win_rate = 50  # Default win rate
            elif not (1 <= win_rate <= 100):
                await send_embed(ctx, "Invalid Win Rate", "Win rate must be between 1 and 100", 0xe74c3c)
                return
    
    # Validate rarity
    valid_rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine", "primordial"]
    if rarity.lower() not in valid_rarities:
        await send_embed(ctx, "Invalid Rarity", f"Valid rarities: {', '.join(valid_rarities)}", 0xe74c3c)
        return
    
    try:
        user_id = user.id
        meta = get_user_meta(user_id)
        
        # Define rarity multipliers for all sections
        rarity_multipliers = {
            "common": 1, "uncommon": 2, "rare": 4, "epic": 6,
            "legendary": 8, "mythic": 16, "divine": 32, "primordial": 100
        }
        
        # Determine item type and create item based on section
        if section.lower() == "weapons":
            # Auto-generate weapon stats
            weapon_types = ["sword", "axe", "dagger", "staff", "bow", "spear", "hammer", "whip"]
            weapon_type = random.choice(weapon_types)
            
            # Calculate damage based on new balanced system - BUFFED EPIC+ WEAPONS
            if rarity.lower() == "common":
                damage = random.randint(1, 3)
            elif rarity.lower() == "uncommon":
                damage = random.randint(3, 5)
            elif rarity.lower() == "rare":
                damage = random.randint(5, 10)
            elif rarity.lower() == "epic":
                damage = random.randint(12, 16)  # BUFFED: was 10-13
            elif rarity.lower() == "legendary":
                damage = random.randint(18, 25)  # BUFFED: was 15-20
            elif rarity.lower() == "mythic":
                damage = random.randint(25, 50)  # BUFFED: was 20-40
            elif rarity.lower() == "divine":
                damage = random.randint(60, 120)  # BUFFED: was 50-100
            elif rarity.lower() == "primordial":
                damage = 1200  # BUFFED: was 1000
            else:
                damage = random.randint(1, 3)  # fallback
            
            # Use new direct pricing system
            weapon_sell_prices = {
                "common": 1200, "uncommon": 5600, "rare": 60000, "epic": 240000,
                "legendary": 2000000, "mythic": random.randint(20000000, 50000000),
                "divine": 400000000, "primordial": 1000000000
            }
            final_value = weapon_sell_prices.get(rarity.lower(), 1200)
            
            # Apply randomization based on rarity
            if rarity.lower() in ["legendary", "mythic", "divine", "primordial"]:
                random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
                final_value = int(final_value * random_factor)
            else:
                random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
                final_value = int(final_value * random_factor)
            
            item = {
                "name": f"{rarity.title()} {item_name}",
                "rarity": rarity.lower(),
                "type": "weapon",
                "weapon_type": weapon_type,
                "damage": damage,
                "value": final_value,
                "description": f"A {rarity} {weapon_type} with {damage} damage",
                "added_by": ctx.author.id,
                "added_at": datetime.now(timezone.utc).isoformat()
            }
            
        elif section.lower() == "loot":
            # Use new direct pricing system
            loot_sell_prices = {
                "common": 300, "uncommon": 1000, "rare": 20000, "epic": 70000,
                "legendary": 400000, "mythic": 4000000, "divine": 70000000, "primordial": 1000000000
            }
            final_value = loot_sell_prices.get(rarity.lower(), 300)
            
            # Apply randomization based on rarity
            if rarity.lower() in ["legendary", "mythic", "divine", "primordial"]:
                random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
                final_value = int(final_value * random_factor)
            else:
                random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
                final_value = int(final_value * random_factor)
            
            item = {
                "name": f"{rarity.title()} {item_name}",
                "rarity": rarity.lower(),
                "type": "consumable",
                "description": f"A {rarity} quality {item_name}",
                "value": final_value,
                "added_by": ctx.author.id,
                "added_at": datetime.now(timezone.utc).isoformat()
            }
            
        elif section.lower() == "ore":
            # Use new direct pricing system
            ore_sell_prices = {
                "common": 450, "uncommon": 1300, "rare": 30000, "epic": 120000,
                "legendary": 600000, "mythic": 10000000, "divine": 100000000, "primordial": 1000000000
            }
            final_value = ore_sell_prices.get(rarity.lower(), 450)
            
            # Apply randomization based on rarity
            if rarity.lower() in ["legendary", "mythic", "divine", "primordial"]:
                random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
                final_value = int(final_value * random_factor)
            else:
                random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
                final_value = int(final_value * random_factor)

            
            item = {
                "name": f"{rarity.title()} {item_name}",
                "rarity": rarity.lower(),
                "type": "ore",
                "description": f"A {rarity} quality {item_name}",
                "value": final_value,
                "added_by": ctx.author.id,
                "added_at": datetime.now(timezone.utc).isoformat()
            }
            
        elif section.lower() == "custom":
            # Validate custom item type
            valid_types = ["weapon", "armor", "artifact", "consumable", "material", "ore", "spirit_beast"]
            if item_type.lower() not in valid_types:
                await send_embed(ctx, "Invalid Type", f"Valid types: {', '.join(valid_types)}", 0xe74c3c)
                return
            
            # Create custom item with appropriate stats
            if item_type.lower() == "armor":
                # Generate health for armor using new balanced system
                if rarity.lower() == "common":
                    health = random.randint(1, 3)
                elif rarity.lower() == "uncommon":
                    health = random.randint(3, 5)
                elif rarity.lower() == "rare":
                    health = random.randint(5, 10)
                elif rarity.lower() == "epic":
                    health = random.randint(10, 15)
                elif rarity.lower() == "legendary":
                    health = random.randint(15, 25)
                elif rarity.lower() == "mythic":
                    health = random.randint(25, 50)
                elif rarity.lower() == "divine":
                    health = random.randint(50, 100)
                elif rarity.lower() == "primordial":
                    health = 1000  # Fixed primordial health
                else:
                    health = random.randint(1, 3)  # fallback
                
                # Use new direct pricing system for armor
                armor_sell_prices = {
                    "common": 1300, "uncommon": 5800, "rare": 70000, "epic": 320000,
                    "legendary": 3000000, "mythic": random.randint(30000000, 60000000),
                    "divine": 400000000, "primordial": 1000000000
                }
                final_value = armor_sell_prices.get(rarity.lower(), 1300)
                
                # Apply randomization based on rarity
                if rarity.lower() in ["legendary", "mythic", "divine", "primordial"]:
                    random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
                    final_value = int(final_value * random_factor)
                else:
                    random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
                    final_value = int(final_value * random_factor)
                
                item = {
                    "name": f"{rarity.title()} {item_name}",
                    "rarity": rarity.lower(),
                    "type": "armor",
                    "health": health,
                    "value": final_value,
                    "description": f"A {rarity} armor with {health} health",
                    "added_by": ctx.author.id,
                    "added_at": datetime.now(timezone.utc).isoformat()
                }
            else:
                # Use new direct pricing system for other item types
                if item_type.lower() == "weapon":
                    weapon_sell_prices = {
                        "common": 1200, "uncommon": 5600, "rare": 60000, "epic": 240000,
                        "legendary": 2000000, "mythic": random.randint(20000000, 50000000),
                        "divine": 400000000, "primordial": 1000000000
                    }
                    final_value = weapon_sell_prices.get(rarity.lower(), 1200)
                elif item_type.lower() == "artifact":
                    artifact_sell_prices = {
                        "common": 1500, "uncommon": 6000, "rare": 80000, "epic": 360000,
                        "legendary": 4000000, "mythic": random.randint(40000000, 70000000),
                        "divine": 400000000, "primordial": 1000000000
                    }
                    final_value = artifact_sell_prices.get(rarity.lower(), 1500)
                elif item_type.lower() == "ore":
                    ore_sell_prices = {
                        "common": 450, "uncommon": 1300, "rare": 30000, "epic": 120000,
                        "legendary": 600000, "mythic": 10000000, "divine": 100000000, "primordial": 1000000000
                    }
                    final_value = ore_sell_prices.get(rarity.lower(), 450)
                else:  # consumable, material
                    loot_sell_prices = {
                        "common": 300, "uncommon": 1000, "rare": 20000, "epic": 70000,
                        "legendary": 400000, "mythic": 4000000, "divine": 70000000, "primordial": 1000000000
                    }
                    final_value = loot_sell_prices.get(rarity.lower(), 300)
                
                # Apply randomization based on rarity
                if rarity.lower() in ["legendary", "mythic", "divine", "primordial"]:
                    random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
                    final_value = int(final_value * random_factor)
                else:
                    random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
                    final_value = int(final_value * random_factor)
                
                # Special handling for spirit beast items
                if item_type.lower() == "spirit_beast":
                    # Use the provided win_rate or default to 50
                    win_chance = win_rate if win_rate is not None else 50
                    
                    item = {
                        "name": f"{rarity.title()} {item_name}",
                        "rarity": rarity.lower(),
                        "type": "spirit_beast",
                        "spirit_animal": True,
                        "win_chance": win_chance,
                        "description": f"A {rarity} spirit beast with {win_chance}% win chance",
                        "value": final_value,
                        "added_by": ctx.author.id,
                        "added_at": datetime.now(timezone.utc).isoformat()
                    }
                else:
                    item = {
                        "name": f"{rarity.title()} {item_name}",
                        "rarity": rarity.lower(),
                        "type": item_type.lower(),
                        "description": f"A {rarity} {item_type}",
                        "value": final_value,
                        "added_by": ctx.author.id,
                        "added_at": datetime.now(timezone.utc).isoformat()
                    }
        
        # Add item to inventory using the stacking function
        add_item_to_inventory(user_id, item)
        
        # Create success embed
        embed = discord.Embed(title="✅ Item Added!", color=0x2ecc71)
        embed.description = f"Added **{item['name']}** to {user.mention}'s inventory"
        
        # Add section-specific details
        if section.lower() == "weapons":
            embed.add_field(name="Weapon Details", value=f"**Type:** {item['weapon_type'].title()}\n**Damage:** {item['damage']}\n**Value:** {MONEY_ICON} {item['value']:,}", inline=True)
        elif item.get("type") == "spirit_beast":
            embed.add_field(name="Spirit Beast Details", value=f"**Type:** Spirit Beast\n**Win Chance:** {item['win_chance']}%\n**Value:** {MONEY_ICON} {item['value']:,}", inline=True)
        else:
            embed.add_field(name="Item Details", value=f"**Type:** {item['type'].title()}\n**Rarity:** {rarity.title()}", inline=True)
        
        embed.add_field(name="Section", value=section.title(), inline=True)
        embed.add_field(name="Added By", value=f"{ctx.author.mention}", inline=True)
        embed.set_footer(text=f"Use /inventory to view {user.display_name}'s inventory")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Add Item Error", f"Error adding item: {str(e)}", 0xe74c3c)


async def show_section_items(ctx, section: str):
    """Show all available items for a specific section"""
    embed = discord.Embed(title=f"📦 Available {section.title()} Items", color=0x2ecc71)
    
    if section.lower() == "weapons":
        weapon_names = {
            "common": ["Iron Sword", "Wooden Staff", "Stone Axe", "Bone Dagger", "Copper Spear", "Rusty Blade", "Training Sword"],
            "uncommon": ["Steel Sword", "Iron Staff", "Iron Axe", "Steel Dagger", "Iron Spear", "Silver Blade", "Warrior Sword"],
            "rare": ["Mythril Sword", "Silver Staff", "Steel Axe", "Silver Dagger", "Steel Spear", "Gold Blade", "Knight Sword"],
            "legendary": ["Adamantium Sword", "Gold Staff", "Mythril Axe", "Gold Dagger", "Mythril Spear", "Platinum Blade", "Hero Sword"],
            "mythic": ["Divine Blade", "Platinum Staff", "Adamantium Axe", "Platinum Dagger", "Adamantium Spear", "Diamond Blade", "Legend Sword"],
            "divine": ["Celestial Blade", "Diamond Staff", "Divine Axe", "Diamond Dagger", "Divine Spear", "Ethereal Blade", "God Sword"]
        }
        
        for rarity, names in weapon_names.items():
            rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
            embed.add_field(
                name=f"{rarity_emoji} {rarity.title()} Weapons",
                value="\n".join([f"• {name}" for name in names]),
                inline=True
            )
    
    elif section.lower() == "loot":
        loot_names = {
            "common": ["Health Potion", "Mana Potion", "Bread", "Water", "Bandage", "Torch", "Rope"],
            "uncommon": ["Greater Health Potion", "Greater Mana Potion", "Healing Salve", "Mana Crystal", "Food Ration", "Lantern"],
            "rare": ["Superior Health Potion", "Superior Mana Potion", "Elixir of Life", "Mana Gem", "Feast", "Magical Light"],
            "legendary": ["Potion of Immortality", "Mana Essence", "Phoenix Feather", "Dragon Scale", "Golden Apple", "Eternal Flame"],
            "mythic": ["Elixir of the Gods", "Mana Core", "Phoenix Heart", "Dragon Heart", "Tree of Life", "Sun's Light"],
            "divine": ["Essence of Creation", "Mana Source", "Phoenix Soul", "Dragon Soul", "World Tree", "Divine Light"]
        }
        
        for rarity, names in loot_names.items():
            rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
            embed.add_field(
                name=f"{rarity_emoji} {rarity.title()} Loot Items",
                value="\n".join([f"• {name}" for name in names]),
                inline=True
            )
    
    elif section.lower() == "ore":
        for rarity, ores in ORE_TYPES.items():
            rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
            embed.add_field(
                name=f"{rarity_emoji} {rarity.title()} Ores",
                value="\n".join([f"• {ore}" for ore in ores]),
                inline=True
            )
    
    elif section.lower() == "custom":
        embed.description = "**Available Custom Item Types:**\n• weapon - Melee and ranged weapons\n• armor - Protective equipment\n• artifact - Magical items with special effects\n• consumable - Items that can be used\n• material - Crafting materials\n• ore - Mining materials\n• spirit_beast - Spirit beasts with win chance (default 50%)"
        embed.add_field(name="Usage", value="`/add_inventory custom <user> <item_name> <rarity> <type>`", inline=False)
    
    embed.set_footer(text=f"Use /add_inventory {section} <user> <item_name> <rarity> to add items")
    await ctx.send(embed=embed)


@bot.command(name="remove_inventory")
@commands.has_permissions(administrator=True)
async def remove_inventory(ctx, user: discord.Member, item_name: str):
    """Remove an item from a user's inventory - Admin only"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        user_id = user.id
        meta = get_user_meta(user_id)
        
        if "inventory" not in meta or not meta["inventory"]:
            await send_embed(ctx, "Empty Inventory", f"{user.display_name} has no items in their inventory.", 0xe67e22)
            return
        
        # Find and remove the item
        removed_items = []
        original_count = len(meta["inventory"])
        
        # Remove all items with matching name (case-insensitive)
        meta["inventory"] = [item for item in meta["inventory"] 
                           if item["name"].lower() != item_name.lower()]
        
        removed_count = original_count - len(meta["inventory"])
        
        if removed_count == 0:
            await send_embed(ctx, "Item Not Found", f"No items named '{item_name}' found in {user.display_name}'s inventory.", 0xe67e22)
            return
        
        # Save the updated inventory
        set_user_meta(user_id, meta)
        
        embed = discord.Embed(title="🗑️ Item Removed!", color=0x2ecc71)
        embed.description = f"Removed **{removed_count}** item(s) named '{item_name}' from {user.mention}'s inventory"
        embed.add_field(name="Items Removed", value=f"**{removed_count}**", inline=True)
        embed.add_field(name="Removed By", value=f"{ctx.author.mention}", inline=True)
        embed.set_footer(text=f"Use /inventory to view {user.display_name}'s inventory")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Remove Item Error", f"Error removing item: {str(e)}", 0xe74c3c)


# -----------------------
# Store Management Commands
# -----------------------

async def cleanup_expired_temp_roles():
    """Background task to clean up expired temporary roles"""
    while True:
        try:
            # Wait 1 hour before checking
            await asyncio.sleep(3600)
            
            # Get all users with temporary roles
            all_users = []
            for filename in os.listdir(DATA_DIR):
                if filename.endswith('.json') and filename.startswith('user_'):
                    user_id = int(filename.split('_')[1].split('.')[0])
                    all_users.append(user_id)
            
            current_time = int(time.time())
            roles_removed = 0
            
            for user_id in all_users:
                try:
                    meta = get_user_meta(user_id)
                    temp_roles = meta.get("temp_roles", {})
                    
                    if not temp_roles:
                        continue
                    
                    # Check each temporary role
                    roles_to_remove = []
                    for role_id_str, role_data in temp_roles.items():
                        if role_data["expires"] <= current_time:
                            roles_to_remove.append(role_id_str)
                    
                    # Remove expired roles
                    for role_id_str in roles_to_remove:
                        role_id = int(role_id_str)
                        del temp_roles[role_id_str]
                        roles_removed += 1
                    
                    # Update user meta if any roles were removed
                    if roles_to_remove:
                        meta["temp_roles"] = temp_roles
                        set_user_meta(user_id, meta)
                        
                except Exception as e:
                    # Log error but continue with other users
                    print(f"Error cleaning up temp roles for user {user_id}: {e}")
                    continue
            
            if roles_removed > 0:
                print(f"Cleaned up {roles_removed} expired temporary roles")
                
        except Exception as e:
            print(f"Error in cleanup_expired_temp_roles: {e}")
            await asyncio.sleep(3600)  # Wait an hour before retrying




@bot.command(name="store_effects")
@commands.has_permissions(administrator=True)
async def store_effects(ctx, item_name: str, effect_type: str, effect_value: str, duration_days: int = None):
    """Add effects to store items - Admin only
    
    Usage: ?store_effects <item_name> <effect_type> <effect_value> [duration_days]
    
    Effect Types:
    - add_role <role_id> - Adds role on purchase
    - remove_role <role_id> - Removes role on purchase  
    - toggle_role <role_id> - Toggles role on purchase
    - temp_role <role_id> [duration_days] - Temporary role
    - add_money <amount> - Adds money on purchase
    - set_money <amount> - Sets money on purchase
    - xp_boost <amount> - Grants XP on purchase
    - sect_xp <amount> - Grants Sect XP on purchase
    - job_xp <amount> - Grants Job XP on purchase
    - immortal_art_reroll <amount> - Grants rerolls on purchase
    
    Examples:
    ?store_effects sword add_role 123456789
    ?store_effects armor temp_role 123456789 7
    ?store_effects potion xp_boost 1000
    """
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        # Load current store
        store = load_json(STORE_FILE)
        
        if item_name.lower() not in store:
            await send_embed(ctx, "Item Not Found", f"Item '{item_name}' not found in store.", 0xe74c3c)
            return
        
        item_data = store[item_name.lower()]
        if "effects" not in item_data:
            item_data["effects"] = {}
        
        effects = item_data["effects"]
        
        # Handle different effect types
        if effect_type.lower() == "add_role":
            # Add role effect: add_role:role_id
            try:
                role_id = int(effect_value)
                role = ctx.guild.get_role(role_id)
                if not role:
                    await send_embed(ctx, "Invalid Role", f"Role with ID {role_id} not found.", 0xe74c3c)
                    return
                effects["add_role"] = role_id
                effect_desc = f"Adds role: {role.mention}"
            except ValueError:
                await send_embed(ctx, "Invalid Role ID", "Role ID must be a number.", 0xe74c3c)
                return
            
        elif effect_type.lower() == "remove_role":
            # Remove role effect: remove_role:role_id
            try:
                role_id = int(effect_value)
                role = ctx.guild.get_role(role_id)
                if not role:
                    await send_embed(ctx, "Invalid Role", f"Role with ID {role_id} not found.", 0xe74c3c)
                    return
                effects["remove_role"] = role_id
                effect_desc = f"Removes role: {role.mention}"
            except ValueError:
                await send_embed(ctx, "Invalid Role ID", "Role ID must be a number.", 0xe74c3c)
                return
            
        elif effect_type.lower() == "toggle_role":
            # Toggle role effect: toggle_role:role_id
            try:
                role_id = int(effect_value)
                role = ctx.guild.get_role(role_id)
                if not role:
                    await send_embed(ctx, "Invalid Role", f"Role with ID {role_id} not found.", 0xe74c3c)
                    return
                effects["toggle_role"] = role_id
                effect_desc = f"Toggles role: {role.mention}"
            except ValueError:
                await send_embed(ctx, "Invalid Role ID", "Role ID must be a number.", 0xe74c3c)
                return
            
        elif effect_type.lower() == "add_money":
            # Add money effect: add_money:amount
            try:
                amount = int(effect_value)
                effects["add_money"] = amount
                effect_desc = f"Adds {MONEY_ICON} {amount:,} to wallet"
            except ValueError:
                await send_embed(ctx, "Invalid Amount", "Amount must be a number.", 0xe74c3c)
                return
            
        elif effect_type.lower() == "remove_money":
            # Remove money effect: remove_money:amount
            try:
                amount = int(effect_value)
                effects["remove_money"] = amount
                effect_desc = f"Removes {MONEY_ICON} {amount:,} from wallet"
            except ValueError:
                await send_embed(ctx, "Invalid Amount", "Amount must be a number.", 0xe74c3c)
                return
            
        elif effect_type.lower() == "set_money":
            # Set money effect: set_money:amount
            try:
                amount = int(effect_value)
                effects["set_money"] = amount
                effect_desc = f"Sets wallet to {MONEY_ICON} {amount:,}"
            except ValueError:
                await send_embed(ctx, "Invalid Amount", "Amount must be a number.", 0xe74c3c)
                return
            
        elif effect_type.lower() == "temp_role":
            # Temporary role effect: temp_role:role_id:days
            if not duration_days:
                await send_embed(ctx, "Duration Required", "Duration in days is required for temporary role effects.", 0xe74c3c)
                return
            try:
                role_id = int(effect_value)
                role = ctx.guild.get_role(role_id)
                if not role:
                    await send_embed(ctx, "Invalid Role", f"Role with ID {role_id} not found.", 0xe74c3c)
                    return
                effects["temp_role"] = {
                    "role_id": role_id,
                    "duration_days": duration_days
                }
                effect_desc = f"Temporarily adds role: {role.mention} for {duration_days} days"
            except ValueError:
                await send_embed(ctx, "Invalid Role ID", "Role ID must be a number.", 0xe74c3c)
                return
            
        elif effect_type.lower() == "xp_boost":
            # XP boost effect: xp_boost:amount
            try:
                amount = int(effect_value)
                effects["xp_boost"] = amount
                effect_desc = f"Grants {amount:,} XP"
            except ValueError:
                await send_embed(ctx, "Invalid Amount", "Amount must be a number.", 0xe74c3c)
                return
            
        elif effect_type.lower() == "sect_xp":
            # Sect XP effect: sect_xp:amount
            try:
                amount = int(effect_value)
                effects["sect_xp"] = amount
                effect_desc = f"Grants {amount:,} Sect XP"
            except ValueError:
                await send_embed(ctx, "Invalid Amount", "Amount must be a number.", 0xe74c3c)
                return
            
        elif effect_type.lower() == "job_xp":
            # Job XP effect: job_xp:amount
            try:
                amount = int(effect_value)
                effects["job_xp"] = amount
                effect_desc = f"Grants {amount:,} Job XP"
            except ValueError:
                await send_embed(ctx, "Invalid Amount", "Amount must be a number.", 0xe74c3c)
                return
            
        elif effect_type.lower() == "immortal_art_reroll":
            # Immortal art reroll effect: immortal_art_reroll:amount
            try:
                amount = int(effect_value)
                effects["immortal_art_reroll"] = amount
                effect_desc = f"Grants {amount} Immortal Art reroll(s)"
            except ValueError:
                await send_embed(ctx, "Invalid Amount", "Amount must be a number.", 0xe74c3c)
                return
            
        else:
            await send_embed(ctx, "Invalid Effect Type", 
                           f"Unknown effect type: {effect_type}\n\n"
                           f"**Valid Effect Types:**\n"
                           f"• `add_role <role_id>` - Adds role on purchase\n"
                           f"• `remove_role <role_id>` - Removes role on purchase\n"
                           f"• `toggle_role <role_id>` - Toggles role on purchase\n"
                           f"• `temp_role <role_id> [days]` - Temporary role\n"
                           f"• `add_money <amount>` - Adds money on purchase\n"
                           f"• `set_money <amount>` - Sets money on purchase\n"
                           f"• `xp_boost <amount>` - Grants XP on purchase\n"
                           f"• `sect_xp <amount>` - Grants Sect XP on purchase\n"
                           f"• `job_xp <amount>` - Grants Job XP on purchase\n"
                           f"• `immortal_art_reroll <amount>` - Grants rerolls on purchase", 0xe74c3c)
            return
        
        # Save the updated store
        save_json(STORE_FILE, store)
        
        embed = discord.Embed(title="✅ Effect Added!", color=0x2ecc71)
        embed.description = f"Added effect to **{item_name}**"
        embed.add_field(name="Effect", value=effect_desc, inline=True)
        embed.add_field(name="Added By", value=f"{ctx.author.mention}", inline=True)
        if duration_days:
            embed.add_field(name="Duration", value=f"{duration_days} days", inline=True)
        embed.set_footer(text="The effect will be applied when users use this item")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Store Effects Error", f"Error adding effect: {str(e)}", 0xe74c3c)


@bot.command(name="store_list")
@commands.has_permissions(administrator=True)
async def store_list(ctx):
    """List all items in the store with detailed information - Admin only"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        store = load_json(STORE_FILE)
        
        if not store:
            await send_embed(ctx, "Empty Store", "No items found in the store.", 0xe67e22)
            return
        
        embed = discord.Embed(title="🏪 Store Items", color=0x9b59b6)
        
        # Group items by type
        items_by_type = {}
        for item_name, item_data in store.items():
            item_type = item_data.get("type", "unknown")
            if item_type not in items_by_type:
                items_by_type[item_type] = []
            items_by_type[item_type].append((item_name, item_data))
        
        # Sort items by price within each type (lowest to highest)
        for item_type in items_by_type:
            items_by_type[item_type].sort(key=lambda x: x[1].get('price', 0))
        
        for item_type, items in items_by_type.items():
            type_text = ""
            for item_name, item_data in items[:5]:  # Show max 5 per type
                rarity_emoji = RARITY_EMOJI.get(item_data.get("rarity", "common"), "⚪")
                price = item_data.get("price", 0)
                stock = item_data.get("stock", 0)
                type_text += f"{rarity_emoji} **{item_name.title()}** - {MONEY_ICON} {price:,} (Stock: {stock})\n"
            
            if len(items) > 5:
                type_text += f"... and {len(items) - 5} more items\n"
            
            embed.add_field(name=f"{item_type.title()} Items ({len(items)})", value=type_text, inline=False)
        
        embed.set_footer(text="Use /store_effects to add effects to items")
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Store List Error", f"Error listing store items: {str(e)}", 0xe74c3c)





# -----------------------
# Combat Stats Command
# -----------------------

@bot.command(name="combat_stats", aliases=["cs", "stats"])
async def combat_stats_cmd(ctx):
    """View detailed combat statistics including equipment bonuses"""
    user_id = ctx.author.id
    attributes, _ = get_user_attributes(user_id)
    equipment = get_user_equipment(user_id)
    combat_stats = calculate_combat_stats(user_id)
    
    embed = discord.Embed(
        title="⚔️ Combat Statistics",
        description=f"Detailed combat analysis for {ctx.author.display_name}",
        color=0xe74c3c
    )
    
    # Base attributes
    embed.add_field(
        name="📊 Base Attributes",
        value=f"**Strength:** {attributes.get('strength', 0)} (+{attributes.get('strength', 0) * 2} damage)\n"
              f"**Defence:** {attributes.get('defence', 0)} (+{attributes.get('defence', 0) * 2} defense)\n"
                              f"**Longevity:** {attributes.get('longevity', 0)} (+{attributes.get('longevity', 0) * 1} health)\n"
              f"**Luck:** {attributes.get('luck', 0)} (+{attributes.get('luck', 0) * 2}% crit chance)",
        inline=False
    )
    
    # Equipment bonuses
    equipment_bonuses = "**Weapon:** "
    if equipment["weapon"]:
        weapon = equipment["weapon"]
        rarity_emoji = RARITY_EMOJI.get(weapon["rarity"], "⚪")
        equipment_bonuses += f"{rarity_emoji} +{weapon['damage']} damage\n"
    else:
        equipment_bonuses += "None equipped\n"
    
    equipment_bonuses += "**Armor:** "
    if equipment["armor"]:
        armor = equipment["armor"]
        rarity_emoji = RARITY_EMOJI.get(armor["rarity"], "⚪")
        equipment_bonuses += f"{rarity_emoji} +{armor['health']} health\n"
    else:
        equipment_bonuses += "None equipped\n"
    
    equipment_bonuses += "**Artifacts:** "
    if equipment["artifacts"]:
        for i, artifact in enumerate(equipment["artifacts"]):
            rarity_emoji = RARITY_EMOJI.get(artifact["rarity"], "⚪")
            equipment_bonuses += f"{rarity_emoji} {artifact['name']}\n"
            for ability in artifact.get("abilities", []):
                if "damage" in ability.lower():
                    equipment_bonuses += "   +10 damage\n"
                elif "defense" in ability.lower():
                    equipment_bonuses += "   +8 defense\n"
                elif "health" in ability.lower():
                    equipment_bonuses += "   +50 health\n"
                elif "critical" in ability.lower():
                    equipment_bonuses += "   +5% crit chance\n"
    else:
        equipment_bonuses += "None equipped"
    
    embed.add_field(
        name="⚔️ Equipment Bonuses",
        value=equipment_bonuses,
        inline=False
    )
    
    # Total combat stats
    embed.add_field(
        name="🎯 Total Combat Stats",
        value=f"**Total Damage:** {combat_stats['total_damage']}\n"
              f"**Total Defense:** {combat_stats['total_defense']}\n"
              f"**Total Health:** {combat_stats['total_health']}\n"
              f"**Critical Chance:** {combat_stats['critical_chance']}%",
        inline=False
    )
    
    # Immortal Arts bonuses
    immortal_bonuses = combat_stats.get("immortal_arts_bonus", {})
    if any(immortal_bonuses.values()):
        immortal_text = ""
        if immortal_bonuses.get("damage_bonus_pct", 0) > 0:
            immortal_text += f"**Damage:** +{immortal_bonuses['damage_bonus_pct']}%\n"
        if immortal_bonuses.get("defense_bonus_pct", 0) > 0:
            immortal_text += f"**Defense:** +{immortal_bonuses['defense_bonus_pct']}%\n"
        if immortal_bonuses.get("health_bonus_pct", 0) > 0:
            immortal_text += f"**Health:** +{immortal_bonuses['health_bonus_pct']}%\n"
        if immortal_bonuses.get("critical_bonus_pct", 0) > 0:
            immortal_text += f"**Critical:** +{immortal_bonuses['critical_bonus_pct']}%\n"
        
        embed.add_field(
            name="✨ Immortal Arts Bonuses",
            value=immortal_text,
        inline=False
    )
    
    # Combat rating calculation
    combat_rating = (combat_stats['total_damage'] * 0.4 + 
                    combat_stats['total_defense'] * 0.3 + 
                    combat_stats['total_health'] * 0.2 + 
                    combat_stats['critical_chance'] * 2)
    
    embed.add_field(
        name="🏆 Combat Rating",
        value=f"**Overall Rating:** {int(combat_rating)}\n"
              f"**Tier:** {get_combat_tier(combat_rating)}",
        inline=False
    )
    
    embed.set_footer(text="Use /equipment for a simpler view • Use /blacksmith to craft better gear")
    await ctx.send(embed=embed)

@bot.hybrid_command(name="pvp_stats", description="View your PvP combat stats and equipment")
async def pvp_stats_cmd(ctx):
    """View your PvP-focused combat statistics"""
    user_id = ctx.author.id
    combat_stats = calculate_combat_stats(user_id)
    equipment = get_user_equipment(user_id)
    
    embed = discord.Embed(
        title="⚔️ PvP Combat Stats",
        description=f"Combat statistics for {ctx.author.display_name}",
        color=0xe74c3c
    )
    
    # Core combat stats
    embed.add_field(
        name="🎯 Core Stats",
        value=f"**Total Damage:** {combat_stats['total_damage']}\n"
              f"**Total Defense:** {combat_stats['total_defense']}\n"
              f"**Total Health:** {combat_stats['total_health']}\n"
              f"**Critical Chance:** {combat_stats['critical_chance']}%",
        inline=False
    )
    
    # Equipment breakdown
    weapon = equipment.get("weapon")
    armor = equipment.get("armor")
    artifacts = equipment.get("artifacts", [])
    
    weapon_text = "None equipped"
    if weapon:
        rarity_emoji = RARITY_EMOJI.get(weapon.get("rarity", "common"), "⚪")
        weapon_text = f"{rarity_emoji} {weapon['name']} (+{weapon.get('damage', 0)} damage)"
    
    armor_text = "None equipped"
    if armor:
        rarity_emoji = RARITY_EMOJI.get(armor.get("rarity", "common"), "⚪")
        armor_text = f"{rarity_emoji} {armor['name']} (+{armor.get('health', 0)} health)"
    
    artifacts_text = "None equipped"
    if artifacts:
        artifact_list = []
        for artifact in artifacts:
            if isinstance(artifact, dict):
                rarity_emoji = RARITY_EMOJI.get(artifact.get("rarity", "common"), "⚪")
                abilities = ", ".join(artifact.get("abilities", [])[:2]) or "None"
                artifact_list.append(f"{rarity_emoji} {artifact['name']} ({abilities})")
        artifacts_text = "\n".join(artifact_list[:3])  # Show first 3
    
    embed.add_field(name="⚔️ Weapon", value=weapon_text, inline=True)
    embed.add_field(name="🛡️ Armor", value=armor_text, inline=True)
    embed.add_field(name="✨ Artifacts", value=artifacts_text, inline=True)
    
    # PvP tips
    tips = []
    if combat_stats['total_damage'] < 50:
        tips.append("💡 Consider upgrading your weapon for more damage")
    if combat_stats['total_health'] < 150:
        tips.append("💡 Better armor will give you more survivability")
    if combat_stats['critical_chance'] < 10:
        tips.append("💡 Artifacts with critical bonuses can turn the tide")
    if len(artifacts) < 2:
        tips.append("💡 Multiple artifacts unlock special abilities")
    
    if tips:
        embed.add_field(name="💡 PvP Tips", value="\n".join(tips), inline=False)
    
    embed.set_footer(text="Use /pvp_fight @user to challenge someone!")
    await ctx.send(embed=embed)

# -----------------------
# Party System Commands
# -----------------------

# Party command removed



# Party command removed

# Party command removed

# Party command removed

# Party command removed

# Party command removed

# Party command removed


# Party button handlers removed


# sell_equipment command removed - redundant with the main /sell command


def get_combat_tier(rating: float) -> str:
    """Get combat tier based on rating"""
    if rating < 100:
        return "Novice"
    elif rating < 200:
        return "Apprentice"
    elif rating < 350:
        return "Warrior"
    elif rating < 500:
        return "Veteran"
    elif rating < 700:
        return "Elite"
    elif rating < 1000:
        return "Master"
    elif rating < 1500:
        return "Legend"
    else:
        return "Mythic"


# -----------------------
# Market System
# -----------------------

# Global market data
MARKET_ITEMS = []
MARKET_LAST_UPDATE = 0

def load_market():
    """Load market data from file"""
    global MARKET_ITEMS, MARKET_LAST_UPDATE
    try:
        data = load_json(MARKET_FILE)
        MARKET_ITEMS = data.get("items", [])
        MARKET_LAST_UPDATE = data.get("last_update", 0)
    except Exception:
        MARKET_ITEMS = []
        MARKET_LAST_UPDATE = 0

def save_market():
    """Save market data to file"""
    data = {
        "items": MARKET_ITEMS,
        "last_update": MARKET_LAST_UPDATE
    }
    save_json(MARKET_FILE, data)

def validate_market_items():
    """Validate and fix market items to ensure they have all required fields"""
    global MARKET_ITEMS
    
    for item in MARKET_ITEMS:
        # Ensure required fields exist
        if "name" not in item:
            item["name"] = "Unknown Item"
        if "type" not in item:
            item["type"] = "loot"
        if "rarity" not in item:
            item["rarity"] = "common"
        if "cost" not in item:
            item["cost"] = 1000
        if "stock" not in item:
            item["stock"] = 1
        if "value" not in item:
            item["value"] = item["cost"]
        
        # Ensure type-specific fields exist
        if item["type"] == "weapon" and "damage" not in item:
            item["damage"] = 10
        elif item["type"] == "armor" and "health" not in item:
            item["health"] = 50
        elif item["type"] == "artifact" and "abilities" not in item:
            item["abilities"] = ["basic"]
        elif item["type"] in ["loot", "consumable"] and "description" not in item:
            item["description"] = f"A {item['rarity']} {item['type']}"

def clean_user_inventory(user_id: int):
    """Clean up old inventory items and convert them to new format with stacking"""
    try:
        print(f"DEBUG: clean_user_inventory called for user {user_id}")
        meta = get_user_meta(user_id)
        if "inventory" not in meta:
            print(f"DEBUG: No inventory found for user {user_id}")
            return
        
        old_inventory = meta["inventory"]
        print(f"DEBUG: Old inventory length: {len(old_inventory)}")
        print(f"DEBUG: Old inventory sample: {old_inventory[:3] if old_inventory else 'empty'}")
        
        # Clear inventory to rebuild with stacking
        meta["inventory"] = []
        set_user_meta(user_id, meta)
        
        # Re-add all items using the stacking function
        for item in old_inventory:
            try:
                if isinstance(item, str):
                    # Convert old string items to new format
                    new_item = {
                        "name": item,
                        "type": "loot",
                        "rarity": "common",
                        "description": f"Legacy item: {item}",
                        "value": 1000
                    }
                    add_item_to_inventory(user_id, new_item)
                    print(f"Converted string item '{item}' to new format")
                elif isinstance(item, dict):
                    # Validate existing dict items
                    if "name" in item and "type" in item:
                        add_item_to_inventory(user_id, item)
                        print(f"Kept valid dict item: {item.get('name', 'unknown')}")
                    else:
                        print(f"Skipping invalid dict item: {item}")
                else:
                    print(f"Skipping unknown item type: {type(item)}: {item}")
            except Exception as e:
                print(f"Error processing item in clean_user_inventory: {e}")
                continue
        
        # Get final inventory to show results
        final_meta = get_user_meta(user_id)
        final_inventory = final_meta.get("inventory", [])
        total_items = sum(item.get("amount", 1) for item in final_inventory)
        
        print(f"Cleaned inventory for user {user_id}: {len(old_inventory)} → {len(final_inventory)} unique items, {total_items} total items")
        print(f"DEBUG: New inventory sample: {final_inventory[:3] if final_inventory else 'empty'}")
        
    except Exception as e:
        print(f"Error in clean_user_inventory for user {user_id}: {e}")
        # Don't fail completely - just log the error

def generate_daily_market():
    """Generate new daily market items - Improved version with better balance and more items"""
    global MARKET_ITEMS, MARKET_LAST_UPDATE
    current_time = time.time()
    
    # Check if it's been 24 hours since last update, or if market is empty (first run)
    if current_time - MARKET_LAST_UPDATE < 86400 and MARKET_ITEMS:  # 24 hours
        return
    
    MARKET_ITEMS = []
    
    # Generate more items for a better market (2 pages worth = ~20-30 items)
    num_items = random.randint(20, 30)
    
    # Ensure we have a good mix of item types
    item_type_weights = {
        "weapon": 25,      # 25% chance - important combat items
        "armor": 25,       # 25% chance - important combat items  
        "artifact": 20,    # 20% chance - powerful items
        "ore": 15,         # 15% chance - crafting materials
        "loot": 10,        # 10% chance - miscellaneous
        "consumable": 5    # 5% chance - limited use items
    }
    
    for _ in range(num_items):
        try:
            # Weighted random selection based on rarity
            total_weight = sum(MARKET_RARITY_WEIGHTS.values())
            rand = random.random() * total_weight
            
            current_weight = 0
            selected_rarity = "common"
            for rarity, weight in MARKET_RARITY_WEIGHTS.items():
                current_weight += weight
                if rand <= current_weight:
                    selected_rarity = rarity
                    break
            
            # Weighted selection of item type for better balance
            total_type_weight = sum(item_type_weights.values())
            type_rand = random.random() * total_type_weight
            
            current_type_weight = 0
            selected_item_type = "loot"  # default
            for item_type, weight in item_type_weights.items():
                current_type_weight += weight
                if type_rand <= current_type_weight:
                    selected_item_type = item_type
                    break
            
            # Get base cost for this rarity and type
            base_cost = MARKET_ITEM_TYPES[selected_item_type][selected_rarity]
            
            # Add some variation (±15% instead of 20% for more consistent pricing)
            variation = random.uniform(0.85, 1.15)
            cost = int(base_cost * variation)
            
            # Generate item based on type
            item = None
            
            if selected_item_type == "weapon":
                # Ensure we have weapon types available
                if hasattr(WEAPON_TYPES, 'keys') and WEAPON_TYPES:
                    weapon_type = random.choice(list(WEAPON_TYPES.keys()))
                    item = generate_weapon(weapon_type, selected_rarity)
                else:
                    # Fallback weapon generation
                    item = {
                        "name": f"{selected_rarity.title()} Sword",
                        "type": "weapon",
                        "rarity": selected_rarity,
                        "damage": 10 + (["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"].index(selected_rarity) * 15),
                        "description": f"A {selected_rarity} quality weapon"
                    }
                    
            elif selected_item_type == "armor":
                # Ensure we have armor types available
                if hasattr(ARMOR_TYPES, 'keys') and ARMOR_TYPES:
                    armor_type = random.choice(list(ARMOR_TYPES.keys()))
                    item = generate_armor(armor_type, selected_rarity)
                else:
                    # Fallback armor generation
                    item = {
                        "name": f"{selected_rarity.title()} Armor",
                        "type": "armor",
                        "rarity": selected_rarity,
                        "health": 8 + (["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"].index(selected_rarity) * 18),
                        "description": f"{selected_rarity.title()} quality armor"
                    }
                    
            elif selected_item_type == "artifact":
                # Ensure we have artifact types available
                if hasattr(ARTIFACT_TYPES, 'keys') and ARTIFACT_TYPES:
                    artifact_type = random.choice(list(ARTIFACT_TYPES.keys()))
                    item = generate_artifact(artifact_type, selected_rarity)
                else:
                    # Fallback artifact generation
                    item = {
                        "name": f"{selected_rarity.title()} Artifact",
                        "description": f"A powerful {selected_rarity} artifact"
                    }
                    
            elif selected_item_type == "ore":
                # Ensure we have ore types available
                if selected_rarity in ORE_TYPES and ORE_TYPES[selected_rarity]:
                    item = {
                        "name": random.choice(ORE_TYPES[selected_rarity]),
                        "type": "ore",
                        "rarity": selected_rarity,
                        "description": f"A {selected_rarity} quality ore for crafting"
                    }
                else:
                    # Fallback ore generation
                    item = {
                        "name": f"{selected_rarity.title()} Ore",
                        "type": "ore",
                        "rarity": selected_rarity,
                        "description": f"High-quality {selected_rarity} ore"
                    }
                    
            elif selected_item_type == "loot":
                # Ensure we have loot names available
                if (selected_rarity in MARKET_ITEM_NAMES.get("loot", {}) and 
                    MARKET_ITEM_NAMES["loot"][selected_rarity]):
                    item = {
                        "name": random.choice(MARKET_ITEM_NAMES["loot"][selected_rarity]),
                        "type": "loot",
                        "rarity": selected_rarity,
                        "description": f"A valuable {selected_rarity} loot item"
                    }
                else:
                    # Fallback loot generation
                    item = {
                        "name": f"{selected_rarity.title()} Treasure",
                        "type": "loot",
                        "rarity": selected_rarity,
                        "description": f"Rare {selected_rarity} treasure"
                    }
                    
            elif selected_item_type == "consumable":
                # Ensure we have consumable names available
                if (selected_rarity in MARKET_ITEM_NAMES.get("consumable", {}) and 
                    MARKET_ITEM_NAMES["consumable"][selected_rarity]):
                    item = {
                        "name": random.choice(MARKET_ITEM_NAMES["consumable"][selected_rarity]),
                        "type": "consumable",
                        "rarity": selected_rarity,
                        "description": f"A powerful {selected_rarity} consumable"
                    }
                else:
                    # Fallback consumable generation
                    item = {
                        "name": f"{selected_rarity.title()} Potion",
                        "type": "consumable",
                        "rarity": selected_rarity,
                        "description": f"A {selected_rarity} healing potion"
                    }
            
            # Skip if item generation failed
            if not item:
                continue
                
            # Add market-specific fields
            item["market_id"] = f"market_{len(MARKET_ITEMS)}"
            item["cost"] = cost
            item["rarity"] = selected_rarity
            item["stock"] = random.randint(1, 5)  # Increased stock for better availability
            
            # Ensure item has a value field for merchant selling
            if "value" not in item:
                item["value"] = cost
            
            # Add item to market
            MARKET_ITEMS.append(item)
            
        except Exception as e:
            print(f"Error generating market item: {e}")
            continue
    
    # Ensure we have at least some items
    if not MARKET_ITEMS:
        print("Warning: No market items generated, creating fallback items")
        # Create some basic fallback items
        fallback_items = [
            {"name": "Common Sword", "type": "weapon", "rarity": "common", "damage": 10, "cost": 10000, "value": 10000, "stock": 3},
            {"name": "Common Armor", "type": "armor", "rarity": "common", "health": 20, "cost": 8000, "value": 8000, "stock": 3},
            {"name": "Common Ore", "type": "ore", "rarity": "common", "cost": 5000, "value": 5000, "stock": 5}
        ]
        for i, fallback_item in enumerate(fallback_items):
            fallback_item["market_id"] = f"market_fallback_{i}"
            fallback_item["description"] = f"A basic {fallback_item['rarity']} {fallback_item['type']}"
            MARKET_ITEMS.append(fallback_item)
    
    MARKET_LAST_UPDATE = current_time
    save_market()
    print(f"Generated {len(MARKET_ITEMS)} market items")

@bot.tree.command(name="market", description="Visit the daily market to buy rare items")
async def market_cmd(interaction: discord.Interaction):
    """Visit the daily market"""
    ctx = await commands.Context.from_interaction(interaction)
    user_id = ctx.author.id
    
    # Load and generate market if needed
    try:
        load_market()
        generate_daily_market()
        
        # Validate all market items to ensure they have required fields
        validate_market_items()
        
        # Debug info
        print(f"Market command - Items: {len(MARKET_ITEMS)}, Last Update: {MARKET_LAST_UPDATE}")
    
        if not MARKET_ITEMS:
            await send_embed(ctx, "Market Error", "Failed to generate market items. Please contact an administrator.", 0xe74c3c)
            return
    except Exception as e:
        print(f"Market generation error: {e}")
        await send_embed(ctx, "Market Error", f"An error occurred while generating the market: {str(e)}", 0xe74c3c)
        return
    
    # Check if we need pagination (more than 20 items)
    if len(MARKET_ITEMS) <= 20:
        # Original single page display
        embed = discord.Embed(
            title="🏪 Daily Market",
            description="Welcome to the daily market! Items change every 24 hours.",
            color=0x9b59b6
        )
        
        # Group items by rarity for better display
        items_by_rarity = {}
        for item in MARKET_ITEMS:
            try:
                # Skip invalid items
                if not isinstance(item, dict) or "name" not in item or "type" not in item:
                    print(f"Skipping invalid market item: {item}")
                    continue
                    
                rarity = item.get("rarity", "common")
                if rarity not in items_by_rarity:
                    items_by_rarity[rarity] = []
                items_by_rarity[rarity].append(item)
            except Exception as e:
                print(f"Error processing market item {item}: {e}")
                continue
        
        # Display items by rarity (sorted by rarity importance)
        rarity_order = ["divine", "mythic", "legendary", "epic", "rare", "uncommon", "common"]
        for rarity in rarity_order:
            if rarity in items_by_rarity:
                rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
                rarity_items = items_by_rarity[rarity]
                
                # Sort items within each rarity by type for consistency
                rarity_items.sort(key=lambda x: x.get("type", ""))
                
                for i, item in enumerate(rarity_items):
                    # Safely get item fields with defaults
                    stock = item.get("stock", 1)
                    cost = int(item.get("cost", 0) * 0.7)  # Make items 30% cheaper
                    
                    if item["type"] == "weapon":
                        damage = item.get("damage", 0)
                        item_text = f"{rarity_emoji} **{item['name']}**\nDamage: {damage}\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                    elif item["type"] == "armor":
                        defense = item.get("defense", 0)
                        item_text = f"{rarity_emoji} **{item['name']}**\nDefense: {defense}\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                    elif item["type"] == "artifact":
                        abilities = item.get("abilities", [])
                        abilities_text = ", ".join(abilities) if abilities else "None"
                        item_text = f"{rarity_emoji} **{item['name']}**\nAbilities: {abilities_text}\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                    elif item["type"] == "ore":
                        item_text = f"{rarity_emoji} **{item['name']}**\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                    elif item["type"] == "loot":
                        description = item.get("description", "A valuable loot item")
                        item_text = f"{rarity_emoji} **{item['name']}**\n{description}\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                    elif item["type"] == "consumable":
                        description = item.get("description", "A powerful consumable")
                        item_text = f"{rarity_emoji} **{item['name']}**\n{description}\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                    else:  # fallback
                        item_text = f"{rarity_emoji} **{item['name']}**\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                    
                    embed.add_field(name=f"{rarity.title()} - {item['type'].title()}", value=item_text, inline=False)
        
        embed.set_footer(text="Market refreshes every 24 hours • All items 30% off! • Use /market_buy <item_name> to purchase")
        await ctx.send(embed=embed)
    else:
        # Paginated display for more than 20 items
        class MarketView(discord.ui.View):
            def __init__(self, items):
                super().__init__(timeout=300)
                self.items = items
                self.current_page = 0
                self.items_per_page = 20
                self.max_pages = (len(items) - 1) // self.items_per_page + 1
            
            def get_embed(self):
                embed = discord.Embed(
                    title=f"🏪 Daily Market - Page {self.current_page + 1}/{self.max_pages}",
                    description="Welcome to the daily market! Items change every 24 hours.",
                    color=0x9b59b6
                )
                
                start_idx = self.current_page * self.items_per_page
                end_idx = min(start_idx + self.items_per_page, len(self.items))
                page_items = self.items[start_idx:end_idx]
                
                # Sort page items by rarity and type for consistency
                page_items.sort(key=lambda x: (
                    ["divine", "mythic", "legendary", "epic", "rare", "uncommon", "common"].index(x.get("rarity", "common")),
                    x.get("type", "")
                ))
                
                for item in page_items:
                    try:
                        # Skip invalid items
                        if not isinstance(item, dict) or "name" not in item or "type" not in item:
                            continue
                        
                        rarity = item.get("rarity", "common")
                        rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
                        stock = item.get("stock", 1)
                        cost = int(item.get("cost", 0) * 0.7)  # Make items 30% cheaper
                        
                        if item["type"] == "weapon":
                            damage = item.get("damage", 0)
                            item_text = f"{rarity_emoji} **{item['name']}**\nDamage: {damage}\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                        elif item["type"] == "armor":
                            defense = item.get("defense", 0)
                            item_text = f"{rarity_emoji} **{item['name']}**\nDefense: {defense}\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                        elif item["type"] == "artifact":
                            abilities = item.get("abilities", [])
                            abilities_text = ", ".join(abilities) if abilities else "None"
                            item_text = f"{rarity_emoji} **{item['name']}**\nAbilities: {abilities_text}\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                        elif item["type"] == "ore":
                            item_text = f"{rarity_emoji} **{item['name']}**\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                        elif item["type"] == "loot":
                            description = item.get("description", "A valuable loot item")
                            item_text = f"{rarity_emoji} **{item['name']}**\n{description}\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                        elif item["type"] == "consumable":
                            description = item.get("description", "A powerful consumable")
                            item_text = f"{rarity_emoji} **{item['name']}**\n{description}\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                        else:  # fallback
                            item_text = f"{rarity_emoji} **{item['name']}**\n💰 Cost: {MONEY_ICON} {cost:,}\n📦 Stock: {stock}"
                        
                        embed.add_field(name=f"{rarity.title()} - {item['type'].title()}", value=item_text, inline=False)
                    except Exception as e:
                        print(f"Error processing market item {item}: {e}")
                        continue
                
                embed.set_footer(text=f"Page {self.current_page + 1}/{self.max_pages} • Market refreshes every 24 hours • All items 30% off! • Use /market_buy <item_name> to purchase")
                return embed
            
            @discord.ui.button(label="◀️ Previous", style=discord.ButtonStyle.secondary)
            async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                if self.current_page > 0:
                    self.current_page -= 1
                    await interaction.response.edit_message(embed=self.get_embed(), view=self)
                else:
                    await interaction.response.send_message("You're already on the first page!", ephemeral=True)
            
            @discord.ui.button(label="▶️ Next", style=discord.ButtonStyle.secondary)
            async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
                if self.current_page < self.max_pages - 1:
                    self.current_page += 1
                    await interaction.response.edit_message(embed=self.get_embed(), view=self)
                else:
                    await interaction.response.send_message("You're already on the last page!", ephemeral=True)
        
        view = MarketView(MARKET_ITEMS)
        embed = view.get_embed()
        await ctx.send(embed=embed, view=view)

@bot.tree.command(name="market_buy", description="Buy an item from the market by name")
@app_commands.autocomplete(item_name=market_item_autocomplete)
async def market_buy_cmd(interaction: discord.Interaction, item_name: str):
    """Buy an item from the market by name"""
    ctx = await commands.Context.from_interaction(interaction)
    load_market()
    
    # Find item by name (case-insensitive)
    item = None
    for market_item in MARKET_ITEMS:
        if market_item["name"].lower() == item_name.lower():
            item = market_item
            break
    
    if not item:
        await send_embed(ctx, "Item Not Found", f"Could not find '{item_name}' in the market.", 0xe74c3c)
        return
    
    stock = item.get("stock", 1)
    if stock <= 0:
        await send_embed(ctx, "Out of Stock", "This item is out of stock!", 0xe74c3c)
        return
    
    user_id = ctx.author.id
    cash, bank = get_balances(user_id)
    
    # Apply 30% discount to market prices
    discounted_cost = int(item["cost"] * 0.7)
    
    if cash < discounted_cost:
        await send_embed(ctx, "Insufficient Funds", f"You need {MONEY_ICON} {discounted_cost:,} to buy this item.", 0xe74c3c)
        return
    
    # Purchase the item
    set_cash(user_id, cash - discounted_cost)

    # Apply immediate effects if present (e.g., immortal_art_reroll)
    try:
        effects = item.get("effects", {}) or {}
        reroll_amount = int(effects.get("immortal_art_reroll", 0) or 0)
        if reroll_amount > 0:
            user_meta = get_user_meta(user_id)
            if "immortal_arts" not in user_meta:
                user_meta["immortal_arts"] = {"rerolls": 0, "slots": [], "unlocked_slots": 1}
            current_rerolls = int(user_meta["immortal_arts"].get("rerolls", 0) or 0)
            user_meta["immortal_arts"]["rerolls"] = current_rerolls + reroll_amount
            set_user_meta(user_id, user_meta)
    except Exception as e:
        print(f"DEBUG: Failed applying market effects for user {user_id}: {e}")

    # Add item to user's inventory
    if item["type"] == "ore":
        add_ore_to_inventory(user_id, item["name"], 1)
    elif item["type"] in ["weapon", "armor", "artifact"]:
        add_item_to_inventory(user_id, item)
    else:
        # For loot and consumables, add to general inventory
        add_item_to_inventory(user_id, item)
    
    # Reduce stock
    item["stock"] = stock - 1
    save_market()
    
    # Build success message including reroll info if any
    reroll_suffix = ""
    try:
        if (item.get("effects") or {}).get("immortal_art_reroll"):
            reroll_suffix = f"\n🎲 Gained {int(item['effects']['immortal_art_reroll'])} Immortal Art reroll(s)."
    except Exception:
        pass
    await send_embed(ctx, "Purchase Successful", f"You bought **{item['name']}** for {MONEY_ICON} {discounted_cost:,}! (30% market discount){reroll_suffix}", 0x2ecc71)







@bot.tree.command(name="fix_market", description="Fix corrupted market items (Admin only)")
async def fix_market_cmd(interaction: discord.Interaction):
    """Fix corrupted market items (Admin only)"""
    ctx = await commands.Context.from_interaction(interaction)
    
    # Check if user is admin
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        # Load current market
        load_market()
        
        # Count items before fix
        items_before = len(MARKET_ITEMS)
        
        # Validate and fix all items
        validate_market_items()
        
        # Save fixed market
        save_market()
        
        embed = discord.Embed(title="🔧 Market Fixed!", color=0x2ecc71)
        embed.description = "Successfully validated and fixed all market items!"
        embed.add_field(name="Items Processed", value=f"{items_before} items", inline=True)
        embed.add_field(name="Status", value="All items validated", inline=True)
        embed.set_footer(text="Use /market to view the fixed items")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Market Fix Error", f"Error fixing market: {str(e)}", 0xe74c3c)

@bot.tree.command(name="market_reroll", description="Manually reroll the market items (Admin only)")
async def market_reroll_cmd(interaction: discord.Interaction):
    """Manually reroll the market items (Admin only)"""
    ctx = await commands.Context.from_interaction(interaction)
    
    # Check if user is admin
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        global MARKET_ITEMS, MARKET_LAST_UPDATE
        
        # Load current market
        load_market()
        
        # Count items before reroll
        items_before = len(MARKET_ITEMS)
        
        # Clear current market and generate new one
        MARKET_ITEMS = []
        MARKET_LAST_UPDATE = time.time()
        
        # Generate new market items
        generate_daily_market()
        
        # Validate all items
        validate_market_items()
        
        # Save new market
        save_market()
        
        embed = discord.Embed(title="🔄 Market Rerolled!", color=0x9b59b6)
        embed.description = "Successfully rerolled all market items!"
        embed.add_field(name="Items Before", value=f"{items_before} items", inline=True)
        embed.add_field(name="Items After", value=f"{len(MARKET_ITEMS)} items", inline=True)
        embed.add_field(name="New Items", value="Market has been completely refreshed with new items", inline=False)
        embed.set_footer(text="Use /market to view the new items")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Market Reroll Error", f"Error rerolling market: {str(e)}", 0xe74c3c)

@bot.command(name="clean_inventory")
@commands.has_permissions(administrator=True)
async def clean_inventory_cmd(ctx):
    """Clean up old inventory items and convert them to new format (Admin only)"""
    # Check if user is admin
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        user_id = ctx.author.id
        
        # Clean up user's inventory
        clean_user_inventory(user_id)
        
        # Get updated inventory
        meta = get_user_meta(user_id)
        inventory = meta.get("inventory", [])
        
        embed = discord.Embed(title="🧹 Inventory Cleaned!", color=0x2ecc71)
        embed.description = "Successfully cleaned up old inventory items!"
        embed.add_field(name="Items After Cleanup", value=f"{len(inventory)} items", inline=True)
        embed.set_footer(text="Use /inventory to view your cleaned inventory")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Inventory Cleanup Error", f"Error cleaning inventory: {str(e)}", 0xe74c3c)





# -----------------------
# Loan System Commands
# -----------------------

@bot.hybrid_command(name="loan_give", description="Give a loan to another user")
@app_commands.describe(
    user="The user to give the loan to",
    amount="Amount to loan",
    duration="Loan duration (e.g., 7d, 24h, 2w, 1m for days, hours, weeks, months)",
    interest_percent="Interest rate percent (e.g., 5 for 5%)",
    loan_name="Name for this loan (e.g., 'Car Loan', 'Business Loan')",
    description="Optional description for the loan"
)
async def loan_give_cmd(ctx, user: discord.Member, amount: int, duration: str, interest_percent: float, loan_name: str = "", description: str = ""):
    """Give a loan to another user with customizable terms - requires acceptance"""
    # Handle both slash commands and prefix commands
    if isinstance(ctx, discord.Interaction):
        interaction = ctx
        await interaction.response.defer(ephemeral=True)
        ctx = await commands.Context.from_interaction(interaction)
    else:
        # Prefix command - no need to defer
        pass
    
    # Parse duration string (e.g., "7d", "24h", "2w", "1m")
    def parse_duration(duration_str):
        duration_str = str(duration_str).strip().lower()
        
        # Handle numeric input (assume days)
        if duration_str.isdigit():
            return int(duration_str) * 24 * 60 * 60  # Convert days to seconds
        
        # Parse time units
        if duration_str.endswith('h'):  # Hours
            try:
                hours = int(duration_str[:-1])
                if hours < 1 or hours > 8760:  # Max 1 year in hours
                    return None
                return hours * 60 * 60
            except ValueError:
                return None
        elif duration_str.endswith('d'):  # Days
            try:
                days = int(duration_str[:-1])
                if days < 1 or days > 365:  # Max 1 year
                    return None
                return days * 24 * 60 * 60
            except ValueError:
                return None
        elif duration_str.endswith('w'):  # Weeks
            try:
                weeks = int(duration_str[:-1])
                if weeks < 1 or weeks > 52:  # Max 1 year
                    return None
                return weeks * 7 * 24 * 60 * 60
            except ValueError:
                return None
        elif duration_str.endswith('m'):  # Months (30 days)
            try:
                months = int(duration_str[:-1])
                if months < 1 or months > 12:  # Max 1 year
                    return None
                return months * 30 * 24 * 60 * 60
            except ValueError:
                return None
        else:
            return None
    
    # Parse duration
    duration_seconds = parse_duration(duration)
    if duration_seconds is None:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Invalid Duration", description="Duration format: 7d (days), 24h (hours), 2w (weeks), 1m (months). Max: 1 year.", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Invalid Duration", description="Duration format: 7d (days), 24h (hours), 2w (weeks), 1m (months). Max: 1 year.", color=0xe74c3c))
        return
    
    # Convert to days for display and calculations
    duration_days = duration_seconds // (24 * 60 * 60)
    
    # Validate inputs
    if amount < LOAN_MIN_AMOUNT:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Invalid Amount", description=f"Minimum loan amount is {MONEY_ICON} {LOAN_MIN_AMOUNT:,}", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Invalid Amount", description=f"Minimum loan amount is {MONEY_ICON} {LOAN_MIN_AMOUNT:,}", color=0xe74c3c))
        return
    
    if amount > LOAN_MAX_AMOUNT:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Invalid Amount", description=f"Maximum loan amount is {MONEY_ICON} {LOAN_MAX_AMOUNT:,}", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Invalid Amount", description=f"Maximum loan amount is {MONEY_ICON} {LOAN_MAX_AMOUNT:,}", color=0xe74c3c))
        return
    
    # Allow minimum of 1 hour (0.0417 days) for very short loans
    if duration_days < 0.0417 or duration_days > LOAN_MAX_DURATION_DAYS:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Invalid Duration", description=f"Loan duration must be between 1 hour and {LOAN_MAX_DURATION_DAYS} days", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Invalid Duration", description=f"Loan duration must be between 1 hour and {LOAN_MAX_DURATION_DAYS} days", color=0xe74c3c))
        return
    
    # Validate interest percent (0% to 500% allowed)
    try:
        interest_percent = float(interest_percent)
    except Exception:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Invalid Interest", description="Interest must be a number (e.g., 5 for 5%)", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Invalid Interest", description="Interest must be a number (e.g., 5 for 5%)", color=0xe74c3c))
        return
    if interest_percent < 0 or interest_percent > 500:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Invalid Interest", description="Interest percent must be between 0 and 500", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Invalid Interest", description="Interest percent must be between 0 and 500", color=0xe74c3c))
        return
    
    if user.id == ctx.author.id:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Invalid Target", description="You cannot loan money to yourself", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Invalid Target", description="You cannot loan money to yourself", color=0xe74c3c))
        return
    
    # Check if lender has enough money
    lender_cash, lender_bank = get_balances(ctx.author.id)
    if lender_cash < amount:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Insufficient Funds", description=f"You need {MONEY_ICON} {amount:,} in cash to give this loan", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Insufficient Funds", description=f"You need {MONEY_ICON} {amount:,} in cash to give this loan", color=0xe74c3c))
        return
    
    # Calculate interest details (percent-based)
    interest_amount = int(amount * (interest_percent / 100))
    total_to_repay = amount + interest_amount
    
    # Handle very short duration loans (less than 1 day)
    if duration_days < 1:
        daily_payment = total_to_repay  # For short loans, daily payment is the full amount
    else:
        daily_payment = int(total_to_repay / duration_days)
    
    # Create loan offer (not actual loan yet) - using simple integer timestamps
    current_timestamp = int(time.time())
    expires_timestamp = int(current_timestamp + (24 * 60 * 60))  # 24 hours to accept
    
    loan_offer = {
        "lender_id": ctx.author.id,
        "borrower_id": user.id,
        "amount": amount,
        "duration": duration_days,  # Use parsed duration in days
        "duration_original": duration,  # Store original input for display
        "interest_percent": interest_percent,
        "interest_amount": interest_amount,
        "total_to_repay": total_to_repay,
        "daily_payment": daily_payment,
        "loan_name": loan_name if loan_name else f"Loan from {ctx.author.display_name}",
        "description": description,
        "timestamp": current_timestamp,
        "expires": expires_timestamp
    }
    
    # Store loan offer temporarily with safety checks
    try:
        loan_offers_file = LOAN_OFFERS_FILE
        loan_offers = load_json(loan_offers_file) if os.path.exists(loan_offers_file) else {}
        
        # Clean up expired offers first - using simple integer timestamps
        current_timestamp = int(time.time())
        expired_offers = [offer_id for offer_id, offer in loan_offers.items() 
                          if current_timestamp > offer.get("expires", 0)]
        for expired_id in expired_offers:
            loan_offers.pop(expired_id, None)
        
        offer_id = str(uuid.uuid4())
        loan_offers[offer_id] = loan_offer
        save_json(loan_offers_file, loan_offers)
    except Exception as e:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Error", description=f"Failed to save loan offer: {str(e)}", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Error", description=f"Failed to save loan offer: {str(e)}", color=0xe74c3c))
        return
    
    # Create loan offer embed
    embed = discord.Embed(title="💰 Loan Offer", color=0xf39c12)
    embed.description = f"{ctx.author.mention} is offering a loan to {user.mention}!\n\n⚠️ **How it works:** When accepted, the borrower gets the money immediately. After 1 day, debt collection begins and all money earned goes to the lender until the debt is paid!"
    
    # Format duration display
    if duration_days < 1:
        duration_display = f"{duration} ({duration_days:.3f} days)"
        payment_display = f"{MONEY_ICON} {daily_payment:,} (full amount when due)"
    else:
        duration_display = f"{duration} ({duration_days} days)"
        payment_display = f"{MONEY_ICON} {daily_payment:,} when balance is negative"
    
    embed.add_field(name="📊 Loan Details", value=f"**Name:** {loan_offer['loan_name']}\nAmount: {MONEY_ICON} {amount:,}\nDuration: {duration_display}\nInterest Rate: {interest_percent}%", inline=True)
    embed.add_field(name="💰 Interest & Total", value=f"Interest: {MONEY_ICON} {interest_amount:,}\nTotal to Repay: {MONEY_ICON} {total_to_repay:,}", inline=True)
    embed.add_field(name="📅 Payment", value=payment_display, inline=False)
    
    if description:
        embed.add_field(name="📝 Description", value=description, inline=False)
    
    # Simple timestamp display - no conversion needed since we store as integers
    expires_timestamp = loan_offer['expires']
    embed.add_field(name="⏰ Expires", value=f"<t:{expires_timestamp}:R>", inline=False)
    embed.set_footer(text=f"Use /loan_pay <loan_name> <amount> to pay back")
    
    # Accept/reject buttons implemented via View with callbacks so it responds
    class LoanView(discord.ui.View):
        def __init__(self, offer_id: str, loan_offer: dict, ctx: commands.Context):
            super().__init__(timeout=300)
            self.offer_id = offer_id
            self.loan_offer = loan_offer
            self.ctx = ctx

        @discord.ui.button(label="✅ Accept Loan", style=discord.ButtonStyle.green)
        async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
            if interaction.user.id != self.loan_offer["borrower_id"]:
                return await interaction.response.send_message("Only the borrower can accept this offer.", ephemeral=True)
            
            # Check if offer has expired - using simple integer comparison
            current_timestamp = int(time.time())
            if current_timestamp > self.loan_offer.get("expires", 0):
                return await interaction.response.send_message("This loan offer has expired.", ephemeral=True)
            
            offers_file = LOAN_OFFERS_FILE
            offers = load_json(offers_file) if os.path.exists(offers_file) else {}
            if self.offer_id not in offers:
                return await interaction.response.send_message("This loan offer has expired or was removed.", ephemeral=True)
            lender_id = self.loan_offer["lender_id"]
            borrower_id = self.loan_offer["borrower_id"]
            amount = int(self.loan_offer["amount"]) 
            lender_cash, _ = get_balances(lender_id)
            if lender_cash < amount:
                return await interaction.response.send_message("Lender no longer has enough cash to fund this loan.", ephemeral=True)
            # Lender gives money to borrower normally
            set_cash(lender_id, lender_cash - amount)
            # Borrower gets the money normally (no negative balance yet)
            borrower_cash, borrower_bank = get_balances(borrower_id)
            set_cash(borrower_id, borrower_cash + amount)
            loan_name, loan_data = create_loan(lender_id, borrower_id, amount, int(self.loan_offer["duration"]), float(self.loan_offer.get("interest_percent", 0)), self.loan_offer.get("description", ""), self.loan_offer.get("loan_name", ""))
            offers.pop(self.offer_id, None)
            save_json(offers_file, offers)
            embed = discord.Embed(title="✅ Loan Accepted", color=0x2ecc71)
            embed.description = f"Loan funded: {MONEY_ICON} {amount:,} - You have 1 day to prepare before debt collection begins!"
            embed.add_field(name="Loan Name", value=f"`{loan_name}`", inline=False)
            embed.add_field(name="📊 Details", value=f"Amount: {MONEY_ICON} {amount:,}\nDuration: {self.loan_offer['duration']} days\nInterest: {self.loan_offer.get('interest_percent', 0)}%", inline=False)
            embed.add_field(name="⚠️ Important", value="**Day 1:** You get the money normally\n**Day 2:** The loan amount is deducted from your balance\n**After Day 2:** All money you earn goes to the lender until debt is paid", inline=False)
            await interaction.response.send_message(embed=embed)

        @discord.ui.button(label="❌ Reject Loan", style=discord.ButtonStyle.red)
        async def reject(self, interaction: discord.Interaction, button: discord.ui.Button):
            if interaction.user.id != self.loan_offer["borrower_id"]:
                return await interaction.response.send_message("Only the borrower can reject this offer.", ephemeral=True)
            offers_file = LOAN_OFFERS_FILE
            offers = load_json(offers_file) if os.path.exists(offers_file) else {}
            offers.pop(self.offer_id, None)
            save_json(offers_file, offers)
            await interaction.response.send_message("Loan offer rejected.", ephemeral=True)

    try:
        # Send a public message in the channel with buttons for the borrower
        if 'interaction' in locals():
            await interaction.channel.send(embed=embed, view=LoanView(offer_id, loan_offer, ctx))
            # And confirm to the lender ephemerally
            await interaction.followup.send(content="✅ Loan offer sent.", ephemeral=True)
        else:
            await ctx.channel.send(embed=embed, view=LoanView(offer_id, loan_offer, ctx))
            await ctx.send(content="✅ Loan offer sent.")
    except discord.Forbidden:
        if 'interaction' in locals():
            await interaction.followup.send(content="❌ I don't have permission to send messages in this channel.", ephemeral=True)
        else:
            await ctx.send(content="❌ I don't have permission to send messages in this channel.")
    except Exception as e:
        if 'interaction' in locals():
            await interaction.followup.send(content=f"❌ Failed to send loan offer: {str(e)}", ephemeral=True)
        else:
            await ctx.send(content=f"❌ Failed to send loan offer: {str(e)}")
        # Clean up the offer if sending failed
        try:
            offers_file = LOAN_OFFERS_FILE
            offers = load_json(offers_file) if os.path.exists(offers_file) else {}
            offers.pop(offer_id, None)
            save_json(offers_file, offers)
        except Exception:
            pass  # Ignore cleanup errors


@bot.hybrid_command(name="loan_pay", description="Make a payment on your loan")
@app_commands.describe(
    loan_name="The name of the loan you want to pay",
    amount="Amount to pay (or 'all' to pay full amount)"
)
@app_commands.autocomplete(loan_name=loan_name_autocomplete)
async def loan_pay_cmd(ctx, loan_name: str, amount: str):
    """Make a payment on an active loan using loan name"""
    # Handle both slash commands and prefix commands
    if isinstance(ctx, discord.Interaction):
        interaction = ctx
        await interaction.response.defer(ephemeral=True)
        ctx = await commands.Context.from_interaction(interaction)
    else:
        # Prefix command - no need to defer
        pass
    
    # Find the loan by loan name
    loans = load_loans()
    user_id = ctx.author.id
    
    # Find active loan with this name
    target_loan = None
    target_loan_name = None
    for loan_name_key, loan in loans.items():
        if (loan["borrower_id"] == user_id and 
            loan["lender_id"] != user_id and 
            loan["status"] == "active" and
            loan_name_key.lower() == loan_name.lower()):
            
            target_loan = loan
            target_loan_name = loan_name_key
            break
    
    if not target_loan:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Loan Not Found", description=f"No active loan found with name '{loan_name}'", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Loan Not Found", description=f"No active loan found with name '{loan_name}'", color=0xe74c3c))
        return
    
    loan = target_loan
    
    if loan["status"] != "active":
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Loan Not Active", description=f"This loan is {loan['status']}", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Loan Not Active", description=f"This loan is {loan['status']}", color=0xe74c3c))
        return
    
    # Calculate payment amount
    remaining_debt = loan["total_to_repay"] - loan["amount_paid"]
    
    # Parse amount using the enhanced parser that supports shortened formats
    payment_amount = parse_amount_arg(amount, remaining_debt)
    if payment_amount is None or payment_amount <= 0:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Invalid Amount", description="Please provide a valid amount (number, 'all', 'half', '1k', '1m', '1b', etc.)", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Invalid Amount", description="Please provide a valid amount (number, 'all', 'half', '1k', '1m', '1b', etc.)", color=0xe74c3c))
        return
    
    if payment_amount > remaining_debt:
        payment_amount = remaining_debt
    
    # Check if user has enough money
    user_cash, user_bank = get_balances(ctx.author.id)
    if user_cash < payment_amount:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Insufficient Funds", description=f"You need {MONEY_ICON} {payment_amount:,} in cash to make this payment", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Insufficient Funds", description=f"You need {MONEY_ICON} {payment_amount:,} in cash to make this payment", color=0xe74c3c))
        return
    
    try:
        # Process payment directly without using process_loan_payment function
        # Update the loan amount paid
        loan["amount_paid"] += payment_amount
        
        # Check if loan is fully repaid
        if loan["amount_paid"] >= loan["total_to_repay"]:
            loan["status"] = "repaid"
            loan["amount_paid"] = loan["total_to_repay"]  # Ensure exact amount
        
        # Save the updated loan
        loans[target_loan_name] = loan
        save_loans(loans)
        
        # Transfer money from borrower to lender
        set_cash(ctx.author.id, user_cash - payment_amount)
        add_cash(loan["lender_id"], payment_amount)
        
        # Get updated loan info
        new_remaining = loan["total_to_repay"] - loan["amount_paid"]
        
        embed = discord.Embed(title="💰 Loan Payment", color=0x2ecc71)
        embed.description = f"Successfully paid {MONEY_ICON} {payment_amount:,} on your loan!"
        
        embed.add_field(name="📊 Payment Details", value=f"Amount Paid: {MONEY_ICON} {payment_amount:,}\nRemaining Debt: {MONEY_ICON} {new_remaining:,}", inline=True)
        
        if loan["status"] == "repaid":
            embed.add_field(name="🎉 Loan Status", value="**FULLY REPAID!**", inline=True)
            embed.color = 0x00ff00
        else:
            # Safe timestamp display for loan due date
            try:
                due_timestamp = int(loan['due_date'])
                embed.add_field(name="📅 Next Due", value=f"<t:{due_timestamp}:R>", inline=True)
            except (ValueError, TypeError):
                embed.add_field(name="📅 Next Due", value="Soon", inline=True)
        
        embed.set_footer(text=f"Loan '{target_loan_name}' successfully updated")
        if 'interaction' in locals():
            await interaction.followup.send(embed=embed, ephemeral=True)
        else:
            await ctx.send(embed=embed)
        
    except Exception as e:
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Payment Error", description=f"Error processing payment: {str(e)}", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Payment Error", description=f"Error processing payment: {str(e)}", color=0xe74c3c))





@bot.hybrid_command(name="loan_status", description="View your loan status and summary")
async def loan_status_cmd(ctx):
    """View your loan status and summary"""
    # Handle both slash commands and prefix commands
    if isinstance(ctx, discord.Interaction):
        interaction = ctx
        await interaction.response.defer(ephemeral=True)
        ctx = await commands.Context.from_interaction(interaction)
    else:
        # Prefix command - no need to defer
        pass
    
    try:
        user_id = ctx.author.id
        print(f"DEBUG: Loan status called for user {user_id}")
        
        # Load loans data
        loans = load_loans()
        print(f"DEBUG: Loaded {len(loans)} total loans")
        
        if not loans:
            if 'interaction' in locals():
                await interaction.followup.send(embed=discord.Embed(title="No Loans", description="No loans exist in the system yet.", color=0x95a5a6), ephemeral=True)
            else:
                await ctx.send(embed=discord.Embed(title="No Loans", description="No loans exist in the system yet.", color=0x95a5a6))
            return
        
        # Get user's loans
        user_loans = get_user_loans(user_id)
        print(f"DEBUG: User {user_id} has {len(user_loans['borrowed'])} borrowed and {len(user_loans['lent'])} lent loans")
        
        # Get summary
        summary = get_loan_summary(user_id)
        print(f"DEBUG: Summary: {summary}")
        
        embed = discord.Embed(title="💰 Loan Status", color=0x3498db)
        
        # Summary section
        embed.add_field(name="📊 Overall Summary", value=f"Total Borrowed: {MONEY_ICON} {summary['total_borrowed']:,}\nTotal Lent: {MONEY_ICON} {summary['total_lent']:,}\nNet Position: {MONEY_ICON} {summary['net_position']:,}", inline=False)
        
        # Active loans section
        if user_loans["borrowed"] or user_loans["lent"]:
            borrowed_text = ""
            lent_text = ""
            
            for loan_name in user_loans["borrowed"][:5]:  # Show first 5
                if loan_name not in loans:
                    print(f"DEBUG: Warning: loan {loan_name} not found in loans data")
                    continue
                    
                loan = loans[loan_name]
                lender = ctx.guild.get_member(loan["lender_id"])
                lender_name = lender.display_name if lender else f"User {loan['lender_id']}"
                
                if loan["status"] == "active":
                    remaining = loan["total_to_repay"] - loan["amount_paid"]
                    borrowed_text += f"• {MONEY_ICON} {remaining:,} remaining from {lender_name} (`{loan_name}`)\n"
                else:
                    status_emoji = "✅" if loan["status"] == "repaid" else "❌"
                    borrowed_text += f"• {status_emoji} {loan['status'].title()} from {lender_name} (`{loan_name}`)\n"
            
            for loan_name in user_loans["lent"][:5]:  # Show first 5
                if loan_name not in loans:
                    print(f"DEBUG: Warning: loan {loan_name} not found in loans data")
                    continue
                    
                loan = loans[loan_name]
                borrower = ctx.guild.get_member(loan["borrower_id"])
                borrower_name = borrower.display_name if borrower else f"User {loan['borrower_id']}"
                
                if loan["status"] == "active":
                    remaining = loan["total_to_repay"] - loan["amount_paid"]
                    lent_text += f"• {MONEY_ICON} {remaining:,} remaining to {borrower_name} (`{loan_name}`)\n"
                else:
                    status_emoji = "✅" if loan["status"] == "repaid" else "❌"
                    lent_text += f"• {status_emoji} {loan['status'].title()} to {borrower_name} (`{loan_name}`)\n"
            
            if borrowed_text:
                embed.add_field(name="📥 Active Borrowed Loans", value=borrowed_text, inline=False)
            if lent_text:
                embed.add_field(name="📤 Active Lent Loans", value=lent_text, inline=False)
        else:
            embed.add_field(name="📋 Loans", value="No active loans", inline=False)
        
        embed.set_footer(text="Use /loan_list to see all your loans")
        if 'interaction' in locals():
            await interaction.followup.send(embed=embed, ephemeral=True)
        else:
            await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"ERROR in loan_status_cmd: {e}")
        import traceback
        traceback.print_exc()
        if 'interaction' in locals():
            await interaction.followup.send(embed=discord.Embed(title="Loan Status Error", description=f"Error getting loan status: {str(e)}", color=0xe74c3c), ephemeral=True)
        else:
            await ctx.send(embed=discord.Embed(title="Loan Status Error", description=f"Error getting loan status: {str(e)}", color=0xe74c3c))


# Removed debug_loans command to reduce command count

# Removed create_test_loan command to reduce command count





@bot.hybrid_command(name="loan_details", description="View detailed information about a specific loan")
@app_commands.describe(loan_name="The name of the loan you want to view")
@app_commands.autocomplete(loan_name=loan_name_autocomplete)
async def loan_details_cmd(ctx, loan_name: str):
    """View detailed information about a specific loan using loan name"""
    # Handle both slash commands and prefix commands
    if isinstance(ctx, discord.Interaction):
        interaction = ctx
        await interaction.response.defer(ephemeral=True)
        ctx = await commands.Context.from_interaction(interaction)
    else:
        # Prefix command - no need to defer
        pass
    
    # Find the loan by loan name
    loans = load_loans()
    user_id = ctx.author.id
    
    # Find loan with this name
    target_loan = None
    target_loan_name = None
    for loan_name_key, loan in loans.items():
        if (loan["borrower_id"] == user_id and 
            loan["lender_id"] != user_id and
            loan_name_key.lower() == loan_name.lower()):
            
            target_loan = loan
            target_loan_name = loan_name_key
            break
    
    if not target_loan:
        await interaction.followup.send(embed=discord.Embed(title="Loan Not Found", description=f"No loan found with name '{loan_name}'", color=0xe74c3c), ephemeral=True)
        return
    
    loan = target_loan
    loan_name = target_loan_name
    
    try:
        # Get user mentions
        lender = ctx.guild.get_member(loan["lender_id"])
        borrower = ctx.guild.get_member(loan["borrower_id"])
        
        lender_name = lender.display_name if lender else f"User {loan['lender_id']}"
        borrower_name = borrower.display_name if borrower else f"User {loan['borrower_id']}"
        
        # Calculate remaining debt
        remaining_debt = loan["total_to_repay"] - loan["amount_paid"]
        
        # Determine color based on status
        if loan["status"] == "repaid":
            color = 0x00ff00  # Green
        elif loan["status"] == "defaulted":
            color = 0xff0000  # Red
        else:
            color = 0x3498db  # Blue
        
        embed = discord.Embed(title="💰 Loan Details", color=color)
        
        # Basic info
        embed.add_field(name="📋 Loan Name", value=f"`{loan_name}`", inline=False)
        embed.add_field(name="👤 Lender", value=lender_name, inline=True)
        embed.add_field(name="👤 Borrower", value=borrower_name, inline=True)
        
        # Financial details
        embed.add_field(name="💰 Amount", value=f"{MONEY_ICON} {loan['amount']:,}", inline=True)
        embed.add_field(name="📈 Interest Rate", value=f"{loan.get('interest_percent', 0):.0f}%", inline=True)
        embed.add_field(name="💸 Interest Amount", value=f"{MONEY_ICON} {loan['interest_amount']:,}", inline=True)
        
        # Payment info
        embed.add_field(name="💳 Total to Repay", value=f"{MONEY_ICON} {loan['total_to_repay']:,}", inline=True)
        embed.add_field(name="💳 Amount Paid", value=f"{MONEY_ICON} {loan['amount_paid']:,}", inline=True)
        embed.add_field(name="💳 Remaining Debt", value=f"{MONEY_ICON} {remaining_debt:,}", inline=True)
        
        # Dates and status - safe timestamp display
        try:
            created_timestamp = int(loan['created_at'])
            embed.add_field(name="📅 Created", value=f"<t:{created_timestamp}:R>", inline=True)
        except (ValueError, TypeError):
            embed.add_field(name="📅 Created", value="Unknown", inline=True)
        
        try:
            due_timestamp = int(loan['due_date'])
            embed.add_field(name="📅 Due Date", value=f"<t:{due_timestamp}:R>", inline=True)
        except (ValueError, TypeError):
            embed.add_field(name="📅 Due Date", value="Unknown", inline=True)
        embed.add_field(name="📊 Status", value=loan["status"].title(), inline=True)
        
        if loan["description"]:
            embed.add_field(name="📝 Description", value=loan["description"], inline=False)
        
        if loan["status"] == "active":
            embed.add_field(name="⚠️ Daily Collection", value=f"{MONEY_ICON} {loan['daily_payment']:,} when balance is negative", inline=False)
        
        embed.set_footer(text=f"Loan '{loan_name}' details")
        await ctx.send(embed=embed)
        
    except Exception as e:
        await interaction.followup.send(embed=discord.Embed(title="Loan Details Error", description=f"Error getting loan details: {str(e)}", color=0xe74c3c), ephemeral=True)

@bot.hybrid_command(name="loan_list", description="List all your loans (borrowed and lent)")
async def loan_list_cmd(ctx):
    """List all your loans with names instead of IDs"""
    # Handle both slash commands and prefix commands
    interaction = None
    if isinstance(ctx, discord.Interaction):
        interaction = ctx
        await interaction.response.defer(ephemeral=True)
        ctx = await commands.Context.from_interaction(interaction)
    
    try:
        user_id = ctx.author.id
        print(f"DEBUG: Loan list called for user {user_id}")
        
        # Load loans data
        loans = load_loans()
        print(f"DEBUG: Loaded {len(loans)} total loans")
        
        if not loans:
            if interaction:
                await interaction.followup.send(embed=discord.Embed(title="No Loans", description="No loans exist in the system yet.", color=0x95a5a6), ephemeral=True)
            else:
                await ctx.send(embed=discord.Embed(title="No Loans", description="No loans exist in the system yet.", color=0x95a5a6))
            return
        
        # Get user's loans
        user_loans = get_user_loans(user_id)
        print(f"DEBUG: User {user_id} has {len(user_loans['borrowed'])} borrowed and {len(user_loans['lent'])} lent loans")
        
        if not user_loans["borrowed"] and not user_loans["lent"]:
            if interaction:
                await interaction.followup.send(embed=discord.Embed(title="No Loans", description="You have no loans (borrowed or lent).", color=0x95a5a6), ephemeral=True)
            else:
                await ctx.send(embed=discord.Embed(title="No Loans", description="You have no loans (borrowed or lent).", color=0x95a5a6))
            return
        
        embed = discord.Embed(title="💰 Your Loans", color=0x3498db)
        
        # Borrowed loans (show lender name first)
        if user_loans["borrowed"]:
            borrowed_text = ""
            for loan_name in user_loans["borrowed"][:10]:  # Show first 10
                if loan_name not in loans:
                    print(f"DEBUG: Warning: loan {loan_name} not found in loans data")
                    continue
                    
                loan = loans[loan_name]
                lender = ctx.guild.get_member(loan["lender_id"])
                lender_name = lender.display_name if lender else f"User {loan['lender_id']}"
                
                remaining = loan["total_to_repay"] - loan["amount_paid"]
                status_emoji = "🟢" if loan["status"] == "active" else "✅" if loan["status"] == "repaid" else "❌"
                
                borrowed_text += f"{status_emoji} **{MONEY_ICON} {remaining:,}** remaining\n"
                borrowed_text += f"   **From:** {lender_name}\n"
                borrowed_text += f"   **Loan:** `{loan_name}`\n"
                # Safe timestamp display for due date
                try:
                    due_timestamp = int(loan['due_date'])
                    borrowed_text += f"   **Due:** <t:{due_timestamp}:R>\n"
                except (ValueError, TypeError):
                    borrowed_text += f"   **Due:** Unknown\n"
                borrowed_text += f"   **Status:** {loan['status'].title()}\n\n"
            
            if borrowed_text:
                embed.add_field(name="📥 Borrowed Loans", value=borrowed_text, inline=False)
        
        # Lent loans (show borrower name first)
        if user_loans["lent"]:
            lent_text = ""
            for loan_name in user_loans["lent"][:10]:  # Show first 10
                if loan_name not in loans:
                    print(f"DEBUG: Warning: loan {loan_name} not found in loans data")
                    continue
                    
                loan = loans[loan_name]
                borrower = ctx.guild.get_member(loan["borrower_id"])
                borrower_name = borrower.display_name if borrower else f"User {loan['borrower_id']}"
                
                remaining = loan["total_to_repay"] - loan["amount_paid"]
                status_emoji = "🟢" if loan["status"] == "active" else "✅" if loan["status"] == "repaid" else "❌"
                
                lent_text += f"{status_emoji} **{MONEY_ICON} {remaining:,}** remaining\n"
                lent_text += f"   **To:** {borrower_name}\n"
                lent_text += f"   **Loan:** `{loan_name}`\n"
                # Safe timestamp display for due date
                try:
                    due_timestamp = int(loan['due_date'])
                    lent_text += f"   **Due:** <t:{due_timestamp}:R>\n"
                except (ValueError, TypeError):
                    lent_text += f"   **Due:** Unknown\n"
                lent_text += f"   **Status:** {loan['status'].title()}\n\n"
            
            if lent_text:
                embed.add_field(name="📤 Lent Loans", value=lent_text, inline=False)
        
        embed.set_footer(text="Use /loan_pay <loan_name> <amount> to pay back loans")
        
        if interaction:
            await interaction.followup.send(embed=embed, ephemeral=True)
        else:
            await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"ERROR in loan_list_cmd: {e}")
        import traceback
        traceback.print_exc()
        error_embed = discord.Embed(title="Loan List Error", description=f"Error listing loans: {str(e)}", color=0xe74c3c)
        if interaction:
            await interaction.followup.send(embed=error_embed, ephemeral=True)
        else:
            await ctx.send(embed=error_embed)


@bot.command(name="collect_debt")
@commands.has_permissions(administrator=True)
async def collect_debt_cmd(ctx):
    """Manually trigger debt collection for all active loans (Admin only)"""
    # Check if user is admin
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        loans_before = load_loans()
        active_before = len([loan for loan in loans_before.values() if loan["status"] == "active"])
        
        # Collect debt
        collect_debt_daily()
        
        loans_after = load_loans()
        active_after = len([loan for loan in loans_after.values() if loan["status"] == "active"])
        repaid_count = len([loan for loan in loans_after.values() if loan["status"] == "repaid"])
        defaulted_count = len([loan for loan in loans_after.values() if loan["status"] == "defaulted"])
        
        embed = discord.Embed(title="💰 Debt Collection", color=0x2ecc71)
        embed.description = "Successfully processed debt collection!"
        
        embed.add_field(name="📊 Results", value=f"Active Loans: {active_before} → {active_after}\nRepaid: {repaid_count}\nDefaulted: {defaulted_count}", inline=False)
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Debt Collection Error", f"Error collecting debt: {str(e)}", 0xe74c3c)





# -----------------------
# Mining System
# -----------------------

@bot.hybrid_command(name="ore_check", description="Check your ore inventory and status")
async def ore_check(ctx):
    """Check your ore inventory and status"""
    user_id = ctx.author.id
    meta = get_user_meta(user_id)
    inventory = meta.get("inventory", [])
    
    # Count ores by rarity
    ore_counts = {}
    total_ores = 0
    old_format_ores = 0
    
    for item in inventory:
        if isinstance(item, str) and "Ore" in item:
            # Old format ore
            old_format_ores += 1
            total_ores += 1
        elif isinstance(item, dict) and item.get("type") == "ore":
            # New format ore
            rarity = item.get("rarity", "unknown")
            if rarity not in ore_counts:
                ore_counts[rarity] = 0
            ore_counts[rarity] += 1
            total_ores += 1
    
    embed = discord.Embed(title="⛏️ Ore Inventory Status", color=0x8B4513)
    
    if total_ores == 0:
        embed.description = "You don't have any ore. Use `/mine` to get some!"
    else:
        embed.description = f"You have **{total_ores}** total ore(s)"
        
        if old_format_ores > 0:
            embed.add_field(name="⚠️ Old Format Ores", 
                          value=f"You have {old_format_ores} ore(s) in the old format.\n"
                                f"Use the blacksmith command to convert them automatically!", 
                          inline=False)
        
        if ore_counts:
            for rarity, count in sorted(ore_counts.items(), key=lambda x: ["common", "uncommon", "rare", "legendary", "mythic", "divine"].index(x[0])):
                rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
                embed.add_field(name=f"{rarity_emoji} {rarity.title()}", value=f"{count} ore(s)", inline=True)
    
    embed.add_field(name="💡 Tip", value="Use `/blacksmith <type> <rarity>` to craft items with your ore!", inline=False)
    embed.set_footer(text="Ore requirements: Weapons(1), Armor(2), Artifacts(3)")
    
    await ctx.send(embed=embed)


@bot.hybrid_command(name="mine", description="Mine for ores and materials")
async def mine(ctx):
    """Mine for ores and materials"""
    user_id = ctx.author.id
    
    # Check cooldown (5 minutes)
    cooldown_key = f"mine_{user_id}"
    if cooldown_key in COOLDOWNS:
        remaining = COOLDOWNS[cooldown_key] - time.time()
        if remaining > 0:
            minutes = int(remaining // 60)
            seconds = int(remaining % 60)
            return await send_embed(ctx, "⏳ Mining Cooldown", f"You must wait {minutes}m {seconds}s before mining again.", 0xe74c3c)
    
    # Get user meta for basic mining
    meta = get_user_meta(user_id)
    
    # Basic mining rewards (rig system disabled)
    base_ore_count = 1  # Always 1 ore
    quality_bonus = 0.0  # No quality bonus
    luck_bonus = 0.0  # No luck bonus
    
    # Generate ores
    ores_found = []
    for _ in range(base_ore_count):
        # Weighted random selection based on rarity
        total_weight = sum(ORE_RARITY_WEIGHTS.values())
        rand = random.random() * total_weight
        
        current_weight = 0
        selected_rarity = "common"
        for rarity, weight in ORE_RARITY_WEIGHTS.items():
            current_weight += weight
            if rand <= current_weight:
                selected_rarity = rarity
                break
        
        # Apply quality bonus (higher quality rig = better rarity chance)
        if random.random() < quality_bonus:
            # Upgrade rarity but make mythic+ extremely rare
            rarity_order = ["common", "uncommon", "rare", "legendary", "mythic", "divine"]
            current_index = rarity_order.index(selected_rarity)
            if current_index < len(rarity_order) - 1:
                # Make mythic+ upgrades extremely rare
                if selected_rarity in ["legendary", "mythic"]:
                    if random.random() < 0.001:  # 0.1% chance for mythic+
                        selected_rarity = rarity_order[current_index + 1]
                else:
                    selected_rarity = rarity_order[current_index + 1]
        
        # Apply luck bonus (higher luck = more ores)
        if random.random() < luck_bonus:
            # Find another ore of the same rarity
            ore_name = random.choice(ORE_TYPES[selected_rarity])
            ores_found.append({"name": ore_name, "rarity": selected_rarity})
        
        # Add the main ore
        ore_name = random.choice(ORE_TYPES[selected_rarity])
        ores_found.append({"name": ore_name, "rarity": selected_rarity})
    
    # Add to inventory
    inventory = meta.get("inventory", [])
    for ore in ores_found:
        # Create proper ore item with type and rarity
        ore_item = {
            "name": ore["name"],
            "type": "ore",
            "rarity": ore["rarity"],
            "mined_at": datetime.now(timezone.utc).isoformat()
        }
        inventory.append(ore_item)
    meta["inventory"] = inventory
    set_user_meta(user_id, meta)
    
    # Set cooldown
    COOLDOWNS[cooldown_key] = time.time() + 300  # 5 minutes
    
    # Update quest progress
    try:
        check_quest_progress(user_id, "mine", 1)
    except Exception as e:
        print(f"DEBUG: Error updating quest progress: {e}")
    
    # Create embed
    embed = discord.Embed(title="⛏️ Mining Results", color=0x8B4513)
    embed.description = f"You mined {len(ores_found)} ores!"
    
    # Group ores by rarity
    ores_by_rarity = {}
    for ore in ores_found:
        rarity = ore["rarity"]
        if rarity not in ores_by_rarity:
            ores_by_rarity[rarity] = []
        ores_by_rarity[rarity].append(ore["name"])
    
    for rarity, ores in ores_by_rarity.items():
        rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
        embed.add_field(
            name=f"{rarity_emoji} {rarity.title()} Ores",
            value="\n".join(ores),
            inline=True
        )
    
    # Basic mining info
    
    await ctx.send(embed=embed)




# -----------------------
# Blacksmith Commands
# -----------------------

@bot.hybrid_command(name="blacksmith", description="Visit the blacksmith to craft weapons, armor, and artifacts")
@app_commands.autocomplete(item_type=craft_type_autocomplete, rarity=rarity_autocomplete, weapon_type=weapon_type_autocomplete, armor_type=armor_type_autocomplete, artifact_type=artifact_type_autocomplete)
async def blacksmith(ctx, item_type: str = None, rarity: str = None, weapon_type: str = None, armor_type: str = None, artifact_type: str = None):
    """Visit the blacksmith to craft all types of equipment"""
    
    # If no arguments provided, show the blacksmith menu
    if item_type is None or rarity is None:
        embed = discord.Embed(
            title="⚒️ Blacksmith's Forge",
            description="Welcome to the blacksmith! Here you can craft weapons, armor, and artifacts.",
            color=0x8B4513
        )
        
        embed.add_field(
            name="🔨 Available Crafting",
            value="**Weapons:** Sword, Axe, Dagger, Staff, Bow, Spear, Hammer, Whip\n"
                  "**Armor:** Leather, Chainmail, Plate, Robe, Scale, Bone\n"
                  "**Artifacts:** Rings, Amulets, Crystals, Relics",
            inline=False
        )
        
        embed.add_field(
            name="💰 Crafting Costs",
            value="**Common:** {MONEY_ICON} 1,000\n"
                  "**Uncommon:** {MONEY_ICON} 5,000\n"
                  "**Rare:** {MONEY_ICON} 50,000\n"
                  "**Epic:** {MONEY_ICON} 200,000\n"
                  "**Legendary:** {MONEY_ICON} 1,000,000\n"
                  "**Mythic:** {MONEY_ICON} 10,000,000\n"
                  "**Divine:** {MONEY_ICON} 100,000,000",
            inline=False
        )
        
        embed.add_field(
            name="⛏️ Ore Requirements",
            value="**Weapons:** 1 ore of same rarity\n**Armor:** 2 ores of same rarity\n**Artifacts:** 3 ores of same rarity",
            inline=False
        )
        
        embed.add_field(
            name="📋 Crafting Command",
            value="`/blacksmith <type> <rarity> [specific_type]` - Craft any item type\n"
                  "**Types:** weapon, armor, artifact\n"
                  "**Specific Types:** sword, axe, dagger, staff, bow, spear, hammer, whip (weapons)\n"
                  "**Specific Types:** leather, chainmail, plate, robe, scale, bone (armor)\n"
                  "**Specific Types:** ring, amulet, crystal, scroll, orb, talisman (artifacts)\n"
                  "**Rarities:** common, uncommon, rare, epic, legendary, mythic, divine",
            inline=False
        )
        

        
        embed.add_field(
            name="🎯 Item Stats",
            value="**Weapons:** Damage based on rarity\n"
                  "**Armor:** Health based on rarity\n"
                  "**Artifacts:** Special abilities (damage, defense, health, critical)",
            inline=False
        )
        
        embed.set_footer(text="Higher rarity items have better stats and special abilities • Ore requirements: Weapons(1), Armor(2), Artifacts(3)")
        await ctx.send(embed=embed)
        return
    
    # If arguments provided, proceed with crafting
    user_id = ctx.author.id
    

    
    # Validate item type
    if item_type.lower() not in ["weapon", "armor", "artifact"]:
        await send_embed(ctx, "Invalid Item Type", "Available types: weapon, armor, artifact", 0xe74c3c)
        return
    
    # Validate rarity
    if rarity.lower() not in ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]:
        await send_embed(ctx, "Invalid Rarity", "Available rarities: common, uncommon, rare, epic, legendary, mythic, divine", 0xe74c3c)
        return
    
    # Calculate cost based on rarity - UPDATED according to new requirements
    rarity_costs = {
        "common": 1000,
        "uncommon": 5000,
        "rare": 50000,
        "epic": 200000,
        "legendary": 1000000,
        "mythic": 10000000,
        "divine": 100000000
    }
    cost = rarity_costs[rarity.lower()]
    
    # Check if user has enough money
    cash, bank = get_balances(user_id)
    if cash < cost:
        await send_embed(ctx, "Insufficient Funds", f"You need {MONEY_ICON} {cost:,} to craft this {item_type}.", 0xe74c3c)
        return
    
    # Check ore requirements based on item type
    meta = get_user_meta(user_id)
    inventory = meta.get("inventory", [])
    
    # Determine ore requirement based on item type
    ore_requirement = 1 if item_type.lower() == "weapon" else (2 if item_type.lower() == "armor" else 3)
    
    # Find ores of the required rarity
    required_ores = []
    
    # Clean up any old ore items that are just strings
    inventory_cleaned = []
    for item in inventory:
        if isinstance(item, str) and "Ore" in item:
            # Convert old string ore items to proper ore objects
            # Try to determine rarity from the ore name
            ore_rarity = "common"  # Default
            for rarity_name, ore_names in ORE_TYPES.items():
                if item in ore_names:
                    ore_rarity = rarity_name
                    break
            
            ore_item = {
                "name": item,
                "type": "ore",
                "rarity": ore_rarity,
                "converted": True
            }
            inventory_cleaned.append(ore_item)
        else:
            inventory_cleaned.append(item)
    
    # Update inventory if we cleaned up any items
    converted_count = 0
    for item in inventory_cleaned:
        if isinstance(item, dict) and item.get("converted"):
            converted_count += 1
    
    if len(inventory_cleaned) != len(inventory):
        meta["inventory"] = inventory_cleaned
        set_user_meta(user_id, meta)
        inventory = inventory_cleaned
        
        if converted_count > 0:
            await send_embed(ctx, "🔄 Ore Items Converted", 
                            f"Converted {converted_count} old ore items to the new format.\n"
                            f"Your ore items are now properly recognized by the blacksmith!", 0x2ecc71)
            return  # Let them try the command again
    
    # Now find ores of the required rarity and count total available (including stacked amounts)
    # Count ALL ores of the same rarity, not just ores with the same name
    total_available_ores = 0
    required_ores = []
    
    print(f"DEBUG: Checking inventory for {rarity} ores. Total inventory items: {len(inventory)}")
    
    for item in inventory:
        if isinstance(item, dict) and item.get("type") == "ore" and item.get("rarity") == rarity.lower():
            # Count the actual amount available (handle stacked ores)
            item_amount = item.get("amount", 1)
            total_available_ores += item_amount
            required_ores.append(item)
            print(f"DEBUG: Found {rarity} ore: {item.get('name', 'Unknown')} with amount {item_amount}")
    
    print(f"DEBUG: Total {rarity} ores available: {total_available_ores}")
    print(f"DEBUG: Ore requirement: {ore_requirement}")
    
    if total_available_ores < ore_requirement:
        # Count total ores of any rarity to help debug
        total_ores = sum(1 for item in inventory if isinstance(item, dict) and item.get("type") == "ore")
        await send_embed(ctx, "Insufficient Ores", 
                        f"You need {ore_requirement} {rarity.title()} ore(s) to craft this {item_type}.\n"
                        f"You have {total_available_ores} {rarity.title()} ore(s) available (any {rarity.title()} ore counts, including stacked amounts) and {total_ores} total ore items.\n"
                        f"Use `/mine` to get more ore or check your inventory with `/inventory`.", 0xe74c3c)
        return
    
    # Remove required ores from inventory (handle stacked ores properly)
    # Remove ANY ores of the same rarity, not just specific names
    print(f"DEBUG: Starting ore removal. Need {ore_requirement} {rarity} ores")
    print(f"DEBUG: Inventory before removal: {len(inventory)} items")
    
    # Show inventory contents before removal
    print("DEBUG: Inventory contents before removal:")
    for i, item in enumerate(inventory):
        if isinstance(item, dict) and item.get("type") == "ore":
            print(f"  [{i}] {item.get('name', 'Unknown')} ({item.get('rarity', 'Unknown')}) - Amount: {item.get('amount', 1)}")
    
    ores_removed = 0
    remaining_requirement = ore_requirement
    
    # Process ores in reverse order to avoid index issues
    for i in range(len(inventory) - 1, -1, -1):
        if remaining_requirement <= 0:
            break
            
        item = inventory[i]
        if isinstance(item, dict) and item.get("type") == "ore" and item.get("rarity") == rarity.lower():
            item_amount = item.get("amount", 1)
            
            if item_amount <= remaining_requirement:
                # This item has enough or more than needed
                if item_amount == remaining_requirement:
                    # Exact amount needed, remove the entire item
                    print(f"DEBUG: Removing entire ore item at index {i}: {item} (amount: {item_amount})")
                    inventory.pop(i)
                    ores_removed += item_amount
                    remaining_requirement = 0
                else:
                    # More than needed, reduce the amount
                    print(f"DEBUG: Reducing ore item at index {i} from {item_amount} to {item_amount - remaining_requirement}")
                    item["amount"] = item_amount - remaining_requirement
                    ores_removed += remaining_requirement
                    remaining_requirement = 0
            else:
                # This item has less than needed, remove it entirely and continue
                print(f"DEBUG: Removing ore item at index {i}: {item} (amount: {item_amount})")
                inventory.pop(i)
                ores_removed += item_amount
                remaining_requirement -= item_amount
    
    print(f"DEBUG: Ore removal complete. Removed {ores_removed} ores")
    print(f"DEBUG: Inventory after removal: {len(inventory)} items")
    
    # Show inventory contents after removal
    print("DEBUG: Inventory contents after removal:")
    for i, item in enumerate(inventory):
        if isinstance(item, dict) and item.get("type") == "ore":
            print(f"  [{i}] {item.get('name', 'Unknown')} ({item.get('rarity', 'Unknown')}) - Amount: {item.get('amount', 1)}")
    
    # Verify ores were removed
    if ores_removed < ore_requirement:
        await send_embed(ctx, "Crafting Error", f"Failed to remove required ores. Expected: {ore_requirement}, Removed: {ores_removed}", 0xe74c3c)
        return
    
    # IMPORTANT: Save the updated inventory after ore removal
    meta["inventory"] = inventory
    set_user_meta(user_id, meta)
    
    # Verify the save worked by reloading the meta
    meta_verify = get_user_meta(user_id)
    inventory_verify = meta_verify.get("inventory", [])
    print(f"DEBUG: Inventory verification - Length: {len(inventory_verify)}, Expected: {len(inventory)}")
    
    # Deduct money
    set_cash(user_id, cash - cost)
    
    # Generate item based on type and rarity
    if item_type.lower() == "weapon":
        # Use specific weapon type if provided, otherwise random
        if weapon_type and weapon_type.lower() in WEAPON_TYPES:
            selected_weapon_type = weapon_type.lower()
        else:
            selected_weapon_type = random.choice(list(WEAPON_TYPES.keys()))
        
        # Generate weapon stats using the new balanced system - BUFFED EPIC+ WEAPONS
        if rarity.lower() == "common":
            damage = random.randint(1, 3)
        elif rarity.lower() == "uncommon":
            damage = random.randint(3, 5)
        elif rarity.lower() == "rare":
            damage = random.randint(5, 10)
        elif rarity.lower() == "epic":
            damage = random.randint(12, 16)  # BUFFED: was 10-13
        elif rarity.lower() == "legendary":
            damage = random.randint(18, 25)  # BUFFED: was 15-20
        elif rarity.lower() == "mythic":
            damage = random.randint(25, 50)  # BUFFED: was 20-40
        elif rarity.lower() == "divine":
            damage = random.randint(60, 120)  # BUFFED: was 50-100
        else:
            damage = random.randint(1, 3)  # fallback
        
        # Generate weapon name based on type and rarity
        weapon_emoji = WEAPON_TYPES[selected_weapon_type]["emoji"]
        name = f"{rarity.title()} {selected_weapon_type.title()}"
        
        # Use new direct pricing system for crafted weapons
        weapon_sell_prices = {
            "common": 1200, "uncommon": 5600, "rare": 60000, "epic": 240000,
            "legendary": 2000000, "mythic": random.randint(20000000, 50000000),
            "divine": 400000000, "primordial": 1000000000
        }
        final_value = weapon_sell_prices.get(rarity.lower(), 1200)
        
        # Apply randomization based on rarity
        if rarity.lower() in ["legendary", "mythic", "divine", "primordial"]:
            random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
            final_value = int(final_value * random_factor)
        else:
            random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
            final_value = int(final_value * random_factor)
        
        crafted_item = {
            "name": name,
            "type": "weapon",
            "weapon_type": selected_weapon_type,
            "rarity": rarity.lower(),
            "damage": damage,
            "value": final_value,
            "description": f"A {rarity} {selected_weapon_type} with {damage} damage",
            "crafted": True
        }
        
    elif item_type.lower() == "armor":
        # Use specific armor type if provided, otherwise random
        if armor_type and armor_type.lower() in ARMOR_TYPES:
            selected_armor_type = armor_type.lower()
        else:
            selected_armor_type = random.choice(list(ARMOR_TYPES.keys()))
        
        # Generate armor stats using the new balanced system - REDUCED BY 50%
        if rarity.lower() == "common":
            health = random.randint(8, 12)
        elif rarity.lower() == "uncommon":
            health = random.randint(12, 25)
        elif rarity.lower() == "rare":
            health = random.randint(25, 50)
        elif rarity.lower() == "epic":
            health = random.randint(50, 100)
        elif rarity.lower() == "legendary":
            health = random.randint(100, 200)
        elif rarity.lower() == "mythic":
            health = random.randint(200, 400)
        elif rarity.lower() == "divine":
            health = random.randint(400, 750)
        else:
            health = random.randint(8, 12)  # fallback - REDUCED
        
        # Generate armor name based on type and rarity
        armor_emoji = ARMOR_TYPES[selected_armor_type]["emoji"]
        name = f"{rarity.title()} {selected_armor_type.title()}"
        
        # Use new direct pricing system for armor
        armor_sell_prices = {
            "common": 1300, "uncommon": 5800, "rare": 70000, "epic": 320000,
            "legendary": 3000000, "mythic": random.randint(30000000, 60000000),
            "divine": 400000000, "primordial": 1000000000
        }
        final_value = armor_sell_prices.get(rarity.lower(), 1300)
        
        # Apply randomization based on rarity
        if rarity.lower() in ["legendary", "mythic", "divine", "primordial"]:
            random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
            final_value = int(final_value * random_factor)
        else:
            random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
            final_value = int(final_value * random_factor)
        
        crafted_item = {
            "name": name,
            "type": "armor",
            "armor_type": selected_armor_type,
            "rarity": rarity.lower(),
            "health": health,
            "value": final_value,
            "description": f"A {rarity} {selected_armor_type} with {health} health",
            "crafted": True
        }
        
    elif item_type.lower() == "artifact":
        # Use specific artifact type if provided, otherwise random
        if artifact_type and artifact_type.lower() in ARTIFACT_TYPES:
            selected_artifact_type = artifact_type.lower()
        else:
            selected_artifact_type = random.choice(list(ARTIFACT_TYPES.keys()))
        
        # Generate artifact with abilities
        abilities = []
        if rarity in ["legendary", "mythic", "divine"]:
            abilities.extend(["damage", "defense", "health", "critical"])
        elif rarity in ["rare", "uncommon"]:
            abilities.extend(random.sample(["damage", "defense", "health", "critical"], random.randint(1, 3)))
        else:
            abilities.append(random.choice(["damage", "defense", "health", "critical"]))
        
        # Generate artifact name based on type and rarity
        artifact_emoji = ARTIFACT_TYPES[selected_artifact_type]["emoji"]
        name = f"{rarity.title()} {selected_artifact_type.title()}"
        
        # Use new direct pricing system for artifacts
        artifact_sell_prices = {
            "common": 1500, "uncommon": 6000, "rare": 80000, "epic": 360000,
            "legendary": 4000000, "mythic": random.randint(40000000, 70000000),
            "divine": 400000000, "primordial": 1000000000
        }
        final_value = artifact_sell_prices.get(rarity.lower(), 1500)
        
        # Apply randomization based on rarity
        if rarity.lower() in ["legendary", "mythic", "divine", "primordial"]:
            random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
            final_value = int(final_value * random_factor)
        else:
            random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
            final_value = int(final_value * random_factor)
        
        crafted_item = {
            "name": name,
            "type": "artifact",
            "artifact_type": selected_artifact_type,
            "rarity": rarity.lower(),
            "abilities": abilities,
            "value": final_value,
            "description": f"A {rarity} {selected_artifact_type} with abilities: {', '.join(abilities)}",
            "crafted": True
        }
    
    # Apply bonus effects for legendary+ items before adding to inventory
    if crafted_item["type"] in ["weapon", "armor", "artifact"] and crafted_item["rarity"] in ["legendary", "mythic", "divine"]:
        crafted_item = apply_item_bonus_effects(crafted_item)
    
    # Add crafted item to inventory
    inventory.append(crafted_item)
    meta["inventory"] = inventory
    set_user_meta(user_id, meta)
    
    # Update quest progress for blacksmithing
    try:
        check_quest_progress(user_id, "blacksmith", 1)
    except Exception as e:
        print(f"DEBUG: Error updating quest progress: {e}")

    
    # Create success embed
    rarity_emoji = RARITY_EMOJI.get(rarity.lower(), "⚪")
    embed = discord.Embed(title="⚒️ Item Crafted!", color=0x2ecc71)
    embed.description = f"Successfully crafted {rarity_emoji} **{crafted_item['name']}**!"
    
    # Add ore consumption info
    embed.add_field(name="⛏️ Ore Consumed", value=f"Used {ores_removed} {rarity.title()} ore(s)", inline=True)
    embed.add_field(name="💰 Cost", value=f"{MONEY_ICON} {cost:,}", inline=True)
    
    embed.add_field(name="Type", value=item_type.title(), inline=True)
    
    # Show specific type if available
    if item_type.lower() == "weapon" and "weapon_type" in crafted_item:
        embed.add_field(name="Weapon Type", value=crafted_item["weapon_type"].title(), inline=True)
    elif item_type.lower() == "armor" and "armor_type" in crafted_item:
        embed.add_field(name="Armor Type", value=crafted_item["armor_type"].title(), inline=True)
    elif item_type.lower() == "artifact" and "artifact_type" in crafted_item:
        embed.add_field(name="Artifact Type", value=crafted_item["artifact_type"].title(), inline=True)
    
    embed.add_field(name="Rarity", value=rarity.title(), inline=True)
    embed.add_field(name="Cost", value=f"{MONEY_ICON} {cost:,}", inline=True)
    
    if item_type.lower() == "weapon":
        embed.add_field(name="Damage", value=crafted_item["damage"], inline=True)
    elif item_type.lower() == "armor":
        embed.add_field(name="Health", value=crafted_item["health"], inline=True)
    elif item_type.lower() == "artifact":
        embed.add_field(name="Abilities", value=", ".join(crafted_item["abilities"]), inline=True)
    
    # Removed duplicate "Ores Used" field since we already have "Ore Consumed" above
    embed.add_field(name="Value", value=f"{MONEY_ICON} {crafted_item['value']:,}", inline=True)
    
    embed.set_footer(text="Use /inventory to view your crafted item")
    await ctx.send(embed=embed)

















# -----------------------
# Admin Commands for Equipment and Encounters
# -----------------------

@bot.command(name="generate_equipment")
@commands.has_permissions(administrator=True)
async def generate_equipment_admin(ctx, user: discord.Member, equipment_type: str, rarity: str):
    """Admin command to generate equipment for a user"""
    if equipment_type not in ["weapon", "armor", "artifact"]:
        await send_embed(ctx, "Invalid Type", "Equipment type must be: weapon, armor, or artifact", 0xe74c3c)
        return
    
    if rarity not in ["common", "uncommon", "rare", "legendary", "mythic", "divine"]:
        await send_embed(ctx, "Invalid Rarity", "Rarity must be: common, uncommon, rare, legendary, mythic, or divine", 0xe74c3c)
        return
    
    # Generate the equipment
    if equipment_type == "weapon":
        weapon_type = random.choice(list(WEAPON_TYPES.keys()))
        item = generate_weapon(weapon_type, rarity)
    elif equipment_type == "armor":
        armor_type = random.choice(list(ARMOR_TYPES.keys()))
        item = generate_armor(armor_type, rarity)
    else:
        artifact_type = random.choice(list(ARTIFACT_TYPES.keys()))
        item = generate_artifact(artifact_type, rarity)
    
    # Apply bonus effects for legendary+ items before adding to inventory
    if item["type"] in ["weapon", "armor", "artifact"] and item.get("rarity") in ["legendary", "mythic", "divine"]:
        item = apply_item_bonus_effects(item)
    
    # Add to user's inventory
    user_meta = get_user_meta(user.id)
    inventory = user_meta.get("inventory", [])
    inventory.append(item)
    user_meta["inventory"] = inventory
    set_user_meta(user.id, user_meta)
    
    rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
    embed = discord.Embed(
        title="✅ Equipment Generated!",
        description=f"Admin {ctx.author.display_name} generated {rarity_emoji} **{item['name']}** for {user.mention}",
        color=0x2ecc71
    )
    
    if equipment_type == "weapon":
        embed.add_field(name="⚔️ Weapon Stats", value=f"Damage: {item['damage']}", inline=True)
    elif equipment_type == "armor":
        embed.add_field(name="🛡️ Armor Stats", value=f"Health: {item['health']}", inline=True)
    elif equipment_type == "artifact":
        embed.add_field(name="✨ Abilities", value=", ".join(item["abilities"]), inline=True)
    
    embed.add_field(name="💰 Value", value=f"{MONEY_ICON} {item['value']:,}", inline=True)
    embed.set_footer(text=f"Item added to {user.display_name}'s inventory")
    
    await ctx.send(embed=embed)


@bot.command(name="set_encounter_chance")
@commands.has_permissions(administrator=True)
async def set_encounter_chance(ctx, chance_percent: float):
    """Admin command to set the chance of encountering beasts/evil cultivators during expeditions"""
    if chance_percent < 0 or chance_percent > 100:
        await send_embed(ctx, "Invalid Chance", "Chance must be between 0 and 100 percent", 0xe74c3c)
        return
    
    # Store in bot settings (you might want to create a separate settings file)
    # For now, we'll use a global variable approach
    global EXPEDITION_ENCOUNTER_CHANCE
    EXPEDITION_ENCOUNTER_CHANCE = chance_percent / 100.0
    
    embed = discord.Embed(
        title="✅ Encounter Chance Updated",
        description=f"Expedition encounter chance set to **{chance_percent}%**",
        color=0x2ecc71
    )
    embed.add_field(name="New Chance", value=f"{chance_percent}%", inline=True)
    embed.add_field(name="Admin", value=ctx.author.mention, inline=True)
    
    await ctx.send(embed=embed)


# -----------------------
# Sect Level Command
# -----------------------
@bot.hybrid_command(name="sect_level", description="View your cultivation progress (works for both sect members and rogue cultivators)")
async def sect_level(ctx):
    try:
        data = load_json(SECTS_FILE)
        meta = get_user_meta(ctx.author.id)
        sect_name = meta.get("sect")
        
        # Clean up corrupted sect data
        if sect_name and sect_name not in data:
            meta["sect"] = None
            meta["sect_rank"] = None
            set_user_meta(ctx.author.id, meta)
            sect_name = None
        elif sect_name and sect_name in data:
            # Check if user is actually a member of the sect or the leader
            if not validate_sect_membership(ctx.author.id, sect_name):
                # User not actually in sect, clear sect data
                meta["sect"] = None
                meta["sect_rank"] = None
                set_user_meta(ctx.author.id, meta)
                sect_name = None
        
        if not sect_name or sect_name not in data:
            # Rogue cultivator - show their progress without sect
            user_xp = int(meta.get("sect_xp", 0))
            level, cur_xp, needed, req = get_member_level_and_progress(user_xp)
            
            embed = discord.Embed(title="Rogue Cultivator Progress", color=0x95a5a6)
            embed.description = "You are a rogue cultivator, free from sect constraints!"
            embed.add_field(name="Your Level", value=f"Level: {level}\nProgress: {cur_xp:,}/{req:,} (Need {needed:,})", inline=False)
            embed.add_field(name="Title", value=f"**{get_decorative_title(level, None)}**", inline=False)
            embed.add_field(name="💡 Tip", value="Join a sect to access sect-specific features and bonuses!", inline=False)
            await ctx.send(embed=embed)
            return
        
        # Sect member progress
        user_xp = int(meta.get("sect_xp", 0))
        level, cur_xp, needed, req = get_member_level_and_progress(user_xp)
        
        # Get current rank from sect data
        sect_data = data[sect_name]
        current_rank = "outer disciple"  # Default rank
        
        # Check if user is the leader
        if ctx.author.id == sect_data.get("leader"):
            current_rank = "sect leader"
        # Check if user has a specific rank in the sect
        elif "positions" in sect_data and str(ctx.author.id) in sect_data["positions"]:
            current_rank = sect_data["positions"][str(ctx.author.id)]
        elif meta.get("sect_rank"):
            current_rank = meta.get("sect_rank")
        
        # Determine next rank
        try:
            idx = SECT_RANKS.index(current_rank.lower())
        except ValueError:
            idx = 0
        
        next_idx = min(idx + 1, len(SECT_RANKS) - 1)
        next_rank = SECT_RANKS[next_idx]
        required_for_next = get_required_xp_for_rank_index(next_idx)
        remaining_to_next = max(0, required_for_next - user_xp)

        embed = discord.Embed(title=f"Sect Progress — {sect_name}", color=0x9b59b6)
        embed.add_field(name="Your Level", value=f"Level: {level}\nProgress: {cur_xp:,}/{req:,} (Need {needed:,})", inline=False)
        embed.add_field(name="Position", value=f"Current: {current_rank.title()}\nNext: {next_rank.title()}\nNeed {remaining_to_next:,} XP to promote", inline=False)
        embed.add_field(name="Title", value=f"**{get_decorative_title(level, sect_name)}**", inline=False)
        await ctx.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(title="❌ Error", description=f"An error occurred: {str(e)}", color=0xe74c3c)
        await ctx.send(embed=error_embed)

@bot.hybrid_command(name="weekly", description="Collect your weekly reward")
async def weekly(ctx):
    await ctx.defer()
    current_timestamp = int(time.time())
    meta = get_user_meta(ctx.author.id)

    last_weekly = meta.get("last_weekly")
    
    # Handle both integer timestamps and legacy ISO strings
    if isinstance(last_weekly, (int, float)):
        last_weekly_timestamp = int(last_weekly)
    elif last_weekly:
        try:
            last_weekly_dt = datetime.fromisoformat(last_weekly)
            last_weekly_timestamp = int(last_weekly_dt.timestamp())
        except (ValueError, TypeError):
            last_weekly_timestamp = 0
    else:
        last_weekly_timestamp = 0

    # Check if 7 days have passed since last claim (604800 seconds = 7 days)
    cooldown_seconds = 604800
    if last_weekly_timestamp > 0 and current_timestamp < last_weekly_timestamp + cooldown_seconds:
        remaining_seconds = (last_weekly_timestamp + cooldown_seconds) - current_timestamp
        days = remaining_seconds // 86400
        hours = (remaining_seconds % 86400) // 3600
        minutes = (remaining_seconds % 3600) // 60
        seconds = remaining_seconds % 60
        
        next_available_timestamp = last_weekly_timestamp + cooldown_seconds

        embed = discord.Embed(title="Weekly Reward", color=0xe74c3c)
        embed.description = f"⏳ You've already claimed your weekly reward."
        embed.add_field(name="Time Remaining", value=f"{days}d {hours}h {minutes}m {seconds}s", inline=True)
        embed.add_field(name="Available At", value=f"<t:{next_available_timestamp}:R> at <t:{next_available_timestamp}:t>", inline=True)
        embed.set_footer(text=f"Available again at <t:{next_available_timestamp}:F>")
        await ctx.send(embed=embed)
        return

    # Fixed reward of 50,000 spirit stones
    reward = 50000

    # Apply sect bonus if applicable
    sect_data = load_json(SECTS_FILE)
    user_sect = get_user_meta(ctx.author.id).get("sect")
    bonus = 0
    boost_pct = 0
    if user_sect and isinstance(sect_data, dict) and user_sect in sect_data:
        boost_pct = int(sect_data[user_sect].get("boost_percent", 0))
        if boost_pct > 0:
            bonus = int(reward * boost_pct / 100)
    # Immortal art bonuses
    total_after_sect = reward + bonus
    
    # Apply sect shop weekly bonus boosts
    total_after_sect, sect_bonus, sect_boost_pct = apply_sect_boosts_to_income(ctx.author.id, total_after_sect)
    
    total_after_sect, art_bonus, art_pct = apply_money_bonus_for_keys(ctx.author.id, total_after_sect, ["global_gold_gain_pct"]) 
    add_cash(ctx.author.id, total_after_sect)
    
    # Give weekly immortal art rerolls
    weekly_rerolls = 9
    if "immortal_arts" not in meta:
        meta["immortal_arts"] = {"rerolls": 0, "slots": [], "unlocked_slots": 1}
    
    current_rerolls = meta["immortal_arts"].get("rerolls", 0)
    meta["immortal_arts"]["rerolls"] = current_rerolls + weekly_rerolls
    
    # Update last weekly and immortal arts
    meta["last_weekly"] = current_timestamp
    set_user_meta(ctx.author.id, meta)

    # Calculate next available time
    next_available_timestamp = current_timestamp + cooldown_seconds

    embed = discord.Embed(title="Weekly Reward", color=0x00ff00)
    desc = f"You claimed your weekly reward!"
    
    # Show base reward
    desc += f"\n\n**Weekly reward: {MONEY_ICON} {reward:,}**"
    
    # Show sect bonus
    if bonus > 0 and user_sect:
        desc += f"\n**Sect bonus from {user_sect}: {MONEY_ICON} {bonus} (+{boost_pct}%)**"
    
    # Show sect shop weekly bonus boost
    if sect_bonus > 0 and user_sect:
        desc += f"\n**🏪 Sect Shop weekly bonus: {MONEY_ICON} {sect_bonus} (+{sect_boost_pct:.1f}%)**"
    
    # Show Immortal Art bonus
    if art_bonus > 0:
        desc += f"\n**Immortal Art bonus: {MONEY_ICON} {art_bonus} (+{art_pct:.1f}%)**"
    
    desc += f"\n\n**Total: {MONEY_ICON} {total_after_sect:,}**"
    desc += f"\n🎲 **Weekly Rerolls: +{weekly_rerolls} immortal art rerolls**"
    desc += f"\n🎲 **Total Rerolls: {meta['immortal_arts']['rerolls']}**"
    
    embed.description = desc
    embed.add_field(name="Next Available", value=f"<t:{next_available_timestamp}:R> at <t:{next_available_timestamp}:t>", inline=True)
    embed.add_field(name="🎲 Rerolls", value=f"Weekly: +{weekly_rerolls} | Total: {meta['immortal_arts']['rerolls']}", inline=True)
    embed.set_footer(text=f"Available again at <t:{next_available_timestamp}:F>")
    await ctx.send(embed=embed)





# Local file constants (paths used above as well)
# JOBS_FILE and STORE_FILE defined in Part1

# Ensure default jobs exist
def ensure_jobs_defaults():
    jobs = load_json(JOBS_FILE)
    if not jobs:
        save_json(JOBS_FILE, DEFAULT_JOBS)
        return DEFAULT_JOBS.copy()
    return jobs


ensure_jobs_defaults()


# Job management
@bot.command(name="addjob")
@commands.has_permissions(administrator=True)
async def addjob(ctx, name: str, min_pay: int, max_pay: int, money_requirement: int = 0,
                 role_requirement: Optional[discord.Role] = None):
    """Admin: add or update a job with optional money and role requirements."""
    jobs = load_json(JOBS_FILE)

    # Store job with requirements
    job_data = [int(min_pay), int(max_pay)]

    # Add money requirement if specified
    if money_requirement > 0:
        job_data.append({"money_req": money_requirement})

    # Add role requirement if specified
    if role_requirement:
        if len(job_data) == 2:
            job_data.append({"role_req": str(role_requirement.id)})
        else:
            job_data[2]["role_req"] = str(role_requirement.id)

    jobs[name] = job_data
    save_json(JOBS_FILE, jobs)

    # Create response message
    response = f"Job **{name}** set with range {MONEY_ICON} {min_pay}–{max_pay}."

    if money_requirement > 0:
        response += f"\n💰 Money Requirement: {MONEY_ICON} {money_requirement}"

    if role_requirement:
        response += f"\n🏅 Role Requirement: {role_requirement.mention}"

    await send_embed(ctx, "Job Updated", response, 0x2ecc71)


@bot.hybrid_command(name="listjobs", description="List available jobs with detailed information")
async def listjobs(ctx):
    jobs = load_json(JOBS_FILE)
    if not jobs:
        await send_embed(ctx, "Jobs", "No jobs configured.", 0xe67e22)
        return

    embed = discord.Embed(
        title="📋 Available Jobs",
        description="Choose a job with `/selectjob <name>` to start working and earning!",
        color=0x3498db
    )

    # Add thumbnail
    embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/123456789/job_icon.png")

    # Group jobs by tier based on pay
    basic_jobs = []
    advanced_jobs = []
    premium_jobs = []

    for job_name, job_data in jobs.items():
        if not isinstance(job_data, list) or len(job_data) < 2:
            continue

        min_pay, max_pay = job_data[0], job_data[1]
        avg_pay = (min_pay + max_pay) / 2

        # Check for requirements
        requirements = []
        if len(job_data) > 2 and isinstance(job_data[2], dict):
            # Money requirement
            if "money_req" in job_data[2]:
                requirements.append(f"💰 Requires {MONEY_ICON} {job_data[2]['money_req']:,}")

            # Role requirement
            if "role_req" in job_data[2]:
                role_id = job_data[2]["role_req"]
                requirements.append(f"🏅 Requires role <@&{role_id}>")

        # Get user's current rank in this job
        user_rank = get_job_rank(ctx.author.id, job_name)
        user_xp = get_job_xp(ctx.author.id, job_name)
        
        # Format job description with more details
        job_desc = f"**Pay:** {MONEY_ICON} {min_pay:,}–{max_pay:,}\n"
        job_desc += f"**Your Rank:** {user_rank.title()}\n"
        job_desc += f"**Your XP:** {user_xp:,}\n"
        
        # Show next rank requirements if not at max
        if user_rank != "master":
            rank_names = list(JOB_RANKS.keys())
            current_rank_index = rank_names.index(user_rank)
            if current_rank_index < len(rank_names) - 1:
                next_rank = rank_names[current_rank_index + 1]
                next_rank_data = JOB_RANKS[next_rank]
                xp_needed = next_rank_data["xp_required"] - user_xp
                if xp_needed > 0:
                    job_desc += f"**Next Rank:** {next_rank.title()} ({xp_needed:,} XP needed)\n"
        
        if requirements:
            job_desc += f"**Requirements:**\n" + "\n".join(requirements)

        # Categorize job based on average pay
        if avg_pay < 200:
            basic_jobs.append((job_name, job_desc))
        elif avg_pay < 400:
            advanced_jobs.append((job_name, job_desc))
        else:
            premium_jobs.append((job_name, job_desc))

    # Add jobs to embed by category with better formatting
    if basic_jobs:
        embed.add_field(name="📝 Basic Jobs (Entry Level)", value="​", inline=False)
        for job_name, job_desc in basic_jobs:
            embed.add_field(name=f"🔨 {job_name}", value=job_desc, inline=False)

    if advanced_jobs:
        embed.add_field(name="📈 Advanced Jobs (Skilled)", value="​", inline=False)
        for job_name, job_desc in advanced_jobs:
            embed.add_field(name=f"⚡ {job_name}", value=job_desc, inline=False)

    if premium_jobs:
        embed.add_field(name="💎 Premium Jobs (Expert)", value="​", inline=False)
        for job_name, job_desc in premium_jobs:
            embed.add_field(name=f"🌟 {job_name}", value=job_desc, inline=False)

    # Add helpful information
    embed.add_field(
        name="💡 Job Progression Tips", 
        value="• Work regularly to gain XP and rank up\n• Higher ranks give better pay multipliers\n• Some jobs have special requirements\n• You can only work one job at a time", 
        inline=False
    )

    embed.set_footer(text="Use /job to work once you've selected a job • Use /job_status to check your progress")
    await ctx.send(embed=embed)


@bot.hybrid_command(name="selectjob", description="Select your job (use job to work)")
@app_commands.autocomplete(job_name=job_name_autocomplete)
async def selectjob(ctx, *, job_name: str):
    jobs = load_json(JOBS_FILE)
    # exact match or case-insensitive substring
    match = None
    for k in jobs.keys():
        if k.lower() == job_name.lower():
            match = k;
            break
    if not match:
        for k in jobs.keys():
            if job_name.lower() in k.lower():
                match = k;
                break
    if not match:
        await send_embed(ctx, "Job Not Found", "Available: " + ", ".join(jobs.keys()), 0xe74c3c)
        return

    # Check job requirements
    job_data = jobs[match]
    if len(job_data) > 2 and isinstance(job_data[2], dict):
        # Check money requirement
        if "money_req" in job_data[2]:
            money_req = job_data[2]["money_req"]
            cash, bank = get_balances(ctx.author.id)
            total_money = cash + bank

            if total_money < money_req:
                await send_embed(ctx, "Requirement Not Met", f"You need at least {MONEY_ICON} {money_req:,} to become a **{match}**. You only have {MONEY_ICON} {total_money:,}.", 0xe74c3c)
                return

        # Check role requirement
        if "role_req" in job_data[2]:
            role_id = job_data[2]["role_req"]
            member_roles = [role.id for role in ctx.author.roles]

            if int(role_id) not in member_roles:
                await send_embed(ctx, "Requirement Not Met", f"You need the <@&{role_id}> role to become a **{match}**.", 0xe74c3c)
                return

    # Update user meta while preserving existing data
    meta = get_user_meta(ctx.author.id)
    meta["job"] = match
    set_user_meta(ctx.author.id, meta)
    await send_embed(ctx, "Job Selected", f"You are now a **{match}**. Use `/work` to work.", 0x2ecc71)


# Work / Job command
@bot.hybrid_command(name="work", description="Work your selected job for payout (hourly cooldown)")
async def work(ctx: commands.Context):
    """Work your currently selected job for payout."""
    await ctx.defer()
    current_timestamp = int(time.time())
    meta = get_user_meta(ctx.author.id)
    sel = meta.get("job")

    # No job selected
    if not sel:
        embed = discord.Embed(title="⚠️ No Job Selected", color=0xe74c3c)
        embed.description = "You don't have a job selected."
        embed.add_field(name="What to do", value="Use `/selectjob` to choose a job first.", inline=False)
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
        await ctx.send(embed=embed)
        return

    # Check if job exists
    jobs = load_json(JOBS_FILE)
    if sel not in jobs:
        embed = discord.Embed(title="⚠️ Job Error", color=0xe74c3c)
        embed.description = "Your chosen job no longer exists."
        embed.add_field(name="What to do",
                        value="Use `/listjobs` to see available jobs and `/selectjob` to choose a new one.",
                        inline=False)
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
        await ctx.send(embed=embed)
        return

    # Check cooldown with Immortal Art reduction - using simple integer timestamps
    last_job_timestamp = meta.get("last_job_timestamp", 0)  # Use integer timestamp
    
    base_cooldown_hours = 1
    cooldown_hours = apply_work_cooldown_reduction(ctx.author.id, base_cooldown_hours)
    cooldown_seconds = cooldown_hours * 3600
    
    time_since_last = current_timestamp - last_job_timestamp
    
    if time_since_last < cooldown_seconds:
        # Still on cooldown
        remaining_seconds = cooldown_seconds - time_since_last
        hours = remaining_seconds // 3600
        minutes = (remaining_seconds % 3600) // 60
        seconds = remaining_seconds % 60
        
        next_available_timestamp = int(last_job_timestamp + cooldown_seconds)

        embed = discord.Embed(title=f"⏳ Job Cooldown — {sel}", color=0xe74c3c)
        embed.description = f"You need to rest before working again."
        
        # Show cooldown reduction if applicable
        cooldown_reduction = base_cooldown_hours - cooldown_hours
        if cooldown_reduction > 0:
            embed.description += f"\n\n**Immortal Art cooldown reduction: -{cooldown_reduction:.1f}h**"
        
        embed.add_field(name="Time Remaining", value=f"{hours}h {minutes}m {seconds}s", inline=True)
        embed.add_field(
            name="Available",
            value=f"<t:{next_available_timestamp}:R> at <t:{next_available_timestamp}:t>",
            inline=True
        )
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
        embed.set_footer(text=f"Try again at <t:{next_available_timestamp}:F>")
        await ctx.send(embed=embed)
        return

    # Calculate payout based on job rank (3x boost applied)
    job_meta = jobs[sel]
    if isinstance(job_meta, (list, tuple)) and len(job_meta) >= 2:
        low, high = job_meta[0] * 3, job_meta[1] * 3  # 3x boost
    else:
        low, high = 300, 900  # 3x boost from 100-300
    
    # Get current job rank and apply multiplier
    current_rank = get_job_rank(ctx.author.id, sel)
    rank_multiplier = JOB_RANKS[current_rank]["multiplier"]
    
    base_payout = random.randint(int(low), int(high))
    payout = int(base_payout * rank_multiplier)

    # Apply sect bonus
    sect_name, boost_pct = get_user_sect_and_boost(ctx.author.id)
    total_earnings, bonus = calc_with_bonus(payout, boost_pct)
    
    # Apply sect income boosts
    total_earnings, sect_bonus, sect_boost_pct = apply_sect_boosts_to_income(ctx.author.id, total_earnings)
    
    # Apply Immortal Art work boosts
    total_earnings, art_bonus, art_pct = apply_money_bonus_for_keys(
        ctx.author.id,
        total_earnings,
        ["work_income_pct"]
    )
    
    # Apply equipment work income boosts
    passive_effects = calculate_passive_effects(ctx.author.id)
    if passive_effects["work_income_boost"] > 0:
        equipment_bonus = int(total_earnings * (passive_effects["work_income_boost"] / 100))
        total_earnings += equipment_bonus
        print(f"DEBUG: Equipment work income boost: +{equipment_bonus} ({passive_effects['work_income_boost']}%)")

    # Check for extra loot from Immortal Art
    extra_loot = None
    if check_work_loot_chance(ctx.author.id):
        loot_amount = random.randint(50, 200)
        total_earnings += loot_amount
        extra_loot = loot_amount

    # Update user data
    new_balance = add_cash(ctx.author.id, total_earnings)
    print(f"DEBUG: User {ctx.author.id} earned {total_earnings} from job {sel}, new balance: {new_balance}")
    
    # Update quest progress
    try:
        check_quest_progress(ctx.author.id, "work", 1)
        # Track wealth quest progress
        check_wealth_quest_progress(ctx.author.id, total_earnings)
    except Exception as e:
        print(f"DEBUG: Error updating quest progress: {e}")
    
    # Add job XP and check for rank up
    old_rank = get_job_rank(ctx.author.id, sel)
    base_xp = JOB_XP_PER_WORK
    
    # Apply sect XP boosts
    total_xp, xp_bonus, xp_boost_pct = apply_sect_boosts_to_xp(ctx.author.id, base_xp)
    
    new_rank, total_xp = add_job_xp(ctx.author.id, sel, total_xp)
    rank_up = old_rank != new_rank
    
    # Reload meta after XP changes to ensure we have the latest data
    meta = get_user_meta(ctx.author.id)
    
    # Add sect XP if user is in a sect
    sect_xp_gained = 0
    if sect_name:
        sect_xp_gained = 5  # Base sect XP for working
        # Add sect XP to the sect
        sects = load_json(SECTS_FILE)
        if sect_name in sects:
            sects[sect_name]["xp"] = sects[sect_name].get("xp", 0) + sect_xp_gained
            save_json(SECTS_FILE, sects)
    
    # Check for item crafting (higher ranks have better chances)
    crafted_item = None
    crafted_rarity = None
    crafted_value = 0
    crafted_type = None
    
    # Lower odds significantly to avoid frequent high-tier items: 3% base + small rank bonus
    if random.random() < (0.03 + JOB_RANKS[new_rank]["multiplier"] * 0.01):
        crafted_item, crafted_rarity, crafted_value, crafted_type = craft_job_item(sel, new_rank, ctx.author.id)
        if crafted_item:
            # Create item with explicit type metadata
            item_data = {
                "type": crafted_type,
                "name": crafted_item,
                "rarity": crafted_rarity,
                "value": crafted_value,
                "job_crafted": sel,
                "rank_crafted": new_rank,
                "crafted_at": current_timestamp
            }
            
            # Special handling for blacksmith job items - ensure they're properly categorized as weapons
            if sel == "Blacksmith" and crafted_type == "job_item":
                item_data["type"] = "weapon"
                # Determine weapon type based on item name
                if "sword" in crafted_item.lower():
                    item_data["weapon_type"] = "sword"
                elif "spear" in crafted_item.lower():
                    item_data["weapon_type"] = "spear"
                elif "dagger" in crafted_item.lower():
                    item_data["weapon_type"] = "dagger"
                elif "axe" in crafted_item.lower():
                    item_data["weapon_type"] = "axe"
                elif "hammer" in crafted_item.lower():
                    item_data["weapon_type"] = "hammer"
                elif "blade" in crafted_item.lower():
                    item_data["weapon_type"] = "sword"
                else:
                    item_data["weapon_type"] = "sword"  # Default weapon type
                
                # Calculate damage based on rarity and rank
                base_damage = 10 + (JOB_RANKS[new_rank]["multiplier"] * 5)
                rarity_multiplier = {"common": 1, "uncommon": 1.5, "rare": 2, "legendary": 3, "mythic": 4}.get(crafted_rarity, 1)
                item_data["damage"] = int(base_damage * rarity_multiplier)
                item_data["description"] = f"A {crafted_rarity} quality weapon crafted by a {new_rank} blacksmith"
            
            # Add to inventory using stacking function
            add_item_to_inventory(ctx.author.id, item_data)
    

    
    # Update last job time AFTER all processing is done - using simple integer timestamp
    # Don't overwrite inventory that was updated by add_item_to_inventory
    current_meta = get_user_meta(ctx.author.id)
    current_meta["last_job_timestamp"] = current_timestamp
    set_user_meta(ctx.author.id, current_meta)

    # Calculate next available time using simple integer timestamp
    next_available_timestamp = int(current_timestamp + cooldown_seconds)

    # Create a rich embed for job completion
    embed = discord.Embed(title=f"💼 Work Completed — {sel}", color=0x2ecc71)
    desc = f"You worked hard as a **{sel}** and earned some spirit stones!"
    
    # Show rank and XP info
    desc += f"\n\n**🏆 Rank:** {new_rank.title()} (x{rank_multiplier:.1f} multiplier)"
    desc += f"\n**📊 XP Gained:** +{total_xp} XP"
    if xp_bonus > 0:
        desc += f" (+{base_xp} base + {xp_bonus} sect boost)"
    
    # Show sect XP if gained
    if sect_xp_gained > 0:
        desc += f"\n**🏛️ Sect XP Gained:** +{sect_xp_gained} XP for {sect_name}"
    
    # Show base earnings
    desc += f"\n\n**Base earnings: {MONEY_ICON} {base_payout:,}**"
    desc += f"\n**Rank multiplier: {MONEY_ICON} {payout - base_payout:,}**"
    
    # Show sect bonus
    if bonus > 0 and sect_name:
        desc += f"\n**Sect bonus from {sect_name}: {MONEY_ICON} {bonus} (+{boost_pct}%)**"
    
    # Show sect shop boosts
    if sect_bonus > 0 and sect_name:
        desc += f"\n**🏪 Sect Shop bonus: {MONEY_ICON} {sect_bonus} (+{sect_boost_pct:.1f}%)**"
    
    # Show Immortal Art bonus
    if art_bonus > 0:
        desc += f"\n**Immortal Art bonus: {MONEY_ICON} {art_bonus} (+{art_pct:.1f}%)**"
    
    # Show equipment bonus
    passive_effects = calculate_passive_effects(ctx.author.id)
    if passive_effects["work_income_boost"] > 0:
        equipment_bonus = int(total_earnings * (passive_effects["work_income_boost"] / 100))
        desc += f"\n**Equipment bonus: {MONEY_ICON} {equipment_bonus} (+{passive_effects['work_income_boost']}%)**"
    
    # Show extra loot
    if extra_loot:
        desc += f"\n**🎁 Extra loot found: {MONEY_ICON} {extra_loot:,}**"
    
    # Show crafted item
    if crafted_item:
        rarity_emoji = RARITY_EMOJI.get(crafted_rarity, "⚪")
        item_type_label = {
            "job_item": "⚒️ Crafted",
            "ore": "⛏️ Ore",
            "loot": "🎁 Loot",
        }.get(crafted_type, "🎁 Reward")
        desc += f"\n**{item_type_label}: {rarity_emoji} {crafted_item} ({crafted_rarity.title()}) - Value: {MONEY_ICON} {crafted_value:,}**"
    
    # Show rank up message
    if rank_up:
        desc += f"\n\n**🎉 RANK UP!** You are now a **{new_rank.title()} {sel}**!"
    
    embed.description = desc

    # Add job details
    embed.add_field(name="💰 Total Earnings", value=f"{MONEY_ICON} {total_earnings:,}", inline=True)
    embed.add_field(
        name="⏱️ Next Available",
        value=f"<t:{next_available_timestamp}:R> at <t:{next_available_timestamp}:t>",
        inline=True
    )
    
    # Add XP progress info
    current_rank, current_xp, xp_needed, progress_percent = get_job_rank_progress(ctx.author.id, sel)
    total_xp_for_next = current_xp + xp_needed
    embed.add_field(
        name="📊 XP Progress",
        value=f"**{current_xp:,}** / **{total_xp_for_next:,}** XP\nProgress: {progress_percent}%",
        inline=True
    )

    # Add timestamp for next availability
    embed.add_field(
        name="📅 Exact Time",
        value=f"<t:{next_available_timestamp}:F>",
        inline=False
    )

    # Add user avatar as thumbnail
    embed.set_thumbnail(url=ctx.author.display_avatar.url)

    embed.set_footer(text=f"Use /work again after cooldown to earn more!")
    await ctx.send(embed=embed)


@bot.hybrid_command(name="job_status", description="View your job progress and rank information")
async def job_status(ctx):
    """Show detailed job status including ranks, XP, and progress"""
    meta = get_user_meta(ctx.author.id)
    selected_job = meta.get("job")
    
    if not selected_job:
        embed = discord.Embed(title="⚠️ No Job Selected", color=0xe74c3c)
        embed.description = "You don't have a job selected."
        embed.add_field(name="What to do", value="Use `/selectjob` to choose a job first.", inline=False)
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
        await ctx.send(embed=embed)
        return
    
    # Get job data
    jobs = load_json(JOBS_FILE)
    if selected_job not in jobs:
        embed = discord.Embed(title="⚠️ Job Error", color=0xe74c3c)
        embed.description = "Your chosen job no longer exists."
        embed.add_field(name="What to do", value="Use `/listjobs` to see available jobs and `/selectjob` to choose a new one.", inline=False)
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
        await ctx.send(embed=embed)
        return
    
    # Get current rank and progress
    current_rank = get_job_rank(ctx.author.id, selected_job)
    current_xp = get_job_xp(ctx.author.id, selected_job)
    rank, xp, xp_needed, progress = get_job_rank_progress(ctx.author.id, selected_job)
    
    # Get message count for progression
    message_count = get_message_count(ctx.author.id)
    
    # Create embed
    embed = discord.Embed(title=f"💼 Job Status — {selected_job}", color=0x3498db)
    embed.description = f"Your current status as a **{selected_job}**"
    
    # Rank information
    rank_info = f"**Current Rank:** {current_rank.title()}\n"
    rank_info += f"**Rank Multiplier:** x{JOB_RANKS[current_rank]['multiplier']:.1f}\n"
    rank_info += f"**Total XP:** {current_xp:,}"
    
    if xp_needed > 0:
        rank_info += f"\n**XP to Next Rank:** {xp_needed:,}\n"
        rank_info += f"**Progress:** {progress}%"
    else:
        rank_info += "\n**🎉 MAX RANK ACHIEVED!**"
    
    embed.add_field(name="🏆 Rank Information", value=rank_info, inline=False)
    
    # Message count for progression
    embed.add_field(name="💬 Message Count", value=f"{message_count:,} messages", inline=True)
    
    # Job requirements for next rank
    if xp_needed > 0:
        next_rank_name = list(JOB_RANKS.keys())[list(JOB_RANKS.keys()).index(current_rank) + 1]
        next_rank_data = JOB_RANKS[next_rank_name]
        embed.add_field(name="📋 Next Rank Requirements", value=f"**{next_rank_name.title()}:**\n• {next_rank_data['xp_required']:,} XP\n• {next_rank_data['message_requirement']:,} messages", inline=True)
    
    # Young Master system removed; no eligibility status
    
    # Add user avatar as thumbnail
    embed.set_thumbnail(url=ctx.author.display_avatar.url)
    
    embed.set_footer(text="Keep working and chatting to progress!")
    await ctx.send(embed=embed)





# Cultivate command (hourly) - using simple integer timestamps
@bot.hybrid_command(name="cultivate", description="Quick cultivate for XP and chance for money (hourly)")
async def cultivate(ctx: commands.Context):
    try:
        await ctx.defer()
        current_timestamp = int(time.time())
        meta = get_user_meta(ctx.author.id)
        last_cultivate_timestamp = meta.get("last_cultivate_timestamp", 0)  # Use integer timestamp
        
        # Check cooldown (1 hour = 3600 seconds)
        cooldown_seconds = 3600
        time_since_last = current_timestamp - last_cultivate_timestamp
        
        if time_since_last < cooldown_seconds:
            # Still on cooldown
            remaining_seconds = cooldown_seconds - time_since_last
            hours = remaining_seconds // 3600
            minutes = (remaining_seconds % 3600) // 60
            seconds = remaining_seconds % 60
            
            next_available_timestamp = int(last_cultivate_timestamp + cooldown_seconds)
            
            embed = discord.Embed(title="Cultivation", color=0xe74c3c)
            embed.description = f"⏳ Your spiritual energy is depleted. You need to rest before cultivating again."
            embed.add_field(name="Time Remaining", value=f"{hours}h {minutes}m {seconds}s", inline=True)
            embed.add_field(name="Available At", value=f"<t:{next_available_timestamp}:R> at <t:{next_available_timestamp}:t>", inline=True)
            await ctx.send(embed=embed)
            return
    except Exception as e:
        await ctx.send(f"❌ An error occurred during cultivation setup: {str(e)}")
        return

    # Main reward: XP (800-1500 base)
    try:
        base_xp = random.randint(800, 1500)
        
        # Apply Immortal Art cultivation boosts for XP
        total_xp, art_bonus, art_pct = apply_money_bonus_for_keys(
            ctx.author.id,
            base_xp,
            ["cultivate_reward_pct"]
        )
        
        # Apply equipment cultivation boosts
        passive_effects = calculate_passive_effects(ctx.author.id)
        if passive_effects["cultivation_boost"] > 0:
            equipment_bonus = int(total_xp * (passive_effects["cultivation_boost"] / 100))
            total_xp += equipment_bonus
            print(f"DEBUG: Equipment cultivation boost: +{equipment_bonus} ({passive_effects['cultivation_boost']}%)")
        
        # Add sect XP
        add_sect_xp(ctx.author.id, total_xp)
        
        # Secondary reward: Money (30% chance, 200-800)
        money_reward = 0
        if random.random() < 0.30:  # 30% chance for money
            money_reward = random.randint(200, 800)
            
            # Apply sect bonus to money
            sect_name, boost_pct = get_user_sect_and_boost(ctx.author.id)
            total_money, bonus = calc_with_bonus(money_reward, boost_pct)
            
            # Apply Immortal Art cultivation boosts to money
            total_money, art_money_bonus, art_money_pct = apply_money_bonus_for_keys(
                ctx.author.id,
                total_money,
                ["cultivate_reward_pct"]
            )
            
            # Apply equipment cultivation boosts to money
            if passive_effects["cultivation_boost"] > 0:
                equipment_money_bonus = int(total_money * (passive_effects["cultivation_boost"] / 100))
                total_money += equipment_money_bonus
                print(f"DEBUG: Equipment cultivation money boost: +{equipment_money_bonus} ({passive_effects['cultivation_boost']}%)")
            
            add_cash(ctx.author.id, total_money)
            money_reward = total_money  # Update for display
            
            # Track wealth quest progress
            try:
                check_wealth_quest_progress(ctx.author.id, total_money)
            except Exception as e:
                print(f"DEBUG: Error updating wealth quest progress: {e}")
    except Exception as e:
        await ctx.send(f"❌ An error occurred during cultivation: {str(e)}")
        return
    
    # Generate cultivation loot (25% chance, modified by role bonuses)
    try:
        loot_result = generate_cultivation_loot(ctx.author.id, ctx.guild)
        
        if loot_result:
            item_name, rarity, base_price = loot_result
            
            # Add to user's inventory with debug logging
            buyer_meta = get_user_meta(ctx.author.id)
            inv = buyer_meta.get("inventory", [])
            
            # Debug: Log before adding
            print(f"DEBUG: Adding {item_name} to inventory for user {ctx.author.id}")
            print(f"DEBUG: Inventory before: {len(inv)} items")
            
            # Create proper inventory item format
            inventory_item = {
                "name": item_name,
                "rarity": rarity,
                "type": "artifact",  # Cultivation loot items are artifacts
                "description": f"A {rarity} quality {item_name} found during cultivation",
                "value": base_price,
                "added_by": ctx.author.id,
                "added_at": int(time.time()),
                "source": "cultivation"
            }
            
            # Use add_item_to_inventory instead of manual manipulation
            add_item_to_inventory(ctx.author.id, inventory_item)
            print(f"DEBUG: Added {item_name} to inventory using add_item_to_inventory")
            
            # Send separate loot embed
            rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
            rarity_color = RARITY_COLOR.get(rarity, 0x2ecc71)
            
            loot_embed = discord.Embed(title="🎁 Cultivation Loot Found!", color=rarity_color)
            loot_embed.description = f"{rarity_emoji} **{item_name}** ({rarity.title()})\nSell Value: {MONEY_ICON} {base_price:,}"
            loot_embed.set_footer(text="Item added to your inventory")
            await ctx.send(embed=loot_embed)
    except Exception as e:
        print(f"Error generating cultivation loot: {e}")
        # Continue with cultivation even if loot generation fails
    
    # Process special rewards (including immortal art rerolls)
    # Note: special_rewards would be generated by cultivation loot system if implemented
    # For now, we'll skip this section since it's not defined
    # TODO: Implement special rewards generation in cultivation loot system
    
    # Store the timestamp using simple integer timestamp
    # Don't overwrite inventory that was updated by add_item_to_inventory
    current_meta = get_user_meta(ctx.author.id)
    current_meta["last_cultivate_timestamp"] = current_timestamp
    set_user_meta(ctx.author.id, current_meta)

    # Update quest progress for cultivation
    try:
        check_quest_progress(ctx.author.id, "cultivate", 1)
    except Exception as e:
        print(f"DEBUG: Error updating quest progress: {e}")

    # Calculate next available time using simple integer timestamp
    next_available_timestamp = int(current_timestamp + cooldown_seconds)

    embed = discord.Embed(title="Cultivation Success", color=0x9b59b6)
    desc = f"✨ You entered a state of deep meditation and gained spiritual insights!"
    
    # Show XP reward (main focus)
    desc += f"\n\n**🎯 Main Reward: {total_xp:,} XP**"
    
    # Show Immortal Art bonus for XP
    if art_bonus > 0:
        desc += f"\n**Immortal Art XP bonus: +{art_bonus} (+{art_pct:.1f}%)**"
    
    # Show equipment bonus for XP
    passive_effects = calculate_passive_effects(ctx.author.id)
    if passive_effects["cultivation_boost"] > 0:
        equipment_bonus = int(total_xp * (passive_effects["cultivation_boost"] / 100))
        desc += f"\n**Equipment XP bonus: +{equipment_bonus} (+{passive_effects['cultivation_boost']}%)**"
    
    # Show money reward if any
    if money_reward > 0:
        desc += f"\n\n**💰 Bonus Money: {MONEY_ICON} {money_reward:,}**"
        if 'sect_name' in locals() and bonus > 0:
            desc += f"\n**Sect bonus from {sect_name}: +{bonus} (+{boost_pct}%)**"
        if 'art_money_bonus' in locals() and art_money_pct > 0:
            desc += f"\n**Immortal Art money bonus: +{art_money_bonus} (+{art_money_pct:.1f}%)**"
        
        # Show equipment bonus for money
        if passive_effects["cultivation_boost"] > 0:
            equipment_money_bonus = int(money_reward * (passive_effects["cultivation_boost"] / 100))
            desc += f"\n**Equipment money bonus: +{equipment_money_bonus} (+{passive_effects['cultivation_boost']}%)**"
    
    embed.description = desc
    embed.add_field(name="XP Gained", value=f"🎯 {total_xp:,}", inline=True)
    if money_reward > 0:
        embed.add_field(name="Money Gained", value=f"💰 {money_reward:,}", inline=True)
    
    # Simple timestamp display - no conversion needed
    embed.add_field(name="Next Available", value=f"<t:{next_available_timestamp}:R> at <t:{next_available_timestamp}:t>", inline=True)
    embed.set_footer(text="Available again in 1 hour")
    await ctx.send(embed=embed)


# Passive role-based income collect (works for both prefix and slash commands)
@bot.hybrid_command(name="collect_income", description="Collect passive income from configured roles")
async def collect_income_impl(ctx: commands.Context):
    """Collect income mapped to roles — each mapping can have its own cooldown stored in role_cooldowns.json"""
    await ctx.defer()
    now = datetime.now(timezone.utc)
    meta = get_user_meta(ctx.author.id)
    last_collects = meta.get("last_collects", {})  # mapping rid -> iso

    income_map = load_json(INCOME_FILE)  # rid -> amount
    cooldowns = load_json(os.path.join(DATA_DIR, "role_cooldowns.json"))  # rid -> hours

    total = 0
    sect_name, boost_pct = get_user_sect_and_boost(ctx.author.id)
    bonus_total = 0
    details = []
    cooldown_details = []
    ready_soon = []

    for rid, amt in income_map.items():
        try:
            rid_int = int(rid)
        except:
            continue
        print(f"DEBUG: Processing role ID {rid} (amount: {amt})")
        role = ctx.guild.get_role(rid_int) if ctx.guild else None
        if not role:
            print(f"DEBUG: Role {rid} not found in guild")
            continue
        if role not in ctx.author.roles:
            print(f"DEBUG: User {ctx.author.id} doesn't have role {role.name} ({rid})")
            continue
        print(f"DEBUG: User {ctx.author.id} has role {role.name} ({rid})")

        cooldown_hours = int(cooldowns.get(rid, 24))
        cooldown_seconds = cooldown_hours * 3600
        last_timestamp = last_collects.get(rid, 0)  # Use integer timestamp
        
        # Check if enough time has passed
        current_timestamp = int(time.time())
        time_since_last = current_timestamp - last_timestamp
        
        if time_since_last < cooldown_seconds:
            # Still on cooldown
            remaining_seconds = cooldown_seconds - time_since_last
            hours = remaining_seconds // 3600
            minutes = (remaining_seconds % 3600) // 60
            seconds = remaining_seconds % 60
            
            next_available_timestamp = int(last_timestamp + cooldown_seconds)
            
            # Format with Discord timestamp
            relative_timestamp = f"<t:{next_available_timestamp}:R>"
            exact_timestamp = f"<t:{next_available_timestamp}:F>"
            time_timestamp = f"<t:{next_available_timestamp}:t>"

            # Add to cooldown list with detailed info
            cooldown_details.append({
                "role": role,
                "amount": amt,
                "next_time": next_available_timestamp,
                "time_left": f"{hours}h {minutes}m {seconds}s",
                "relative_timestamp": relative_timestamp,
                "exact_timestamp": exact_timestamp,
                "time_timestamp": time_timestamp,
                "timestamp": next_available_timestamp
            })

            # Check if it will be ready in the next hour
            if hours == 0 and minutes < 60:
                ready_soon.append({
                    "role": role,
                    "amount": amt,
                    "minutes": minutes,
                    "timestamp": next_available_timestamp,
                    "relative_timestamp": relative_timestamp
                })

            continue

        base_amt = int(amt)
        # apply sect bonus per-role
        total_with_bonus, bonus = calc_with_bonus(base_amt, boost_pct)
        
        # apply sect shop income boosts
        total_with_bonus, sect_bonus, sect_boost_pct = apply_sect_boosts_to_income(ctx.author.id, total_with_bonus)
        
        # apply Immortal Art money boosts
        total_with_bonus, art_bonus, art_pct = apply_money_bonus_for_keys(
            ctx.author.id, total_with_bonus, ["global_gold_gain_pct"]
        )
        total += total_with_bonus
        bonus_total += bonus
        details.append({
            "role": role,
            "amount": base_amt,
            "total": total_with_bonus,
            "bonus": bonus,
            "sect_bonus": sect_bonus,
            "sect_boost_pct": sect_boost_pct,
            "art_bonus": art_bonus,
            "art_pct": art_pct,
        })
        last_collects[rid] = current_timestamp
        
        # Debug: Log successful collection
        print(f"DEBUG: User {ctx.author.id} collected {total_with_bonus} from role {role.name} (base: {base_amt}, bonus: {bonus})")

    if total > 0:
        print(f"DEBUG: Adding {total} cash to user {ctx.author.id}")
        new_balance = add_cash(ctx.author.id, total)
        print(f"DEBUG: New balance for user {ctx.author.id}: {new_balance}")
        
        # Update quest progress for collecting income
        try:
            check_quest_progress(ctx.author.id, "collect", 1)
            # Track wealth quest progress
            check_wealth_quest_progress(ctx.author.id, total)
        except Exception as e:
            print(f"DEBUG: Error updating quest progress: {e}")

    meta["last_collects"] = last_collects
    set_user_meta(ctx.author.id, meta)

    # Create a rich embed with all the information
    if total > 0:
        embed = discord.Embed(
            title=f"💰 Income Collection",
            description=f"You collected **{MONEY_ICON} {total:,}** from your income sources!",
            color=0x2ecc71
        )

        # Format collected income
        if details:
            collected_text = ""
            for item in details:
                line = f"**{item['role'].name}**: {MONEY_ICON} {item['total']:,}"
                if item['bonus'] > 0 and sect_name:
                    line += f"\nSect bonus: {MONEY_ICON} {item['bonus']:,} (+{boost_pct}%)"
                if item.get('sect_bonus', 0) > 0 and sect_name:
                    line += f"\n🏪 Sect Shop: {MONEY_ICON} {item['sect_bonus']:,} (+{item['sect_boost_pct']:.1f}%)"
                if item.get('art_bonus', 0) > 0:
                    line += f"\nImmortal Art: {MONEY_ICON} {item['art_bonus']:,} (+{item['art_pct']:.1f}%)"
                collected_text += line + "\n"
            embed.add_field(name="💰 Collected Income", value=collected_text, inline=False)

        if bonus_total > 0 and sect_name:
            embed.add_field(name="Sect Bonus", value=f"{MONEY_ICON} {bonus_total:,} from {sect_name} (+{boost_pct}%)",
                            inline=False)

        # Add user avatar
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
    else:
        embed = discord.Embed(
            title="💰 Income Collection",
            description="You don't have any income ready to collect right now.",
            color=0xe67e22
        )

        # Add user avatar
        embed.set_thumbnail(url=ctx.author.display_avatar.url)

    # Format cooldown information
    if cooldown_details:
        cooldown_text = ""
        for item in cooldown_details:
            cooldown_text += f"**{item['role'].name}**: Available {item['relative_timestamp']} at <t:{item['timestamp']}:t>\n"
        embed.add_field(name="⏳ On Cooldown", value=cooldown_text, inline=False)

    # Format soon-to-be-ready income
    if ready_soon:
        soon_text = ""
        for item in ready_soon:
            soon_text += f"**{item['role'].name}**: Ready in {item['minutes']} minutes ({item['relative_timestamp']})\n"
        embed.add_field(name="⌛ Ready Soon", value=soon_text, inline=False)

    # Add footer with helpful information
    if cooldown_details or ready_soon:
        embed.set_footer(text="Income sources have different cooldown periods. Check back later!")
    else:
        embed.set_footer(text="All income sources collected! Check back later for more.")

    # Debug summary
    print(f"DEBUG: collect_income summary for user {ctx.author.id}:")
    print(f"  - Total income sources: {len(income_map)}")
    print(f"  - User roles: {[r.name for r in ctx.author.roles]}")
    print(f"  - Total collected: {total}")
    print(f"  - Cooldown details: {len(cooldown_details)}")
    print(f"  - Ready soon: {len(ready_soon)}")

    # Process debt collection for this user
    try:
        user_loans = get_user_loans(ctx.author.id)
        if user_loans["borrowed"]:
            loans = load_loans()
            debt_collected = 0
            
            for loan_name in user_loans["borrowed"]:
                loan = loans[loan_name]
                if loan["status"] == "active":
                    cash, bank = get_balances(ctx.author.id)
                    total_balance = cash + bank
                    
                    # If user is in debt, collect daily payment
                    if total_balance < 0:
                        daily_payment = loan["daily_payment"]
                        
                        if cash >= daily_payment:
                            set_cash(ctx.author.id, cash - daily_payment)
                            process_loan_payment(loan_name, daily_payment)
                            debt_collected += daily_payment
                        elif bank >= daily_payment:
                            set_bank(ctx.author.id, bank - daily_payment)
                            process_loan_payment(loan_name, daily_payment)
                            debt_collected += daily_payment
            
            if debt_collected > 0:
                embed.add_field(name="💸 Debt Collection", value=f"Daily debt collection: {MONEY_ICON} {debt_collected:,}", inline=False)
    except Exception as e:
        print(f"DEBUG: Error in debt collection: {e}")

    await ctx.send(embed=embed)


# Shortened prefix command for collect_income
@bot.command(name="collect")
async def collect_short(ctx):
    """Shortened version of collect_income command"""
    await collect_income_impl(ctx)


# Admin helper to map role -> cooldown (hybrid command)
@bot.hybrid_command(name="set_income_role", description="Set a role's income collection cooldown (Admin only)")
@app_commands.describe(role="The role to configure", cooldown_hours="Hours between collections (default: 24)")
@app_commands.checks.has_permissions(administrator=True)
async def set_income_role(ctx, role: discord.Role, cooldown_hours: int = 24):
    """Set a role's income collection cooldown - edits existing or creates new"""
    await ctx.defer()
    
    data = load_json(INCOME_FILE)
    cooldowns = load_json(os.path.join(DATA_DIR, "role_cooldowns.json"))
    
    # Check if role already exists
    role_exists = str(role.id) in data
    previous_cooldown = cooldowns.get(str(role.id), 24)
    
    # Set default amount if role doesn't exist (you can customize this)
    if not role_exists:
        data[str(role.id)] = 1000  # Default amount for new roles
    
    # Update cooldown
    cooldowns[str(role.id)] = int(cooldown_hours)
    
    # Save both files
    save_json(INCOME_FILE, data)
    save_json(os.path.join(DATA_DIR, "role_cooldowns.json"), cooldowns)
    
    # Create appropriate embed message
    if role_exists:
        embed = discord.Embed(title="✅ Income Role Updated", color=0x2ecc71)
        embed.description = f"**{role.name}** cooldown updated from {previous_cooldown}h to {cooldown_hours}h"
        embed.add_field(name="Role", value=role.mention, inline=True)
        embed.add_field(name="Previous Cooldown", value=f"{previous_cooldown}h", inline=True)
        embed.add_field(name="New Cooldown", value=f"{cooldown_hours}h", inline=True)
        embed.set_footer(text="Role income amount unchanged • Users can use /collect_income or ?collect")
    else:
        embed = discord.Embed(title="✅ New Income Role Created", color=0x2ecc71)
        embed.description = f"**{role.name}** now gives {MONEY_ICON} 1,000 every {cooldown_hours} hours"
        embed.add_field(name="Role", value=role.mention, inline=True)
        embed.add_field(name="Default Amount", value=f"{MONEY_ICON} 1,000", inline=True)
        embed.add_field(name="Cooldown", value=f"{cooldown_hours}h", inline=True)
        embed.set_footer(text="New role created • Users can use /collect_income or ?collect")
    
    await ctx.send(embed=embed)


@bot.tree.command(name="remove_income_role", description="Remove a role from income system (Admin only)")
@app_commands.describe(role="The role to remove from income system")
@app_commands.checks.has_permissions(administrator=True)
async def remove_income_role_slash(interaction: discord.Interaction, role: discord.Role):
    """Remove a role from the income system"""
    ctx = await commands.Context.from_interaction(interaction)
    
    data = load_json(INCOME_FILE)
    cooldowns = load_json(os.path.join(DATA_DIR, "role_cooldowns.json"))
    
    if str(role.id) in data:
        amount = data[str(role.id)]
        del data[str(role.id)]
        save_json(INCOME_FILE, data)
        
        if str(role.id) in cooldowns:
            del cooldowns[str(role.id)]
            save_json(os.path.join(DATA_DIR, "role_cooldowns.json"), cooldowns)
        
        embed = discord.Embed(title="✅ Income Role Removed", color=0x2ecc71)
        embed.description = f"**{role.name}** no longer gives income"
        embed.add_field(name="Role", value=role.mention, inline=True)
        embed.add_field(name="Previous Amount", value=f"{MONEY_ICON} {amount:,}", inline=True)
        embed.set_footer(text="Users with this role will no longer receive income from it")
    else:
        embed = discord.Embed(title="❌ Role Not Found", color=0xe74c3c)
        embed.description = f"**{role.name}** was not configured for income"
    
    await ctx.send(embed=embed)


@bot.command(name="remove_income_role")
@commands.has_permissions(administrator=True)
async def remove_income_role_prefix(ctx, role: discord.Role):
    """Remove a role from the income system (prefix command version)"""
    data = load_json(INCOME_FILE)
    cooldowns = load_json(os.path.join(DATA_DIR, "role_cooldowns.json"))
    
    if str(role.id) in data:
        amount = data[str(role.id)]
        del data[str(role.id)]
        save_json(INCOME_FILE, data)
        
        if str(role.id) in cooldowns:
            del cooldowns[str(role.id)]
            save_json(os.path.join(DATA_DIR, "role_cooldowns.json"), cooldowns)
        
        embed = discord.Embed(title="✅ Income Role Removed", color=0x2ecc71)
        embed.description = f"**{role.name}** no longer gives income"
        embed.add_field(name="Role", value=role.mention, inline=True)
        embed.add_field(name="Previous Amount", value=f"{MONEY_ICON} {amount:,}", inline=True)
        embed.set_footer(text="Users with this role will no longer receive income from it")
    else:
        embed = discord.Embed(title="❌ Role Not Found", color=0xe74c3c)
        embed.description = f"**{role.name}** was not configured for income"
    
    await ctx.send(embed=embed)


# Removed income_roles slash command to reduce command count
@app_commands.checks.has_permissions(administrator=True)
async def list_income_roles_slash(interaction: discord.Interaction):
    """List all roles configured for income"""
    ctx = await commands.Context.from_interaction(interaction)
    
    data = load_json(INCOME_FILE)
    cooldowns = load_json(os.path.join(DATA_DIR, "role_cooldowns.json"))
    
    if not data:
        embed = discord.Embed(title="💰 Income Roles", color=0xe67e22)
        embed.description = "No income roles are currently configured"
        await ctx.send(embed=embed)
        return
    
    embed = discord.Embed(title="💰 Configured Income Roles", color=0x2ecc71)
    embed.description = f"**{len(data)}** roles configured for income generation"
    
    for role_id, amount in data.items():
        role = ctx.guild.get_role(int(role_id))
        cooldown = cooldowns.get(role_id, 24)
        
        if role:
            embed.add_field(
                name=f"💰 {role.name}",
                value=f"**Amount:** {MONEY_ICON} {amount:,}\n**Cooldown:** {cooldown}h\n**Role:** {role.mention}",
                inline=True
            )
        else:
            embed.add_field(
                name=f"❌ Unknown Role ({role_id})",
                value=f"**Amount:** {MONEY_ICON} {amount:,}\n**Cooldown:** {cooldown}h\n**Status:** Role not found in server",
                inline=True
            )
    
    embed.set_footer(text="Use /set_income_role to add new income roles")
    await ctx.send(embed=embed)


# Removed income_roles prefix command to reduce command count
@commands.has_permissions(administrator=True)
async def list_income_roles_prefix(ctx):
    """List all roles configured for income (prefix command version)"""
    data = load_json(INCOME_FILE)
    cooldowns = load_json(os.path.join(DATA_DIR, "role_cooldowns.json"))
    
    if not data:
        embed = discord.Embed(title="💰 Income Roles", color=0xe67e22)
        embed.description = "No income roles are currently configured"
        await ctx.send(embed=embed)
        return
    
    embed = discord.Embed(title="💰 Configured Income Roles", color=0x2ecc71)
    embed.description = f"**{len(data)}** roles configured for income generation"
    
    for role_id, amount in data.items():
        role = ctx.guild.get_role(int(role_id))
        cooldown = cooldowns.get(role_id, 24)
        
        if role:
            embed.add_field(
                name=f"💰 {role.name}",
                value=f"**Amount:** {MONEY_ICON} {amount:,}\n**Cooldown:** {cooldown}h\n**Role:** {role.mention}",
                inline=True
            )
        else:
            embed.add_field(
                name=f"❌ Unknown Role ({role_id})",
                value=f"**Amount:** {MONEY_ICON} {amount:,}\n**Cooldown:** {cooldown}h\n**Status:** Role not found in server",
                inline=True
            )
    
    embed.set_footer(text="Use ?set_income_role to add new income roles")
    await ctx.send(embed=embed)


# -----------------------
# Gambling role win-rate mapping
# -----------------------
GAMBLE_ROLES_FILE = os.path.join(DATA_DIR, "gamble_roles.json")
ensure_file(GAMBLE_ROLES_FILE, {})


async def _get_gamble_bonus(game: str, member: discord.Member) -> int:
    data = load_json(GAMBLE_ROLES_FILE)
    bonuses = data.get(game.lower(), {})
    total = 0
    for r in member.roles:
        b = bonuses.get(str(r.id))
        if isinstance(b, (int, float)):
            total += int(b)
    return max(-50, min(50, total))


@bot.command(name="gambling_role_chance")
@commands.has_permissions(administrator=True)
async def gambling_role_chance(ctx, game: str, role: discord.Role, win_rate_bonus_pct: int):
    """Set a win-rate bonus percentage for a role for a specific game (roulette/blackjack)."""
    game = (game or "").lower()
    if game not in ("roulette", "blackjack"):
        return await send_embed(ctx, "Gambling", "Game must be 'roulette' or 'blackjack'.", 0xe74c3c)

    bonus = max(-50, min(50, int(win_rate_bonus_pct)))
    data = load_json(GAMBLE_ROLES_FILE)
    data.setdefault(game, {})[str(role.id)] = bonus
    save_json(GAMBLE_ROLES_FILE, data)

    sign = "+" if bonus >= 0 else ""
    await send_embed(ctx, "Gambling", f"Set {game.title()} win-rate bonus for {role.mention}: {sign}{bonus}%", 0x2ecc71)

# -----------------------
# Store & inventory basic helpers
# -----------------------
# Old inventory system removed - using new system instead


def get_item_rarity(item_name: str) -> str:
    """Get the rarity of an item from store or cultivation loot"""
    store = load_json(STORE_FILE, {})
    item_key = item_name.lower()
    
    # Check store items
    if item_key in store:
        return store[item_key].get("rarity", "common").lower()
    
    # Check cultivation loot items
    for rarity, items in CULTIVATION_LOOT_ITEMS.items():
        if item_key in [name.lower() for name in items.keys()]:
            return rarity.lower()
    
    # Default rarity
    return "common"


def combine_store_item_effects(item1: dict, item2: dict) -> dict:
    """Combine the effects of two store items"""
    result = {}
    
    # Copy basic properties from first item
    for key in ["rarity", "description", "price"]:
        if key in item1:
            result[key] = item1[key]
    
    # Combine effects
    result["effects"] = {}
    
    # Add effects from first item
    if "effects" in item1:
        for effect, value in item1["effects"].items():
            result["effects"][effect] = value
    
    # Add or enhance effects from second item
    if "effects" in item2:
        for effect, value in item2["effects"].items():
            if effect in result["effects"]:
                # If effect exists, enhance it (add values)
                result["effects"][effect] += value
            else:
                # If effect doesn't exist, add it
                result["effects"][effect] = value
    
    # Combine command effects (prioritize the first item)
    if "command" in item1:
        result["command"] = item1["command"]
    elif "command" in item2:
        result["command"] = item2["command"]
    
    # Combine limit uses (use the more restrictive limits)
    if "limit_uses" in item1 or "limit_uses" in item2:
        limit1 = item1.get("limit_uses", {})
        limit2 = item2.get("limit_uses", {})
        result["limit_uses"] = {}
        for period in ["daily", "weekly", "monthly"]:
            if period in limit1 and period in limit2:
                result["limit_uses"][period] = min(limit1[period], limit2[period])
            elif period in limit1:
                result["limit_uses"][period] = limit1[period]
            elif period in limit2:
                result["limit_uses"][period] = limit2[period]
    
    # Set combined description
    result["description"] = f"Combined item with effects from {item1.get('name', 'unknown')} and {item2.get('name', 'unknown')}"
    
    return result


@bot.hybrid_command(name="add_store_item", description="Add a new item to the store with effects")
@app_commands.describe(
    key="Item name/key",
    price="Item price in spirit stones",
    description="Item description",
    min_rank="Minimum rank required to buy (optional)",
    rarity="Item rarity (common, uncommon, rare, legendary, mythic, divine)",
    stock="Initial stock quantity (default: 999)",
    usable="Whether the item can be used/consumed (default: true)",
    instant_use="Whether item is consumed immediately on purchase (default: false)",
    effect_type="Type of effect to add",
    effect_value="Value for the effect (role ID, amount, etc.)",
    duration_days="Duration in days for temporary effects",
    daily_limit="Daily usage limit (optional)",
    weekly_limit="Weekly usage limit (optional)",
    monthly_limit="Monthly usage limit (optional)"
)
@app_commands.choices(
    rarity=[
        app_commands.Choice(name="Common", value="common"),
        app_commands.Choice(name="Uncommon", value="uncommon"),
        app_commands.Choice(name="Rare", value="rare"),
        app_commands.Choice(name="Epic", value="epic"),
        app_commands.Choice(name="Legendary", value="legendary"),
        app_commands.Choice(name="Mythic", value="mythic"),
        app_commands.Choice(name="Divine", value="divine")
    ],
    usable=[
        app_commands.Choice(name="✅ Usable", value="true"),
        app_commands.Choice(name="❌ Display Only", value="false")
    ],
    instant_use=[
        app_commands.Choice(name="🔥 Instant Use (Consumed on Purchase)", value="true"),
        app_commands.Choice(name="📦 Goes to Inventory", value="false")
    ],
    effect_type=[
        app_commands.Choice(name="Add Role", value="add_role"),
        app_commands.Choice(name="Remove Role", value="remove_role"),
        app_commands.Choice(name="Temp Role", value="temp_role"),
        app_commands.Choice(name="Spirit Beast", value="spirit_beast"),
        app_commands.Choice(name="Immortal Art Reroll", value="immortal_art_reroll"),
        app_commands.Choice(name="Add Money", value="add_money"),
        app_commands.Choice(name="XP Boost", value="xp_boost"),
        app_commands.Choice(name="Command", value="command"),
        app_commands.Choice(name="None", value="none")
    ]
)
async def add_store_item_hybrid(
    ctx,
    key: str,
    price: int,
    description: str = "No description",
    min_rank: str = None,
    rarity: str = "common",
    stock: int = 999,
    usable: str = "true",
    instant_use: str = "false",
    effect_type: str = "none",
    effect_value: str = None,
    duration_days: int = 7,
    daily_limit: int = None,
    weekly_limit: int = None,
    monthly_limit: int = None
):
    """Add a new item to the store with customizable effects"""
    # Check if user is administrator
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    # Handle both slash and prefix commands
    if hasattr(ctx, 'interaction') and ctx.interaction:
        # Slash command - defer response
        await ctx.interaction.response.defer(ephemeral=True)
        interaction = ctx.interaction
    else:
        # Prefix command - no defer needed
        interaction = None
    
    store = load_json(STORE_FILE)
    
    # Basic validation
    min_rank_index = 0
    if min_rank:
        try:
            min_rank_index = get_rank_index(min_rank.lower())
        except:
            if interaction:
                await interaction.followup.send(f"Invalid Rank: {min_rank}. Valid ranks: {', '.join(SECT_RANKS)}", ephemeral=True)
            else:
                await send_embed(ctx, "Invalid Rank", f"Invalid rank: {min_rank}. Valid ranks: {', '.join(SECT_RANKS)}", 0xe74c3c)
            return
    
    rarity = (rarity or "common").lower()
    if rarity not in RARITY_LIST:
        if interaction:
            await interaction.followup.send(f"Invalid Rarity: {rarity}. Valid rarities: {', '.join(RARITY_LIST)}", ephemeral=True)
        else:
            await send_embed(ctx, "Invalid Rarity", f"Invalid rarity: {rarity}. Valid rarities: {', '.join(RARITY_LIST)}", 0xe74c3c)
        return
    
    # Parse instant_use parameter
    instant_use = (instant_use or "false").lower() == "true"
    
    # Validate price parameter
    if price is None or price <= 0:
        if interaction:
            await interaction.followup.send("Price is required and must be a positive number.", ephemeral=True)
        else:
            await send_embed(ctx, "Invalid Price", "Price is required and must be a positive number.", 0xe74c3c)
        return
    
    # Validate stock parameter
    if stock is None or stock < 0:
        if interaction:
            await interaction.followup.send("Stock must be a non-negative number.", ephemeral=True)
        else:
            await send_embed(ctx, "Invalid Stock", "Stock must be a non-negative number.", 0xe74c3c)
        return
    
    # Validate and convert usable parameter
    if usable is None:
        usable_bool = True  # Default to usable if not specified
    else:
        usable_bool = usable.lower() == "true"  # Convert string to boolean
    
    # Create base item structure
    item_data = {
        "price": price,
        "description": description,
        "stock": stock,
        "min_rank": min_rank_index,
        "rarity": rarity,
        "usable": usable_bool,
        "instant_use": instant_use,
        "effects": {}
    }

    # Handle effects based on effect_type
    effects_info = ""
    if effect_type != "none" and effect_value:
        if effect_type == "add_role":
            try:
                role_id_int = int(effect_value)
                role = ctx.guild.get_role(role_id_int)
                if role:
                    item_data["effects"]["add_role"] = role_id_int
                    effects_info = f"\n**Effect:** Adds role {role.mention}"
                else:
                    if interaction:
                        await interaction.followup.send(f"Role ID {effect_value} not found in this server.", ephemeral=True)
                    else:
                        await send_embed(ctx, "Role Not Found", f"Role ID {effect_value} not found in this server.", 0xe74c3c)
                    return
            except ValueError:
                if interaction:
                    await interaction.followup.send("Invalid role ID. Please provide a valid role ID number.", ephemeral=True)
                else:
                    await send_embed(ctx, "Invalid Role ID", "Invalid role ID. Please provide a valid role ID number.", 0xe74c3c)
                return
                
        elif effect_type == "remove_role":
            try:
                role_id_int = int(effect_value)
                role = ctx.guild.get_role(role_id_int)
                if role:
                    item_data["effects"]["remove_role"] = role_id_int
                    effects_info = f"\n**Effect:** Removes role {role.mention}"
                else:
                    if interaction:
                        await interaction.followup.send(f"Role ID {effect_value} not found in this server.", ephemeral=True)
                    else:
                        await send_embed(ctx, "Role Not Found", f"Role ID {effect_value} not found in this server.", 0xe74c3c)
                    return
            except ValueError:
                if interaction:
                    await interaction.followup.send("Invalid role ID. Please provide a valid role ID number.", ephemeral=True)
                else:
                    await send_embed(ctx, "Invalid Role ID", "Invalid role ID. Please provide a valid role ID number.", 0xe74c3c)
                return
                
        elif effect_type == "temp_role":
            try:
                role_id_int = int(effect_value)
                role = ctx.guild.get_role(role_id_int)
                if role:
                    item_data["effects"]["temp_role"] = {
                        "role_id": role_id_int,
                        "duration_days": duration_days
                    }
                    effects_info = f"\n**Effect:** Temporarily adds role {role.mention} for {duration_days} days"
                else:
                    if interaction:
                        await interaction.followup.send(f"Role ID {effect_value} not found in this server.", ephemeral=True)
                    else:
                        await send_embed(ctx, "Role Not Found", f"Role ID {effect_value} not found in this server.", 0xe74c3c)
                    return
            except ValueError:
                if interaction:
                    await interaction.followup.send("Invalid role ID. Please provide a valid role ID number.", ephemeral=True)
                else:
                    await send_embed(ctx, "Invalid Role ID", "Invalid role ID. Please provide a valid role ID number.", 0xe74c3c)
                return
                
        elif effect_type == "spirit_beast":
            try:
                win_chance = int(effect_value)
                if win_chance < 1 or win_chance > 100:
                    if interaction:
                        await interaction.followup.send("Win chance must be between 1 and 100.", ephemeral=True)
                    else:
                        await send_embed(ctx, "Invalid Win Chance", "Win chance must be between 1 and 100.", 0xe74c3c)
                    return
                item_data["spirit_animal"] = True
                item_data["activate_on_buy"] = True
                item_data["win_chance"] = win_chance
                effects_info = f"\n**Effect:** Spirit beast with {win_chance}% win chance"
            except ValueError:
                if interaction:
                    await interaction.followup.send("Invalid win chance. Please provide a number between 1-100.", ephemeral=True)
                else:
                    await send_embed(ctx, "Invalid Win Chance", "Invalid win chance. Please provide a number between 1-100.", 0xe74c3c)
                return
                
        elif effect_type == "immortal_art_reroll":
            try:
                reroll_amount = int(effect_value)
                if reroll_amount < 1:
                    if interaction:
                        await interaction.followup.send("Reroll amount must be at least 1.", ephemeral=True)
                    else:
                        await send_embed(ctx, "Invalid Reroll Amount", "Reroll amount must be at least 1.", 0xe74c3c)
                    return
                item_data["effects"]["immortal_art_reroll"] = reroll_amount
                effects_info = f"\n**Effect:** Grants {reroll_amount} immortal art reroll(s)"
            except ValueError:
                if interaction:
                    await interaction.followup.send("Invalid reroll amount. Please provide a valid number.", ephemeral=True)
                else:
                    await send_embed(ctx, "Invalid Reroll Amount", "Invalid reroll amount. Please provide a valid number.", 0xe74c3c)
                return
                
        elif effect_type == "add_money":
            try:
                money_amount = int(effect_value)
                if money_amount < 1:
                    if interaction:
                        await interaction.followup.send("Money amount must be at least 1.", ephemeral=True)
                    else:
                        await send_embed(ctx, "Invalid Money Amount", "Money amount must be at least 1.", 0xe74c3c)
                    return
                item_data["effects"]["add_money"] = money_amount
                effects_info = f"\n**Effect:** Adds {MONEY_ICON} {money_amount:,} to wallet"
            except ValueError:
                if interaction:
                    await interaction.followup.send("Invalid money amount. Please provide a valid number.", ephemeral=True)
                else:
                    await send_embed(ctx, "Invalid Money Amount", "Invalid money amount. Please provide a valid number.", 0xe74c3c)
                return
                
        elif effect_type == "xp_boost":
            try:
                xp_amount = int(effect_value)
                if xp_amount < 1:
                    if interaction:
                        await interaction.followup.send("XP amount must be at least 1.", ephemeral=True)
                    else:
                        await send_embed(ctx, "Invalid XP Amount", "XP amount must be at least 1.", 0xe74c3c)
                    return
                item_data["effects"]["xp_boost"] = xp_amount
                effects_info = f"\n**Effect:** Grants {xp_amount:,} XP"
            except ValueError:
                if interaction:
                    await interaction.followup.send("Invalid XP amount. Please provide a valid number.", ephemeral=True)
                else:
                    await send_embed(ctx, "Invalid XP Amount", "Invalid XP amount. Please provide a valid number.", 0xe74c3c)
                return
                
        elif effect_type == "command":
            if not effect_value:
                if interaction:
                    await interaction.followup.send("Command effect requires a command string (e.g., '/moderation xp add {user} {value}').", ephemeral=True)
                else:
                    await send_embed(ctx, "Invalid Command", "Command effect requires a command string (e.g., '/moderation xp add {user} {value}').", 0xe74c3c)
                return
            
            # For command effects, we need to extract the actual value from the command string
            # The effect_value should be the command string, but we need to parse it to get the actual value
            command_parts = effect_value.split()
            actual_value = "100"  # Default value
            
            # Validate command format
            if not effect_value.startswith('/'):
                if interaction:
                    await interaction.followup.send("Command must start with '/' (e.g., '/moderation xp add {user} {value}').", ephemeral=True)
                else:
                    await send_embed(ctx, "Invalid Command", "Command must start with '/' (e.g., '/moderation xp add {user} {value}').", 0xe74c3c)
                return
            
            # Try to extract the actual value from the command string
            if len(command_parts) >= 4 and command_parts[0] == "moderation" and command_parts[1] == "xp" and command_parts[2] == "add":
                # For moderation xp add commands, the value is typically the last part
                if len(command_parts) >= 5:
                    actual_value = command_parts[4]  # The actual XP value
                else:
                    actual_value = "100"  # Default if no value specified
                
                # Validate that the command has the required placeholders
                if "{user}" not in effect_value or "{value}" not in effect_value:
                    if interaction:
                        await interaction.followup.send("Command must include {user} and {value} placeholders (e.g., '/moderation xp add {user} {value}').", ephemeral=True)
                    else:
                        await send_embed(ctx, "Invalid Command", "Command must include {user} and {value} placeholders (e.g., '/moderation xp add {user} {value}').", 0xe74c3c)
                    return
            
            # Store both the command string and the actual value
            item_data["effects"]["command"] = effect_value
            item_data["effects"]["command_value"] = actual_value  # Store the actual value separately
            effects_info = f"\n**Effect:** Executes command: {effect_value}\n**Command Value:** {actual_value}"

    # Add limit uses system
    limit_uses = {}
    if daily_limit and daily_limit > 0:
        limit_uses["daily"] = daily_limit
    if weekly_limit and weekly_limit > 0:
        limit_uses["weekly"] = weekly_limit
    if monthly_limit and monthly_limit > 0:
        limit_uses["monthly"] = monthly_limit
    
    if limit_uses:
        # Add limit uses fields to the embed description
        limit_uses_info = ""
        if limit_uses.get("daily"):
            limit_uses_info += f"\n**Daily Limit:** {limit_uses['daily']} uses"
        if limit_uses.get("weekly"):
            limit_uses_info += f"\n**Weekly Limit:** {limit_uses['weekly']} uses"
        if limit_uses.get("monthly"):
            limit_uses_info += f"\n**Monthly Limit:** {limit_uses['monthly']} uses"
        
        effects_info += limit_uses_info
        item_data["limit_uses"] = limit_uses

    # Save to store
    store[key.lower()] = item_data
    save_json(STORE_FILE, store)
    
    # Create response embed
    embed = discord.Embed(title="✅ Store Item Added", color=RARITY_COLOR.get(rarity, 0x2ecc71))
    
    req = f" — Requires {SECT_RANKS[min_rank_index]}" if min_rank_index > 0 else ""
    
    embed.description = (
        f"{RARITY_EMOJI.get(rarity, '')} **{key}** ({rarity.title()}) added for {MONEY_ICON} {price:,} to the store{req}."
        f"{effects_info}"
    )
    
    # Add item details
    usable_status = "✅ Usable" if usable_bool else "❌ Display Only"
    embed.add_field(name="📋 Item Details", value=f"**Key:** {key.lower()}\n**Price:** {MONEY_ICON} {price:,}\n**Stock:** {stock:,}\n**Min Rank:** {SECT_RANKS[min_rank_index]}\n**Status:** {usable_status}", inline=True)
    
    if effect_type != "none":
        embed.add_field(name="✨ Effect", value=f"**Type:** {effect_type.replace('_', ' ').title()}\n**Value:** {effect_value}", inline=True)
    
    embed.set_footer(text=f"Use /shop to view the store • Use /delete_store_item {key} to remove")
    
    if interaction:
        await interaction.followup.send(embed=embed)
    else:
        await ctx.send(embed=embed)

# Add alias for the hybrid command
add_store_item = add_store_item_hybrid

async def execute_moderation_xp_command(ctx, user_mention: str, xp_value: str):
    """Execute a moderation XP command on the external moderation bot"""
    try:
        print(f"DEBUG: Executing moderation XP command: +{xp_value} XP for {user_mention}")
        
        # Extract user ID from mention (remove <@ > and get the ID)
        user_id = user_mention.strip('<@!>')
        
        # Use the existing external XP command function
        # This will send the command as a message in the channel for the moderation bot to pick up
        success, message = await execute_external_xp_command(ctx, int(user_id), int(xp_value))
        
        if success:
            print(f"DEBUG: Successfully executed external XP command: {message}")
            return True
        else:
            print(f"DEBUG: Failed to execute external XP command: {message}")
            return False
        
    except Exception as e:
        print(f"Error in execute_moderation_xp_command: {e}")
        return False

async def execute_item_command(ctx, command_str: str, user_mention: str, effect_value: str):
    """Execute a command from an item effect"""
    try:
        # Debug logging
        print(f"DEBUG: execute_item_command called with:")
        print(f"DEBUG: - command_str: {command_str}")
        print(f"DEBUG: - user_mention: {user_mention}")
        print(f"DEBUG: - effect_value: {effect_value}")
        
        # Replace placeholders in the command
        command = command_str.replace("{user}", user_mention).replace("{value}", effect_value)
        print(f"DEBUG: - command after replacement: {command}")
        
        # Remove the slash if present
        if command.startswith('/'):
            command = command[1:]
            print(f"DEBUG: - command after slash removal: {command}")
        
        # Split command into parts
        parts = command.split()
        print(f"DEBUG: - command parts: {parts}")
        if len(parts) < 2:
            return False, "Invalid command format"
        
        # Check if it's a moderation command for the specific app
        if parts[0] == "moderation" and len(parts) >= 4:
            # Validate the moderation command format
            if parts[1] == "xp" and parts[2] == "add":
                # This is a valid moderation xp add command
                # We need to actually execute this command on the moderation bot
                try:
                    # Extract user ID from mention
                    user_mention = parts[3]
                    xp_value = parts[4] if len(parts) > 4 else "100"
                    
                    # Execute the actual moderation command
                    success = await execute_moderation_xp_command(ctx, user_mention, xp_value)
                    if success:
                        return True, f"Moderation XP command executed: +{xp_value} XP for {user_mention}"
                    else:
                        return False, "Failed to execute moderation command on external bot"
                except Exception as e:
                    print(f"Error executing moderation command: {e}")
                    return False, f"Error executing moderation command: {str(e)}"
            else:
                return False, f"Unknown moderation command: {' '.join(parts[1:])}"
        
        # Check if it's a valid command format
        if len(parts) < 3:
            return False, f"Command too short. Expected format: /command action target [value]"
        
        return False, f"Unknown command: {parts[0]}"
        
    except Exception as e:
        return False, f"Error executing command: {str(e)}"

def check_item_usage_limits(user_id: int, item_name: str, limit_uses: dict) -> tuple[bool, str]:
    """Check if user can use an item based on usage limits"""
    try:
        # Get user meta to track usage
        meta = get_user_meta(user_id)
        if not meta:
            meta = {}
        
        # Initialize usage tracking if it doesn't exist
        if "item_usage" not in meta:
            meta["item_usage"] = {}
        
        if item_name not in meta["item_usage"]:
            meta["item_usage"][item_name] = {
                "daily": {"count": 0, "reset_date": datetime.now().date().isoformat()},
                "weekly": {"count": 0, "reset_date": (datetime.now() - timedelta(days=datetime.now().weekday())).date().isoformat()},
                "monthly": {"count": 0, "reset_date": datetime.now().replace(day=1).date().isoformat()}
            }
        
        usage = meta["item_usage"][item_name]
        current_date = datetime.now().date()
        
        # Check daily limit
        if "daily" in limit_uses:
            daily_limit = limit_uses["daily"]
            daily_reset = datetime.fromisoformat(usage["daily"]["reset_date"]).date()
            
            if current_date > daily_reset:
                # Reset daily count
                usage["daily"]["count"] = 0
                usage["daily"]["reset_date"] = current_date.isoformat()
            
            if usage["daily"]["count"] >= daily_limit:
                return False, f"Daily limit reached ({daily_limit} uses per day)"
        
        # Check weekly limit
        if "weekly" in limit_uses:
            weekly_limit = limit_uses["weekly"]
            week_start = current_date - timedelta(days=current_date.weekday())
            weekly_reset = datetime.fromisoformat(usage["weekly"]["reset_date"]).date()
            
            if week_start > weekly_reset:
                # Reset weekly count
                usage["weekly"]["count"] = 0
                usage["weekly"]["reset_date"] = week_start.isoformat()
            
            if usage["weekly"]["count"] >= weekly_limit:
                return False, f"Weekly limit reached ({weekly_limit} uses per week)"
        
        # Check monthly limit
        if "monthly" in limit_uses:
            monthly_limit = limit_uses["monthly"]
            month_start = current_date.replace(day=1)
            monthly_reset = datetime.fromisoformat(usage["monthly"]["reset_date"]).date()
            
            if month_start > monthly_reset:
                # Reset monthly count
                usage["monthly"]["count"] = 0
                usage["monthly"]["reset_date"] = month_start.isoformat()
            
            if usage["monthly"]["count"] >= monthly_limit:
                return False, f"Monthly limit reached ({monthly_limit} uses per month)"
        
        return True, "Usage allowed"
        
    except Exception as e:
        print(f"Error checking item usage limits: {e}")
        return False, f"Error checking limits: {str(e)}"

def increment_item_usage(user_id: int, item_name: str):
    """Increment usage counters for an item"""
    try:
        meta = get_user_meta(user_id)
        if not meta or "item_usage" not in meta:
            return
        
        if item_name in meta["item_usage"]:
            usage = meta["item_usage"][item_name]
            usage["daily"]["count"] += 1
            usage["weekly"]["count"] += 1
            usage["monthly"]["count"] += 1
            
            set_user_meta(user_id, meta)
            
    except Exception as e:
        print(f"Error incrementing item usage: {e}")

@bot.hybrid_command(name="shop", description="View store items with pagination controls")
async def shop(ctx, page: int = 1):
    store = load_json(STORE_FILE)
    if not store:
        await send_embed(ctx, "Store", "Store is empty.", 0xe67e22)
        return
    # Filter by sect rank visibility
    meta = get_user_meta(ctx.author.id)
    user_rank_idx = get_rank_index(meta.get("sect_rank", SECT_RANKS[0]))
    def is_visible(item):
        return user_rank_idx >= int(item.get("min_rank", 0))
    items = [(k, v) for k, v in store.items() if is_visible(v)]
    
    # Sort items by price from lowest (top) to highest (bottom)
    items.sort(key=lambda x: x[1].get('price', 0))
    
    per = 8
    total_pages = (len(items) + per - 1) // per
    page = max(1, min(page, total_pages))
    start = (page - 1) * per
    slice_ = items[start:start + per]
    # Fancy card-like embed
    embed = discord.Embed(title="🏪 Heavenly Market", color=0x00ffcc)
    embed.description = "**Auto-restock every 3 days** • Use `/restock_status` to check schedule"
    for k, v in slice_:
        req_idx = int(v.get('min_rank', 0))
        req_txt = f" • Req: {SECT_RANKS[req_idx]}" if req_idx > 0 else ""
        rarity_key = v.get('rarity', 'common').lower()
        rarity_txt = rarity_key.title()
        emoji = RARITY_EMOJI.get(rarity_key, '')
        min_r = v.get('min_rarity')
        max_rc = int(v.get('max_rarity_chance', 0))
        rarity_extra = ""
        if min_r:
            rarity_extra = f"\nMin Rarity: {min_r.title()}"
            if max_rc:
                rarity_extra += f" • Max Rarity Chance: {max_rc}%"
        price_txt = f"{MONEY_ICON} {int(v.get('price', 0)):,}"
        stock_txt = v.get('stock', '∞')
        name_line = f"{emoji} {k.capitalize()} — {price_txt} ({rarity_txt})"
        # Add role and money action info
        role_action = v.get('role_action')
        role_id = v.get('role_id')
        money_action = v.get('money_action')
        money_amount = v.get('money_amount', 0)
        
        action_info = ""
        if role_action and role_id:
            action_info += f"\n**Role:** {role_action.title()}"
        if money_action and money_amount:
            action_info += f"\n**Money:** {money_action.title()} {MONEY_ICON} {money_amount:,}"

        # Spirit animal info
        if v.get('spirit_animal'):
            action_info += f"\n**Spirit Animal:** Yes"
            action_info += f"\nActivate on buy: {'Yes' if v.get('activate_on_buy') else 'No'}"
            action_info += f"\nWin Chance: {int(v.get('win_chance', 50))}%"
        
        # Usable status and instant use status
        usable_txt = "✅ Usable" if v.get('usable', True) else "❌ Display Only"
        instant_txt = "🔥 Instant Use" if v.get('instant_use', False) else "📦 Inventory"
        status_txt = f"{usable_txt} • {instant_txt}"
        desc_line = f"{v.get('description', '')}\nStock: {stock_txt}{req_txt}{rarity_extra}{action_info}\nStatus: {status_txt}"
        embed.add_field(name=name_line, value=desc_line, inline=False)
    embed.set_footer(text=f"Page {page}/{total_pages} • Use /buy_item <name>")
    
    # Add pagination controls
    view = discord.ui.View()
    
    # Previous page button
    prev_button = discord.ui.Button(style=discord.ButtonStyle.secondary, label="◀", disabled=(page <= 1))
    async def prev_callback(interaction):
        if interaction.user.id != ctx.author.id:
            return await interaction.response.send_message("You can't use this button.", ephemeral=True)
        await interaction.response.defer()
        await shop(ctx, page - 1)
    prev_button.callback = prev_callback
    view.add_item(prev_button)
    
    # Next page button
    next_button = discord.ui.Button(style=discord.ButtonStyle.secondary, label="▶", disabled=(page >= total_pages))
    async def next_callback(interaction):
        if interaction.user.id != ctx.author.id:
            return await interaction.response.send_message("You can't use this button.", ephemeral=True)
        await interaction.response.defer()
        await shop(ctx, page + 1)
    next_button.callback = next_callback
    view.add_item(next_button)
    
    await ctx.send(embed=embed, view=view)


@bot.command(name="delete_store_item")
@commands.has_permissions(administrator=True)
async def delete_store_item(ctx, *, item_name: str):
    """Delete a store item by key or display name (case-insensitive)."""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    store = load_json(STORE_FILE)
    if not store:
        await send_embed(ctx, "Store Admin", "Store is empty.", 0xe67e22)
        return
    
    key = item_name.strip().lower()
    # Try by exact key first
    target_key = None
    if key in store:
        target_key = key
    else:
        # Fallback: match by display name if present
        for k, v in store.items():
            disp = (v.get('name') or k).strip().lower()
            if disp == key:
                target_key = k
                break
    
    if not target_key:
        await send_embed(ctx, "Store Admin", f"Item '{item_name}' not found in the store.", 0xe74c3c)
        return
    
    item = store.get(target_key, {})
    rarity = str(item.get('rarity', 'common')).title()
    price = int(item.get('price', 0))
    display = item.get('name', target_key.capitalize())
    
    store.pop(target_key, None)
    save_json(STORE_FILE, store)
    
    embed = discord.Embed(title="🗑️ Store Item Deleted", color=0xe74c3c)
    embed.description = f"**{display}** ({rarity}) has been removed from the store."
    embed.add_field(name="Price", value=f"{MONEY_ICON} {price:,}", inline=True)
    embed.add_field(name="Key", value=f"`{target_key}`", inline=True)
    await ctx.send(embed=embed)


@bot.command(name="set_item_usable")
@commands.has_permissions(administrator=True)
async def set_item_usable(ctx, item_name: str, usable: str):
    """Toggle whether a store item is usable. Usage: ?set_item_usable <item_name> <true|false>"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return

    store = load_json(STORE_FILE)
    if not store:
        await send_embed(ctx, "Store Admin", "Store is empty.", 0xe67e22)
        return

    key = item_name.strip().lower()
    target_key = None
    if key in store:
        target_key = key
    else:
        for k, v in store.items():
            disp = (v.get('name') or k).strip().lower()
            if disp == key:
                target_key = k
                break

    if not target_key:
        await send_embed(ctx, "Store Admin", f"Item '{item_name}' not found in the store.", 0xe74c3c)
        return

    usable_norm = str(usable).strip().lower()
    if usable_norm not in ("true", "false", "yes", "no", "1", "0"): 
        await send_embed(ctx, "Invalid Value", "Usable must be one of: true, false, yes, no, 1, 0.", 0xe74c3c)
        return

    usable_bool = usable_norm in ("true", "yes", "1")

    store[target_key]["usable"] = usable_bool
    save_json(STORE_FILE, store)

    status_txt = "✅ Usable" if usable_bool else "❌ Display Only"
    embed = discord.Embed(title="🛠️ Store Item Updated", color=0x3498db)
    embed.description = f"`{target_key}` usability set to {status_txt}."
    await ctx.send(embed=embed)


@bot.command(name="restock_store")
@commands.has_permissions(administrator=True)
async def restock_store(ctx):
    """Restock all store items to their maximum stock levels. 
    
    This command will:
    • Restock all items to their maximum stock levels
    • Set max_stock values for items that don't have them
    • Use intelligent defaults based on item rarity and type
    • Only restock items that are below their maximum stock
    
    Usage: ?restock_store
    """
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return

    store = load_json(STORE_FILE)
    if not store:
        await send_embed(ctx, "Store Admin", "Store is empty.", 0xe67e22)
        return

    restocked_count = 0
    total_items = len(store)
    
    for item_key, item_data in store.items():
        current_stock = item_data.get("stock", 0)
        
        # Determine max stock based on item type and rarity
        rarity = item_data.get("rarity", "common").lower()
        if "axis" in item_key.lower():
            max_stock = 10  # Axis items are limited
        elif "role" in item_key.lower():
            max_stock = 10  # Role items are limited
        elif "pill" in item_key.lower():
            max_stock = 50  # Pills are consumables
        elif rarity in ["legendary", "mythic", "divine"]:
            max_stock = 25  # High rarity items are limited
        elif rarity in ["epic", "rare"]:
            max_stock = 50  # Medium rarity items
        else:
            max_stock = 100  # Common items have higher stock
        
        # Update the item with max_stock if it doesn't exist
        if "max_stock" not in item_data:
            item_data["max_stock"] = max_stock
        
        if current_stock < max_stock:
            store[item_key]["stock"] = max_stock
            restocked_count += 1

    if restocked_count > 0:
        save_json(STORE_FILE, store)
        
        embed = discord.Embed(title="🔄 Store Restocked", color=0x2ecc71)
        embed.description = f"Successfully restocked **{restocked_count}** out of **{total_items}** items to maximum stock levels."
        embed.add_field(name="Items Restocked", value=f"✅ {restocked_count}", inline=True)
        embed.add_field(name="Total Items", value=f"📦 {total_items}", inline=True)
        embed.add_field(name="Status", value="🟢 All items now at maximum stock", inline=True)
        
        await ctx.send(embed=embed)
    else:
        embed = discord.Embed(title="ℹ️ Store Status", color=0x3498db)
        embed.description = "All store items are already at maximum stock levels. No restocking needed."
        await ctx.send(embed=embed)

@bot.hybrid_command(name="restock_status", description="Check the status of store restocking")
async def restock_status(ctx):
    """Check when the store was last restocked and when it will be restocked next"""
    # Check if this is a slash command or prefix command
    is_slash = ctx.interaction is not None if hasattr(ctx, 'interaction') else False
    
    if is_slash:
        await ctx.defer()
    
    RESTOCK_TRACKING_FILE = os.path.join(DATA_DIR, "restock_tracking.json")
    ensure_file(RESTOCK_TRACKING_FILE, {"last_restock": 0})
    
    tracking_data = load_json(RESTOCK_TRACKING_FILE)
    last_restock = tracking_data.get("last_restock", 0)
    
    if last_restock == 0:
        status_msg = "🔄 **Store has never been restocked**"
        next_restock_msg = "⏰ **Next restock:** Available now!"
    else:
        last_restock_time = datetime.fromtimestamp(last_restock)
        time_since_restock = time.time() - last_restock
        time_until_next = 259200 - time_since_restock  # 3 days = 259200 seconds
        
        if time_until_next <= 0:
            status_msg = f"🔄 **Last restock:** {last_restock_time.strftime('%Y-%m-%d %H:%M:%S')}"
            next_restock_msg = "⏰ **Next restock:** Available now!"
        else:
            days = int(time_until_next // 86400)
            hours = int((time_until_next % 86400) // 3600)
            minutes = int((time_until_next % 3600) // 60)
            
            status_msg = f"🔄 **Last restock:** {last_restock_time.strftime('%Y-%m-%d %H:%M:%S')}"
            next_restock_msg = f"⏰ **Next restock:** In {days}d {hours}h {minutes}m"
    
    embed = discord.Embed(title="🏪 Store Restock Status", color=0x3498db)
    embed.description = "The store automatically restocks every 3 days to maintain item availability."
    embed.add_field(name="Status", value=status_msg, inline=False)
    embed.add_field(name="Schedule", value=next_restock_msg, inline=False)
    embed.add_field(name="Auto-Restock", value="✅ **Enabled** - Every 3 days", inline=False)
    embed.set_footer(text="Use /restock_store to manually restock now")
    
    if is_slash:
        await ctx.followup.send(embed=embed)
    else:
        await ctx.send(embed=embed)


@bot.hybrid_command(name="buy_item", description="Buy an item from the store")
@app_commands.describe(
    item_name="Name of the item to buy",
    quantity="How many of the item to buy (default: 1)"
)
@app_commands.autocomplete(item_name=store_item_autocomplete)
async def buy_item(ctx, item_name: str, quantity: int = 1):
    cash, _ = get_balances(ctx.author.id)
    store = load_json(STORE_FILE)
    key = item_name.lower()
    if key not in store:
        await ctx.send(embed=discord.Embed(title="Item Not Found", color=0xe74c3c))
        return
    item = store[key]
    base_price = int(item.get("price", 0))
    stock = int(item.get("stock", 0))
    
    # Apply quality variation based on rarity
    rarity = item.get("rarity", "common")
    final_rarity, was_upgraded = get_quality_variation(rarity)
    
    # Apply Immortal Art price discount to the base price
    final_price, discount = apply_buy_price_discount(ctx.author.id, base_price)
    
    # Validate quantity
    if quantity <= 0:
        await ctx.send(embed=discord.Embed(title="Invalid Quantity", description="Quantity must be at least 1.", color=0xe74c3c))
        return
    
    # Check if enough stock is available
    if stock < quantity:
        await ctx.send(embed=discord.Embed(title="Not Enough Stock", description=f"Only {stock} available, but you requested {quantity}.", color=0xe74c3c))
        return
    
    # Calculate total cost
    total_cost = final_price * quantity
    
    # Rank requirement
    req_rank_idx = int(item.get("min_rank", 0))
    user_rank_idx = get_rank_index(get_user_meta(ctx.author.id).get("sect_rank", SECT_RANKS[0]))
    if user_rank_idx < req_rank_idx:
        await ctx.send(embed=discord.Embed(title="Requirement Not Met", description=f"Requires rank {SECT_RANKS[req_rank_idx]} or higher.", color=0xe74c3c))
        return
    
    if cash < total_cost:
        await ctx.send(embed=discord.Embed(title="Not Enough Money", description=f"You need {MONEY_ICON} {total_cost:,} but only have {MONEY_ICON} {cash:,}.", color=0xe74c3c))
        return

    set_cash(ctx.author.id, cash - total_cost)
    item["stock"] = stock - quantity
    save_json(STORE_FILE, store)

    # Enhanced role and money management from effects
    effects = item.get("effects", {})
    role_action = effects.get("add_role") or effects.get("remove_role") or effects.get("toggle_role")
    role_id = effects.get("add_role") or effects.get("remove_role") or effects.get("toggle_role")
    money_action = effects.get("add_money") or effects.get("set_money") or effects.get("remove_money")
    money_amount = int(effects.get("add_money", effects.get("set_money", effects.get("remove_money", 0))))
    collect_cooldown_hours = int(item.get("collect_cooldown_hours", 24))
    
    # Handle temporary role effects
    temp_role_data = effects.get("temp_role", {})
    if temp_role_data:
        role_id = temp_role_data.get("role_id")
        duration_hours = temp_role_data.get("duration_days", 1) * 24  # Convert days to hours
        role_action = "add"
    
    # Handle XP and other effects
    xp_boost = effects.get("xp_boost", 0)
    sect_xp_boost = effects.get("sect_xp", 0)
    job_xp_boost = effects.get("job_xp", 0)
    immortal_art_rerolls = effects.get("immortal_art_reroll", 0)

    # Handle role management
    role_msg = ""
    if role_action and role_id and ctx.guild:
        # Note: For roles, quantity doesn't multiply the effect (you can't have the same role multiple times)
        # Only the first item will apply the role effect
        role = ctx.guild.get_role(int(role_id))
        if role:
            try:
                temp_role = item.get("temp_role", False)
                duration_hours = int(item.get("duration_hours", 24))
                
                if role_action == "add":
                    await ctx.author.add_roles(role, reason=f"Purchased {key}")
                    if temp_role:
                        role_msg = f"\n**Temporary Role Added:** {role.mention} for {duration_hours} hours"
                        # Schedule role removal
                        async def remove_role_later(member_id, role_id, guild_id):
                            await asyncio.sleep(duration_hours * 3600)  # Convert hours to seconds
                            try:
                                guild = bot.get_guild(guild_id)
                                if not guild:
                                    return
                                member = guild.get_member(member_id)
                                if not member:
                                    return
                                role = guild.get_role(role_id)
                                if not role:
                                    return
                                await member.remove_roles(role, reason=f"Temporary role duration expired for {key}")
                                # Notify user
                                try:
                                    await safe_channel_send(member, f"Your temporary role **{role.name}** from item **{key}** has expired.")
                                except:
                                    pass  # Can't DM user
                            except Exception as e:
                                print(f"Error removing temporary role: {e}")
                        
                        # Start the task to remove the role later
                        asyncio.create_task(remove_role_later(ctx.author.id, role.id, ctx.guild.id))
                    else:
                        role_msg = f"\n**Role Added:** {role.mention}"
                elif role_action == "remove":
                    await ctx.author.remove_roles(role, reason=f"Purchased {key}")
                    role_msg = f"\n**Role Removed:** {role.mention}"
                elif role_action == "toggle":
                    if role in ctx.author.roles:
                        await ctx.author.remove_roles(role, reason=f"Purchased {key} - toggle")
                        role_msg = f"\n**Role Removed:** {role.mention}"
                    else:
                        await ctx.author.add_roles(role, reason=f"Purchased {key} - toggle")
                        if temp_role:
                            role_msg = f"\n**Temporary Role Added:** {role.mention} for {duration_hours} hours"
                            # Schedule role removal
                            async def remove_role_later(member_id, role_id, guild_id):
                                await asyncio.sleep(duration_hours * 3600)  # Convert hours to seconds
                                try:
                                    guild = bot.get_guild(guild_id)
                                    if not guild:
                                        return
                                    member = guild.get_member(member_id)
                                    if not member:
                                        return
                                    role = guild.get_role(role_id)
                                    if not role:
                                        return
                                    await member.remove_roles(role, reason=f"Temporary role duration expired for {key}")
                                    # Notify user
                                    try:
                                        await safe_channel_send(member, f"Your temporary role **{role.name}** from item **{key}** has expired.")
                                    except:
                                        pass  # Can't DM user
                                except Exception as e:
                                    print(f"Error removing temporary role: {e}")
                            
                            # Start the task to remove the role later
                            asyncio.create_task(remove_role_later(ctx.author.id, role.id, ctx.guild.id))
                        else:
                            role_msg = f"\n**Role Added:** {role.mention}"
            except Exception as e:
                role_msg = f"\n**Role Action Failed:** {role_action.title()} {role.mention} (Error: {str(e)})"
        else:
            role_msg = f"\n**Warning:** Role ID {role_id} not found"

    # Handle money management
    money_msg = ""
    if money_action and money_amount > 0:
        income_map = load_json(INCOME_FILE)
        target_role_id = str(role_id) if role_id else f"user:{ctx.author.id}"
        
        # For money effects, quantity doesn't multiply the effect (it's a one-time setup)
        if money_action == "add":
            # Add to existing amount
            current_amount = income_map.get(target_role_id, 0)
            income_map[target_role_id] = current_amount + money_amount
            money_msg = f"\n**Income Added:** {MONEY_ICON} {money_amount:,} (Total: {MONEY_ICON} {current_amount + money_amount:,})"
        elif money_action == "set":
            # Set to specific amount
            income_map[target_role_id] = money_amount
            money_msg = f"\n**Income Set:** {MONEY_ICON} {money_amount:,} every {collect_cooldown_hours}h"
        elif money_action == "remove":
            # Remove income collection
            if target_role_id in income_map:
                del income_map[target_role_id]
                money_msg = f"\n**Income Removed:** No more collection"
            else:
                money_msg = f"\n**Income Removed:** No income was set"
        
        save_json(INCOME_FILE, income_map)
        
        # Update cooldowns
        cooldowns = load_json(os.path.join(DATA_DIR, "role_cooldowns.json"))
        if money_action != "remove":
            cooldowns[target_role_id] = collect_cooldown_hours
        elif target_role_id in cooldowns:
            del cooldowns[target_role_id]
        save_json(os.path.join(DATA_DIR, "role_cooldowns.json"), cooldowns)

    # Apply XP and other effects (only for non-consumable items or special effects)
    effect_msg = ""
    
    # Only apply XP effects immediately for non-consumable items
    # Consumable items with XP effects should only give XP when used
    if not item.get("consumable", True):
        if xp_boost > 0:
            total_xp = xp_boost * quantity
            add_sect_xp(ctx.author.id, total_xp)
            effect_msg += f"\n**XP Gained:** +{total_xp:,} XP (from {quantity}x items)"
        
        if sect_xp_boost > 0:
            total_sect_xp = sect_xp_boost * quantity
            add_sect_xp(ctx.author.id, total_sect_xp)
            effect_msg += f"\n**Sect XP Gained:** +{total_sect_xp:,} Sect XP (from {quantity}x items)"
        
        if job_xp_boost > 0:
            # Add job XP logic here if you have a job XP system
            total_job_xp = job_xp_boost * quantity
            effect_msg += f"\n**Job XP Gained:** +{total_job_xp:,} Job XP (from {quantity}x items)"
    
    # Apply immortal art reroll effects
    if immortal_art_rerolls > 0:
        user_meta = get_user_meta(ctx.author.id)
        
        # Initialize immortal arts if not exists
        if "immortal_arts" not in user_meta:
            user_meta["immortal_arts"] = {"rerolls": 0, "slots": [], "unlocked_slots": 1}
        
        # Add rerolls (multiplied by quantity)
        total_rerolls = immortal_art_rerolls * quantity
        current_rerolls = user_meta["immortal_arts"].get("rerolls", 0)
        user_meta["immortal_arts"]["rerolls"] = current_rerolls + total_rerolls
        set_user_meta(ctx.author.id, user_meta)
        
        effect_msg += f"\n**🎲 Immortal Art Rerolls Gained:** +{total_rerolls} rerolls (Total: {user_meta['immortal_arts']['rerolls']})"
    


    # Check if this is an instant use item (doesn't go to inventory)
    instant_use = item.get("instant_use", False)
    
    # Initialize buyer_meta for both instant use and regular items
    buyer_meta = get_user_meta(ctx.author.id)
    # Ensure inventory field exists
    if "inventory" not in buyer_meta:
        buyer_meta["inventory"] = []
    
    # Initialize inventory_item variable for both instant use and regular items
    inventory_item = {
        "name": key,
        "type": "store_item",  # Mark as store item
        "rarity": final_rarity,
        "value": base_price,  # Use base_price as the item value
        "description": item.get("description", "No description"),
        "effects": item.get("effects", {}),
        "purchased_price": final_price,
        "stock_remaining": stock - 1
    }
    
    if instant_use:
        # Item is consumed immediately - don't add to inventory
        added_to_inventory = False
        inventory_msg = "\n**🔥 Instant Use:** Item consumed immediately!"
        
        # Apply all effects immediately for instant use items (multiplied by quantity)
        if xp_boost > 0:
            total_xp = xp_boost * quantity
            add_sect_xp(ctx.author.id, total_xp)
            effect_msg += f"\n**XP Gained:** +{total_xp:,} XP (from {quantity}x items)"
        
        if sect_xp_boost > 0:
            total_sect_xp = sect_xp_boost * quantity
            add_sect_xp(ctx.author.id, total_sect_xp)
            effect_msg += f"\n**Sect XP Gained:** +{total_sect_xp:,} Sect XP (from {quantity}x items)"
        
        if job_xp_boost > 0:
            # Add job XP logic here if you have a job XP system
            total_job_xp = job_xp_boost * quantity
            effect_msg += f"\n**Job XP Gained:** +{total_job_xp:,} Job XP (from {quantity}x items)"
    else:
        # Regular item - add to inventory
        added_to_inventory = True
        inv = buyer_meta.get("inventory", [])
    
    # Add special properties for specific item types
    if item.get("spirit_animal"):
        inventory_item["spirit_animal"] = True
        inventory_item["win_chance"] = item.get("win_chance", 50)
    
    if item.get("consumable", False):
        inventory_item["consumable"] = True
    
    # Set usable property from store item
    inventory_item["usable"] = item.get("usable", True)
    
    # Store complete item data in inventory (only for non-instant use items)
    if not instant_use:
        # Add quantity to the item data
        inventory_item["amount"] = quantity
        
        # Add command and limit_uses data from store item
        if "command" in item:
            inventory_item["command"] = item["command"]
        if "limit_uses" in item:
            inventory_item["limit_uses"] = item["limit_uses"]
        
        # Add the item to inventory (the add_item_to_inventory function handles stacking automatically)
        add_item_to_inventory(ctx.author.id, inventory_item)
        
        added_to_inventory = True
        
        # Reload user meta to get the updated inventory
        buyer_meta = get_user_meta(ctx.author.id)

    # Spirit animal auto-activate on buy
    if item.get("spirit_animal") and item.get("activate_on_buy"):
        buyer_meta.setdefault("spirit_animal", {})
        buyer_meta["spirit_animal"] = {
            "name": key,
            "win_chance": int(item.get("win_chance", 50)),
            "active": True,
        }
        # Save spirit animal changes
        set_user_meta(ctx.author.id, buyer_meta)

    color = RARITY_COLOR.get(final_rarity, 0x2ecc71)
    emoji = RARITY_EMOJI.get(final_rarity, "")
    embed = discord.Embed(title=f"Purchase Successful {emoji}", color=color)
    
    # Build description with price breakdown
    if quantity == 1:
        desc = f"You bought **{key}** ({final_rarity.title()}) for {MONEY_ICON} {final_price:,}."
    else:
        desc = f"You bought **{quantity}x {key}** ({final_rarity.title()}) for {MONEY_ICON} {total_cost:,} ({MONEY_ICON} {final_price:,} each)."
    
    # Show quality upgrade info
    if was_upgraded:
        upgrade_emoji = "✨"
        desc += f"\n**Quality Upgrade:** {upgrade_emoji} Upgraded from {rarity.title()} to {final_rarity.title()}!"
    
    if discount > 0:
        total_discount = discount * quantity
        total_base_price = base_price * quantity
        desc += f"\n**Immortal Art discount: -{MONEY_ICON} {total_discount:,} (from {MONEY_ICON} {total_base_price:,})**"
    desc += f"{role_msg}{money_msg}{effect_msg}"
    
    # Confirm item was added to inventory or instant use
    if instant_use:
        desc += f"\n\n**🔥 Instant Use:** Item consumed immediately! Effects applied."
    else:
        if quantity == 1:
            desc += f"\n\n**Inventory:** Item added to your inventory! Use `/inventory` to view."
        else:
            desc += f"\n\n**Inventory:** {quantity}x items added to your inventory! Use `/inventory` to view."
    
    # Add usage instructions based on item properties
    if not item.get("usable", True):
        desc += f"\n\n**Note:** This is a display/collection item and cannot be used."
    elif item.get("consumable", False):
        desc += f"\n\n**Usage:** Use `/use_item {key}` to consume this item and get its effects!"
    else:
        desc += f"\n\n**Usage:** Use `/use_item {key}` to activate this item's effects!"
    
    # Append spirit animal info
    if item.get("spirit_animal"):
        desc += "\n\n**Spirit Animal:** This item can be used in Spirit Fights."
        if item.get("activate_on_buy"):
            desc += "\nActivated now."
        else:
            desc += "\nUse `/spirit_set` to activate one spirit animal."
    
    embed.description = desc
    try:
        await ctx.send(embed=embed)
    except Exception as e:
        print(f"Error sending purchase embed for user {ctx.author.id}: {e}")
        # Try to send a simple message instead
        try:
            await send_embed(ctx, "Purchase Complete", f"Item {key} purchased successfully!", 0x2ecc71)
        except:
            print(f"Could not send fallback message for user {ctx.author.id}")


@bot.hybrid_command(name="sell", description="Sell any item to the merchant for a fair price")
@app_commands.describe(
    item_name="Item name or 'all' to sell all items of a specific rarity",
    amount="Amount of items to sell (default: 1, or 'all' for entire stack)"
)
@app_commands.autocomplete(item_name=inventory_item_autocomplete)
async def sell(ctx, item_name: str, amount: str = "1"):
    """Sell any item to the merchant for a fair price with Immortal Art bonuses"""
    await ctx.defer()
    print(f"DEBUG: sell called with item_name: {item_name}, amount: {amount}")
    key = item_name.lower()
    print(f"DEBUG: Looking for item with key: {key}")
    
    # Parse amount parameter
    sell_amount = 1
    sell_all_from_stack = False
    
    if amount.lower() == "all":
        sell_all_from_stack = True
        print(f"DEBUG: User wants to sell entire stack")
    else:
        try:
            sell_amount = int(amount)
            if sell_amount <= 0:
                return await send_embed(ctx, "Merchant Error", "Amount must be a positive number or 'all'.", 0xe74c3c)
            print(f"DEBUG: User wants to sell {sell_amount} items")
        except ValueError:
            return await send_embed(ctx, "Merchant Error", "Amount must be a number or 'all'.", 0xe74c3c)
    
    # Clean up user's inventory first to ensure consistent format
    user_id = ctx.author.id
    print(f"DEBUG: User ID: {user_id}")
    clean_user_inventory(user_id)
    
    # Get cleaned inventory
    meta = get_user_meta(user_id)
    if not isinstance(meta, dict):
        print(f"DEBUG: Invalid meta data for user {user_id}: {meta}")
        return await send_embed(ctx, "Merchant Error", "Failed to load user data. Please try again.", 0xe74c3c)
    
    inv = meta.get("inventory", [])
    if not isinstance(inv, list):
        print(f"DEBUG: Invalid inventory data for user {user_id}: {inv}")
        inv = []
        meta["inventory"] = inv
    
    print(f"DEBUG: Inventory length: {len(inv)}")
    print(f"DEBUG: Inventory items: {inv[:3] if inv else 'empty'}...")  # Show first 3 items
    
    # Check if user wants to sell all items of a specific rarity
    if key.startswith("all "):
        rarity = key[4:].strip()  # Remove "all " prefix
        if rarity in ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine", "primordial"]:
            await sell_all_of_rarity(ctx, user_id, meta, inv, rarity)
            return
        else:
            return await send_embed(ctx, "Merchant", "Invalid rarity. Use: common, uncommon, rare, epic, legendary, mythic, divine, primordial", 0xe74c3c)
    
    # Check if user wants to sell ALL items regardless of rarity
    if key.lower() == "all":
        await sell_all_items(ctx, user_id, meta, inv)
        return
    
    # Find the item in inventory by name and get its index
    found_item = None
    item_index = -1
    for i, item in enumerate(inv):
        if isinstance(item, dict) and item.get("name", "").lower() == key:
            found_item = item
            item_index = i
            print(f"DEBUG: Found item at index {i}: {item}")
            break
    
    if not found_item:
        print(f"DEBUG: Item not found in inventory")
        return await send_embed(ctx, "Merchant", "You don't own that item.", 0xe74c3c)
    
    # Check if user has enough of the item to sell
    item_amount = found_item.get("amount", 1)
    print(f"DEBUG: User has {item_amount} of this item")
    
    if sell_all_from_stack:
        sell_amount = item_amount
        print(f"DEBUG: Selling entire stack of {sell_amount} items")
    elif sell_amount > item_amount:
        return await send_embed(ctx, "Merchant Error", f"You only have {item_amount} of that item, but you're trying to sell {sell_amount}.", 0xe74c3c)
    
    # Calculate item value based on type and rarity
    item_type = found_item.get("type", "loot")
    rarity = found_item.get("rarity", "common")
    print(f"DEBUG: Item type: {item_type}, rarity: {rarity}")
    
    # New pricing system based on rarity and type - USER SPECIFIED TARGETS
    if item_type == "weapon":
        damage = found_item.get("damage", 0)
        print(f"DEBUG: Weapon with damage {damage}, rarity {rarity}")
    elif item_type == "armor":
        health = found_item.get("health", 0)
        print(f"DEBUG: Armor with health {health}, rarity {rarity}")
    elif item_type == "artifact":
        abilities = found_item.get("abilities", [])
        print(f"DEBUG: Artifact with abilities {abilities}, rarity {rarity}")
    elif item_type == "ore":
        print(f"DEBUG: Ore with rarity {rarity}")
    else:
        print(f"DEBUG: Other item with rarity {rarity}")

    # REMOVED: Rarity multiplier system - now using direct sell prices
    # Calculate sell price based on item type and rarity (NEW DIRECT PRICING SYSTEM)
    if item_type == "weapon":
        weapon_sell_prices = {
            "common": 1200,
            "uncommon": 5600,
            "rare": 60000,
            "epic": 240000,
            "legendary": 2000000,
            "mythic": random.randint(20000000, 50000000),  # 20M-50M range
            "divine": 400000000,  # 400M as requested
            "primordial": 1000000000
        }
        sell_price = weapon_sell_prices.get(rarity, 1200)
    elif item_type == "armor":
        armor_sell_prices = {
            "common": 1300,
            "uncommon": 5800,
            "rare": 70000,
            "epic": 320000,
            "legendary": 3000000,
            "mythic": random.randint(30000000, 60000000),  # 30M-60M range
            "divine": 400000000,  # 400M as requested
            "primordial": 1000000000
        }
        sell_price = armor_sell_prices.get(rarity, 1300)
    elif item_type == "artifact":
        artifact_sell_prices = {
            "common": 1500,
            "uncommon": 6000,
            "rare": 80000,
            "epic": 360000,
            "legendary": 4000000,
            "mythic": random.randint(40000000, 70000000),  # 40M-70M range
            "divine": 400000000,  # 400M as requested
            "primordial": 1000000000
        }
        sell_price = artifact_sell_prices.get(rarity, 1500)
    elif item_type == "ore":
        ore_sell_prices = {
            "common": 450,
            "uncommon": 1300,
            "rare": 30000,
            "epic": 120000,
            "legendary": 600000,
            "mythic": 10000000,
            "divine": 100000000,  # 100M as requested
            "primordial": 1000000000
        }
        sell_price = ore_sell_prices.get(rarity, 450)
    else:
        # Loot, consumables, and other items
        loot_sell_prices = {
            "common": 300,
            "uncommon": 1000,
            "rare": 20000,
            "epic": 70000,
            "legendary": 400000,
            "mythic": 4000000,
            "divine": 70000000,  # 70M as requested
            "primordial": 1000000000
        }
        sell_price = loot_sell_prices.get(rarity, 300)
    
    # Apply randomization based on rarity
    if rarity in ["legendary", "mythic", "divine", "primordial"]:
        # 30% range randomization for legendary+
        random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
        sell_price = int(sell_price * random_factor)
    else:
        # 15% range randomization for common-epic
        random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
        sell_price = int(sell_price * random_factor)
    
    print(f"DEBUG: Sell price for {rarity} {item_type}: {sell_price}")
    
    print(f"DEBUG: Sell price for {rarity}: {sell_price}")
    
    # Apply Immortal Art sell price bonus
    final_sell_price, bonus = apply_sell_price_bonus(user_id, sell_price)
    print(f"DEBUG: Final sell price: {final_sell_price}, bonus: {bonus}")
    
    # Multiply by the amount being sold
    if sell_amount > 1:
        final_sell_price = final_sell_price * sell_amount
        bonus = bonus * sell_amount
        print(f"DEBUG: Multiplied by sell amount {sell_amount}, final price: {final_sell_price}")
    
    # NOTE: The user receives final_sell_price (sell_price + bonus), not just sell_price
    
    # Remove item from inventory using index (more reliable than object reference)
    print(f"DEBUG: About to process item at index {item_index}")
    try:
        if item_index >= 0 and item_index < len(inv):
            if sell_amount == item_amount:
                # Selling entire stack, remove the item completely
                print(f"DEBUG: Removing entire stack: {found_item}")
                removed_item = inv.pop(item_index)
                print(f"DEBUG: Removed item: {removed_item}")
                print(f"DEBUG: Inventory length after removal: {len(inv)}")
            else:
                # Selling partial stack, reduce the amount
                print(f"DEBUG: Reducing stack from {item_amount} to {item_amount - sell_amount}")
                found_item["amount"] = item_amount - sell_amount
                print(f"DEBUG: Updated item: {found_item}")
                print(f"DEBUG: Inventory length unchanged: {len(inv)}")
        else:
            print(f"DEBUG: Invalid item index {item_index}, inventory length: {len(inv)}")
            return await send_embed(ctx, "Merchant Error", "Failed to process item from inventory. Please try again.", 0xe74c3c)
        
        meta["inventory"] = inv
        set_user_meta(user_id, meta)
        add_cash(user_id, final_sell_price)
        print(f"DEBUG: Added {final_sell_price} cash to user")
    except Exception as e:
        print(f"ERROR removing item from inventory for user {user_id}: {e}")
        return await send_embed(ctx, "Merchant Error", "Failed to process the sale. Please try again.", 0xe74c3c)
    
    # Build response message
    embed = discord.Embed(title="💰 Merchant Sale", color=0x2ecc71)
    
    item_name = found_item.get("name", key)
    if sell_amount > 1:
        desc = f"Sold **{sell_amount}x {item_name.title()}** for {MONEY_ICON} {final_sell_price:,}!"
    else:
        desc = f"Sold **{item_name.title()}** for {MONEY_ICON} {final_sell_price:,}!"
    
    # Price breakdown - NEW DIRECT PRICING SYSTEM
    breakdown = []
    breakdown.append(f"Item Type: {item_type.title()}")
    breakdown.append(f"Rarity: {rarity.title()}")
    
    # Show base sell price before randomization
    if item_type == "weapon":
        base_sell = {"common": 1200, "uncommon": 5600, "rare": 60000, "epic": 240000, "legendary": 2000000, "mythic": "20M-50M", "divine": "400M", "primordial": "1B"}[rarity]
    elif item_type == "armor":
        base_sell = {"common": 1300, "uncommon": 5800, "rare": 70000, "epic": 320000, "legendary": 3000000, "mythic": "30M-60M", "divine": "400M", "primordial": "1B"}[rarity]
    elif item_type == "artifact":
        base_sell = {"common": 1500, "uncommon": 6000, "rare": 80000, "epic": 360000, "legendary": 4000000, "mythic": "40M-70M", "divine": "400M", "primordial": "1B"}[rarity]
    elif item_type == "ore":
        base_sell = {"common": 450, "uncommon": 1300, "rare": 30000, "epic": 120000, "legendary": 600000, "mythic": "10M", "divine": "100M", "primordial": "1B"}[rarity]
    else:
        base_sell = {"common": 300, "uncommon": 1000, "rare": 20000, "epic": 70000, "legendary": 400000, "mythic": "4M", "divine": "70M", "primordial": "1B"}[rarity]
    
    breakdown.append(f"Base Sell Price: {MONEY_ICON} {base_sell}")
    
    # Show quantity information if applicable
    if sell_amount > 1:
        breakdown.append(f"Quantity Sold: {sell_amount}x")
        breakdown.append(f"Base Price × Quantity: {MONEY_ICON} {base_sell} × {sell_amount} = {MONEY_ICON} {base_sell * sell_amount}")
    
    # Show randomization applied
    if rarity in ["legendary", "mythic", "divine", "primordial"]:
        breakdown.append(f"Randomization: ±15% (30% total range)")
    else:
        breakdown.append(f"Randomization: ±7.5% (15% total range)")
    
    # Show final price calculation
    if sell_amount > 1:
        breakdown.append(f"Price After Randomization: {MONEY_ICON} {sell_price * sell_amount}")
    
    if bonus > 0:
        breakdown.append(f"Immortal Art Bonus: +{MONEY_ICON} {bonus:,}")
        breakdown.append(f"**TOTAL RECEIVED: {MONEY_ICON} {final_sell_price:,}**")
    else:
        breakdown.append(f"**TOTAL RECEIVED: {MONEY_ICON} {final_sell_price:,}**")
    
    embed.description = desc
    embed.add_field(name="💰 Price Breakdown", value="\n".join(breakdown), inline=False)
    embed.add_field(name="📦 Item Sold", value=f"{item_type.title()} - {rarity.title()}", inline=True)
    embed.add_field(name="💎 Rarity", value=rarity.title(), inline=True)
    
    # Show remaining inventory status
    if sell_amount < item_amount:
        remaining = item_amount - sell_amount
        embed.add_field(name="📦 Remaining", value=f"{remaining}x {item_name.title()} left in inventory", inline=True)
    
    embed.set_footer(text="Use /inventory to view your remaining items")
    
    print(f"DEBUG: Sending response embed")
    await ctx.send(embed=embed)


async def sell_all_of_rarity(ctx, user_id: int, meta: dict, inv: list, rarity: str):
    """Sell all items of a specific rarity"""
    # Find all items of the specified rarity
    items_to_sell = []
    total_value = 0
    total_sell_price = 0
    total_bonus = 0
    
    for i, item in enumerate(inv):
        if isinstance(item, dict) and item.get("rarity", "").lower() == rarity.lower():
            items_to_sell.append((i, item))
    
    if not items_to_sell:
        return await send_embed(ctx, "Merchant", f"You don't have any {rarity} items to sell.", 0xe74c3c)
    
    # Calculate total value and sell price for all items
    for i, item in items_to_sell:
        # Calculate item value based on type and rarity (same logic as single sell)
        item_type = item.get("type", "loot")
        

        if item_type == "weapon":
            weapon_sell_prices = {
                "common": 1200, "uncommon": 5600, "rare": 60000, "epic": 240000,
                "legendary": 2000000, "mythic": random.randint(20000000, 50000000),
                "divine": 400000000, "primordial": 1000000000
            }
            sell_price = weapon_sell_prices.get(rarity, 1200)
        elif item_type == "armor":
            armor_sell_prices = {
                "common": 1300, "uncommon": 5800, "rare": 70000, "epic": 320000,
                "legendary": 3000000, "mythic": random.randint(30000000, 60000000),
                "divine": 400000000, "primordial": 1000000000
            }
            sell_price = armor_sell_prices.get(rarity, 1300)
        elif item_type == "artifact":
            artifact_sell_prices = {
                "common": 1500, "uncommon": 6000, "rare": 80000, "epic": 360000,
                "legendary": 4000000, "mythic": random.randint(40000000, 70000000),
                "divine": 400000000, "primordial": 1000000000
            }
            sell_price = artifact_sell_prices.get(rarity, 1500)
        elif item_type == "ore":
            ore_sell_prices = {
                "common": 450, "uncommon": 1300, "rare": 30000, "epic": 120000,
                "legendary": 600000, "mythic": 10000000, "divine": 100000000, "primordial": 1000000000
            }
            sell_price = ore_sell_prices.get(rarity, 450)
        else:
            loot_sell_prices = {
                "common": 300, "uncommon": 1000, "rare": 20000, "epic": 70000,
                "legendary": 400000, "mythic": 4000000, "divine": 70000000, "primordial": 1000000000
            }
            sell_price = loot_sell_prices.get(rarity, 300)
        
        # Apply randomization based on rarity
        if rarity in ["legendary", "mythic", "divine", "primordial"]:
            random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
            sell_price = int(sell_price * random_factor)
        else:
            random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
            sell_price = int(sell_price * random_factor)
        
        # Check if item has quantity/amount and handle accordingly
        item_amount = item.get("amount", 1)
        
        # Set final_base_price to sell_price for compatibility
        final_base_price = sell_price
        
        # Apply Immortal Art sell price bonus
        final_sell_price, bonus = apply_sell_price_bonus(user_id, sell_price)
        
        # Multiply by quantity if item has amount > 1
        if item_amount > 1:
            final_sell_price = final_sell_price * item_amount
            bonus = bonus * item_amount
            final_base_price = final_base_price * item_amount
        
        total_value += final_base_price
        total_sell_price += final_sell_price
        total_bonus += bonus
    
    # Remove all items from inventory (in reverse order to avoid index issues)
    # Sort indices in descending order to remove from end to beginning
    indices_to_remove = sorted([i for i, item in items_to_sell], reverse=True)
    for i in indices_to_remove:
        inv.pop(i)
    
    # Update inventory and add money
    meta["inventory"] = inv
    set_user_meta(user_id, meta)
    add_cash(user_id, total_sell_price)  # total_sell_price already includes the bonus
    
    # Create response embed
    embed = discord.Embed(title="💰 Bulk Sale Complete", color=0x2ecc71)
    embed.description = f"Sold **{len(items_to_sell)} {rarity.title()} items** for {MONEY_ICON} {total_sell_price:,}!"
    
    # Price breakdown
    breakdown = []
    breakdown.append(f"Items Sold: {len(items_to_sell)} (including stacked items)")
    breakdown.append(f"Total Base Value: {MONEY_ICON} {total_value:,}")
    if rarity in ["uncommon", "epic", "legendary", "mythic", "divine", "primordial"]:
        breakdown.append(f"Total Sell Price (100%): {MONEY_ICON} {total_sell_price:,}")
    else:
        breakdown.append(f"Total Sell Price (50%): {MONEY_ICON} {total_sell_price:,}")
    
    if total_bonus > 0:
        breakdown.append(f"Immortal Art Bonus: +{MONEY_ICON} {total_bonus:,}")
        breakdown.append(f"**TOTAL RECEIVED: {MONEY_ICON} {total_sell_price:,}**")
    else:
        breakdown.append(f"**TOTAL RECEIVED: {MONEY_ICON} {total_sell_price:,}**")
    
    embed.add_field(name="💰 Sale Summary", value="\n".join(breakdown), inline=False)
    embed.add_field(name="📦 Items Sold", value=f"{len(items_to_sell)} {rarity.title()} items", inline=True)
    embed.add_field(name="💎 Rarity", value=rarity.title(), inline=True)
    embed.set_footer(text=f"Use /inventory to view your remaining items")
    
    await ctx.send(embed=embed)


async def sell_all_items(ctx, user_id: int, meta: dict, inv: list):
    """Sell ALL items in inventory regardless of rarity"""
    try:
        if not inv:
            return await send_embed(ctx, "Merchant", "You don't have any items to sell.", 0xe74c3c)
        
        # Calculate total value and sell price for all items
        total_value = 0
        total_sell_price = 0
        total_bonus = 0
        items_sold = 0
        
        for i, item in enumerate(inv):
            try:
                if isinstance(item, dict) and "name" in item:
                    # Calculate item value (same logic as single sell)
                    item_type = item.get("type", "loot")
                    rarity = item.get("rarity", "common")
                    
                    # NEW DIRECT PRICING SYSTEM (same as single sell)
                    if item_type == "weapon":
                        weapon_sell_prices = {
                            "common": 1200, "uncommon": 5600, "rare": 60000, "epic": 240000,
                            "legendary": 2000000, "mythic": random.randint(20000000, 50000000),
                            "divine": 400000000, "primordial": 1000000000
                        }
                        sell_price = weapon_sell_prices.get(rarity, 1200)
                    elif item_type == "armor":
                        armor_sell_prices = {
                            "common": 1300, "uncommon": 5800, "rare": 70000, "epic": 320000,
                            "legendary": 3000000, "mythic": random.randint(30000000, 60000000),
                            "divine": 400000000, "primordial": 1000000000
                        }
                        sell_price = armor_sell_prices.get(rarity, 1300)
                    elif item_type == "artifact":
                        artifact_sell_prices = {
                            "common": 1500, "uncommon": 6000, "rare": 80000, "epic": 360000,
                            "legendary": 4000000, "mythic": random.randint(40000000, 70000000),
                            "divine": 400000000, "primordial": 1000000000
                        }
                        sell_price = artifact_sell_prices.get(rarity, 1500)
                    elif item_type == "ore":
                        ore_sell_prices = {
                            "common": 450, "uncommon": 1300, "rare": 30000, "epic": 120000,
                            "legendary": 600000, "mythic": 10000000, "divine": 100000000, "primordial": 1000000000
                        }
                        sell_price = ore_sell_prices.get(rarity, 450)
                    else:
                        loot_sell_prices = {
                            "common": 300, "uncommon": 1000, "rare": 20000, "epic": 70000,
                            "legendary": 400000, "mythic": 4000000, "divine": 70000000, "primordial": 1000000000
                        }
                        sell_price = loot_sell_prices.get(rarity, 300)
                    
                    # Apply randomization based on rarity
                    if rarity in ["legendary", "mythic", "divine", "primordial"]:
                        random_factor = 0.85 + (random.random() * 0.3)  # ±15% = 30% total range
                        sell_price = int(sell_price * random_factor)
                    else:
                        random_factor = 0.925 + (random.random() * 0.15)  # ±7.5% = 15% total range
                        sell_price = int(sell_price * random_factor)
                    
                    # Check if item has quantity/amount and handle accordingly
                    item_amount = item.get("amount", 1)
                    
                    # Set final_base_price to sell_price for compatibility
                    final_base_price = sell_price
                    
                    # Apply Immortal Art sell price bonus
                    final_sell_price, bonus = apply_sell_price_bonus(user_id, sell_price)
                    
                    # Multiply by quantity if item has amount > 1
                    if item_amount > 1:
                        final_sell_price = final_sell_price * item_amount
                        bonus = bonus * item_amount
                        final_base_price = final_base_price * item_amount
                    
                    total_value += final_base_price
                    total_sell_price += final_sell_price
                    total_bonus += bonus
                    items_sold += item_amount  # Count actual items, not just stack entries
            except Exception as e:
                print(f"Error processing item {i} in sell_all_items: {e}")
                continue
        
        if items_sold == 0:
            return await send_embed(ctx, "Merchant", "No valid items found to sell.", 0xe74c3c)
        
        # Clear entire inventory
        meta["inventory"] = []
        set_user_meta(user_id, meta)
        add_cash(user_id, total_sell_price)  # total_sell_price already includes the bonus
        
        # Create response embed
        embed = discord.Embed(title="💰 MASS SALE COMPLETE!", color=0x00ff00)
        embed.description = f"Sold **ALL {items_sold} items** from your inventory for {MONEY_ICON} {total_sell_price:,}!"
        
        # Sale summary
        breakdown = []
        breakdown.append(f"Items Sold: {items_sold} (including stacked items)")
        breakdown.append(f"Total Base Value: {MONEY_ICON} {total_value:,}")
        breakdown.append(f"Total Sell Price: {MONEY_ICON} {total_sell_price:,}")
        
        if total_bonus > 0:
            breakdown.append(f"Immortal Art Bonus: +{MONEY_ICON} {total_bonus:,}")
            breakdown.append(f"**TOTAL RECEIVED: {MONEY_ICON} {total_sell_price:,}**")
        else:
            breakdown.append(f"**TOTAL RECEIVED: {MONEY_ICON} {total_sell_price:,}**")
        
        embed.add_field(name="💰 Sale Summary", value="\n".join(breakdown), inline=False)
        embed.add_field(name="📦 Inventory Status", value="**EMPTIED** - All items sold!", inline=True)
        embed.add_field(name="💎 Rarity Breakdown", value="Mixed rarities sold at appropriate rates", inline=True)
        embed.set_footer(text="Use /inventory to confirm your inventory is empty")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Error in sell_all_items: {e}")
        await send_embed(ctx, "Merchant Error", f"An error occurred while selling all items: {str(e)}", 0xe74c3c)


# Removed debug_sect_ranks command - no longer needed


# Prefix command version for add_store_item
@bot.command(name="addstore")
@commands.has_permissions(administrator=True)
async def add_store_item_prefix(ctx, key: str, price: int, description: str = "No description", 
                               min_rank: str = None, rarity: str = "common", stock: int = 999, 
                               usable: str = "true", instant_use: str = "false", 
                               effect_type: str = "none", effect_value: str = None, 
                               duration_days: int = 7):
    """Prefix command version of add_store_item"""
    # Convert to hybrid command context
    hybrid_ctx = type('Context', (), {
        'author': ctx.author,
        'guild': ctx.guild,
        'send': ctx.send,
        'interaction': None
    })()
    
    # Call the hybrid command function directly
    await add_store_item_hybrid(hybrid_ctx, key, price, description, min_rank, rarity, 
                        stock, usable, instant_use, effect_type, effect_value, duration_days)


# -----------------------
# Spirit Animal management and fight system
# -----------------------

@bot.hybrid_command(name="spirit", description="Manage your spirit beast - set, train, view stats, and fight!")
@app_commands.describe(
    action="What you want to do with your spirit beast",
    item_name="Name of the spirit beast item (for set action)",
    amount="Bet amount (for fight action)",
    opponent="Opponent to fight (for fight action)"
)
@app_commands.choices(action=[
    app_commands.Choice(name="set", value="set"),
    app_commands.Choice(name="train", value="train"),
    app_commands.Choice(name="stats", value="stats"),
    app_commands.Choice(name="fight", value="fight")
])
@app_commands.autocomplete(item_name=inventory_item_autocomplete)
async def spirit_command(ctx, action: str, item_name: str = None, amount: str = None, opponent: discord.Member = None):
    """Master spirit beast command - handles everything!"""
    
    if action == "set":
        if not item_name:
            return await send_embed(ctx, "Spirit Beast", "Please provide an item name to set as your spirit beast.", 0xe74c3c)
        
        store = load_json(STORE_FILE)
        item_key = item_name.lower()
        item = store.get(item_key)
        
        # Check if it's a spirit beast from store
        is_store_spirit = item and item.get("spirit_animal")
        
        # If not in store, check user's inventory for custom spirit beasts
        if not is_store_spirit:
            meta = get_user_meta(ctx.author.id)
            inv = meta.get("inventory", [])
            
            # Look for spirit beast in inventory
            inventory_spirit = None
            for inv_item in inv:
                if isinstance(inv_item, dict) and inv_item.get("name", "").lower() == item_key and inv_item.get("type") == "spirit_beast":
                    inventory_spirit = inv_item
                    break
            
            if not inventory_spirit:
                return await send_embed(ctx, "Spirit Beast", "That item is not a spirit beast.", 0xe74c3c)
            
            # Use inventory spirit beast data
            item = inventory_spirit
        elif not item.get("spirit_animal"):
            return await send_embed(ctx, "Spirit Beast", "That item is not a spirit beast.", 0xe74c3c)

        # Check inventory
        meta = get_user_meta(ctx.author.id)
        inv = meta.get("inventory", [])
        
        # Check if user owns the spirit beast
        owns_spirit = False
        for inv_item in inv:
            if isinstance(inv_item, dict) and inv_item.get("name", "").lower() == item_key:
                owns_spirit = True
                break
            elif isinstance(inv_item, str) and inv_item.lower() == item_key:
                owns_spirit = True
                break
        
        if not owns_spirit:
            return await send_embed(ctx, "Spirit Beast", "You don't own that spirit beast.", 0xe74c3c)

        meta.setdefault("spirit_animal", {})
        meta["spirit_animal"] = {
            "name": item_key,
            "win_chance": int(item.get("win_chance", 50)),
            "active": True,
            "level": 1,
            "experience": 0,
            "critical_chance": 5,
            "dodge_chance": 3,
            "special_attack_chance": 15,
            "abilities": []
        }
        set_user_meta(ctx.author.id, meta)

        await send_embed(ctx, "Spirit Beast", f"Set active spirit beast to {item_key.title()} (Win Chance {int(item.get('win_chance', 50))}%)!", 0x2ecc71)
    
    elif action == "train":
        user_id = ctx.author.id
        meta = get_user_meta(user_id)
        
        if "spirit_animal" not in meta or not meta["spirit_animal"].get("active"):
            return await send_embed(ctx, "Spirit Training", "You need an active spirit beast to train. Use `/spirit set [item_name]` first.", 0xe74c3c)
        
        spirit = meta["spirit_animal"]
        current_level = spirit.get("level", 1)
        current_exp = spirit.get("experience", 0)
        max_exp = current_level * 100
        
        # Training costs increase with level
        training_cost = current_level * 10000  # 10k per level
        
        # Check if user has enough money
        cash, _ = get_balances(user_id)
        if cash < training_cost:
            return await send_embed(ctx, "Insufficient Funds", 
                                  f"Training costs {MONEY_ICON} {training_cost:,}. You have {MONEY_ICON} {cash:,}.", 0xe74c3c)
        
        # Training results
        exp_gain = random.randint(20, 40)  # Random exp gain
        new_exp = current_exp + exp_gain
        
        # Check for level up
        level_up = False
        new_level = current_level
        if new_exp >= max_exp:
            new_level = current_level + 1
            new_exp = new_exp - max_exp  # Carry over excess exp
            level_up = True
        
        # Stat improvements
        critical_boost = random.randint(1, 3) if random.random() < 0.4 else 0
        dodge_boost = random.randint(1, 2) if random.random() < 0.3 else 0
        special_boost = random.randint(1, 2) if random.random() < 0.25 else 0
        
        # Update spirit beast stats
        spirit["experience"] = new_exp
        spirit["level"] = new_level
        spirit["critical_chance"] = spirit.get("critical_chance", 5) + critical_boost
        spirit["dodge_chance"] = spirit.get("dodge_chance", 3) + dodge_boost
        spirit["special_attack_chance"] = spirit.get("special_attack_chance", 15) + special_boost
        
        # Deduct training cost
        set_cash(user_id, cash - training_cost)
        
        # Create training results embed
        embed = discord.Embed(title="🏋️ Spirit Beast Training Complete!", color=0x2ecc71)
        embed.description = f"**{spirit['name'].title()}** has completed its training session!"
        
        embed.add_field(name="💰 Training Cost", value=f"{MONEY_ICON} {training_cost:,}", inline=True)
        embed.add_field(name="📈 Experience Gained", value=f"+{exp_gain} XP", inline=True)
        
        if level_up:
            embed.add_field(name="🎉 LEVEL UP!", value=f"**{spirit['name'].title()}** reached Level {new_level}!", inline=False)
            embed.color = 0xffd700  # Gold color for level up
        
        # Show stat improvements
        stat_improvements = []
        if critical_boost > 0:
            stat_improvements.append(f"**Critical Chance:** +{critical_boost}%")
        if dodge_boost > 0:
            stat_improvements.append(f"**Dodge Chance:** +{dodge_boost}%")
        if special_boost > 0:
            stat_improvements.append(f"**Special Attack:** +{special_boost}%")
        
        if stat_improvements:
            embed.add_field(name="📊 Stat Improvements", value="\n".join(stat_improvements), inline=False)
        
        # Show current stats
        embed.add_field(
            name="📋 Current Stats", 
            value=f"**Level:** {new_level}\n"
                  f"**Experience:** {new_exp}/{new_level * 100}\n"
                  f"**Critical:** {spirit['critical_chance']}%\n"
                  f"**Dodge:** {spirit['dodge_chance']}%\n"
                  f"**Special:** {spirit['special_attack_chance']}%",
            inline=False
        )
        
        embed.set_footer(text=f"Next training session costs {MONEY_ICON} {new_level * 10000:,}")
        await ctx.send(embed=embed)
        
        # Save updated spirit beast data
        set_user_meta(user_id, meta)
    
    elif action == "stats":
        user_id = ctx.author.id
        meta = get_user_meta(user_id)
        
        if "spirit_animal" not in meta or not meta["spirit_animal"].get("active"):
            return await send_embed(ctx, "Spirit Beast Stats", "You don't have an active spirit beast. Use `/spirit set [item_name]` to set one!", 0xe74c3c)
        
        spirit = meta["spirit_animal"]
        current_level = spirit.get("level", 1)
        current_exp = spirit.get("experience", 0)
        max_exp = current_level * 100
        
        embed = discord.Embed(title=f"🐺 {spirit['name'].title()} - Spirit Beast Stats", color=0x9b59b6)
        embed.description = f"**{spirit['name'].title()}** is your loyal companion in battle!"
        
        # Basic stats
        embed.add_field(
            name="📊 Combat Stats",
            value=f"**Win Chance:** {spirit.get('win_chance', 50)}%\n"
                  f"**Critical Chance:** {spirit.get('critical_chance', 5)}%\n"
                  f"**Dodge Chance:** {spirit.get('dodge_chance', 3)}%\n"
                  f"**Special Attack:** {spirit.get('special_attack_chance', 15)}%",
            inline=True
        )
        
        # Level and experience
        embed.add_field(
            name="📈 Progression",
            value=f"**Level:** {current_level}\n"
                  f"**Experience:** {current_exp}/{max_exp}\n"
                  f"**Progress:** {int((current_exp/max_exp)*100)}%\n"
                  f"**Next Training Cost:** {MONEY_ICON} {current_level * 10000:,}",
            inline=True
        )
        
        # Abilities and special features
        abilities = spirit.get("abilities", [])
        if abilities:
            embed.add_field(name="✨ Special Abilities", value="\n".join([f"• {ability}" for ability in abilities]), inline=False)
        else:
            embed.add_field(name="✨ Special Abilities", value="No special abilities yet. Train your beast to unlock them!", inline=False)
        
        embed.set_footer(text="Use `/spirit train` to improve your beast's stats!")
        await ctx.send(embed=embed)
    
    elif action == "fight":
        if not amount:
            return await send_embed(ctx, "Spirit Fight", "Please provide a bet amount for the fight.", 0xe74c3c)
        
        # Start the enhanced spirit fight
        await _enhanced_spirit_fight(ctx, amount, opponent)
    
    else:
        await send_embed(ctx, "Spirit Beast", "Invalid action! Use: `set`, `train`, `stats`, or `fight`.", 0xe74c3c)

@bot.hybrid_command(name="spirit_help", description="Get help with the enhanced spirit beast system")
async def spirit_help(ctx):
    """Show help for the enhanced spirit beast system"""
    embed = discord.Embed(title="🐺 Enhanced Spirit Beast System Help", color=0x9b59b6)
    embed.description = "**Master your spirit beast with the new consolidated `/spirit` command!**"
    
    embed.add_field(
        name="📋 Available Actions",
        value="**`/spirit set [item_name]`** - Set your active spirit beast\n"
              "**`/spirit train`** - Train your beast to increase stats\n"
              "**`/spirit stats`** - View your beast's current stats\n"
              "**`/spirit fight [amount] [opponent]`** - Battle other players or bots",
        inline=False
    )
    
    embed.add_field(
        name="⚔️ Enhanced Combat Features",
        value="• **Special Abilities:** Lightning Strike, Shadow Claw, Spirit Blast, Elemental Burst, Mystic Fang\n"
              "• **Critical Hits:** Chance for devastating damage (1.8x multiplier)\n"
              "• **Dodge Mechanics:** Evade incoming attacks\n"
              "• **Level Bonuses:** Higher level beasts deal more damage\n"
              "• **Dynamic Battle Logs:** See exactly what happened each round",
        inline=False
    )
    
    embed.add_field(
        name="🏋️ Training System",
        value="• **Experience Gain:** 20-40 XP per training session\n"
              "• **Level Progression:** Level up every 100 XP\n"
              "• **Stat Improvements:** Random boosts to Critical, Dodge, and Special Attack chances\n"
              "• **Cost Scaling:** Training costs increase with level (10k × level)",
        inline=False
    )
    
    embed.add_field(
        name="💰 Fighting & Rewards",
        value="• **Minimum Bet:** 50 Spirit Stones\n"
              "• **Bot Battles:** 2x payout on victory\n"
              "• **PvP Battles:** 1x payout (both players stake equal amounts)\n"
              "• **Draws:** Full refund for both players",
        inline=False
    )
    
    embed.add_field(
        name="🎯 Getting Started",
        value="1. **Buy a spirit beast** from the store\n"
              "2. **Set it as active** with `/spirit set [item_name]`\n"
              "3. **Train it** with `/spirit train` to improve stats\n"
              "4. **Fight others** with `/spirit fight [amount] [opponent]`\n"
              "5. **Check progress** with `/spirit stats`",
        inline=False
    )
    
    embed.set_footer(text="The spirit beast system has been completely overhauled for maximum excitement!")
    await ctx.send(embed=embed)









async def _enhanced_spirit_fight(ctx, amount: str, opponent: Optional[discord.Member] = None):
    """Enhanced spirit fight function called by the main spirit command"""
    await ctx.defer()

    # Load fighter A (invoker)
    profA = _get_spirit_profile(ctx.author.id)
    if not profA.get("name") or not profA.get("active"):
        return await send_embed(ctx, "Spirit Fight", "You must have an active spirit beast. Buy one from the store and use `/spirit set [item_name]`.", 0xe74c3c)

    payer_cash, _ = get_balances(ctx.author.id)
    bet_amt = parse_amount_arg(amount, payer_cash)
    if bet_amt is None or bet_amt <= 0:
        return await send_embed(ctx, "Spirit Fight", "Provide a valid bet amount (number, `all`, `half`, `1k`, `1m`, `1b`, etc.).", 0xe74c3c)
    if bet_amt < 50:
        return await send_embed(ctx, "Spirit Fight", "Minimum bet is 50 Spirit Stones.", 0xe67e22)
    if bet_amt > payer_cash:
        return await send_embed(ctx, "Spirit Fight", "You don't have enough Spirit Stones for that bet.", 0xe74c3c)

    # Helper: run the actual fight after funds are secured
    async def run_fight(is_vs_bot: bool, opponent_member: Optional[discord.Member]):
        # Refresh profiles
        profA2 = _get_spirit_profile(ctx.author.id)
        if not profA2.get("name") or not profA2.get("active"):
            return await send_embed(ctx, "Spirit Fight", "Your spirit beast is no longer active.", 0xe74c3c)

        nameA = profA2.get("name")
        hpA = 100

        if is_vs_bot:
            nameB = "Bot Spirit"
            hpB = 100
            metaB = {"name": nameB, "win_chance": 50, "active": True}
            def _tmp_get_spirit_profile(_):
                return metaB
            getB = _tmp_get_spirit_profile
            target_display = "Bot"
        else:
            profB2 = _get_spirit_profile(opponent_member.id)
            if not profB2.get("name") or not profB2.get("active"):
                return await send_embed(ctx, "Spirit Fight", f"{opponent_member.mention} has no active spirit beast.", 0xe67e22)
            nameB = profB2.get("name")
            hpB = 100
            getB = lambda _: profB2
            target_display = opponent_member.display_name

        # Enhanced opening embed
        embed = discord.Embed(title="⚔️ Spirit Fight Begins!", color=0x9b59b6)
        embed.description = ("**Enhanced Spirit Beast Combat System!**\n\n"
                           "• **Special Abilities:** Lightning Strike, Shadow Claw, Spirit Blast, and more!\n"
                           "• **Critical Hits:** Chance for devastating damage\n"
                           "• **Dodge Mechanics:** Evade incoming attacks\n"
                           "• **Level Bonuses:** Higher level beasts deal more damage\n\n"
                           f"**Bet:** {MONEY_ICON} {bet_amt:,} • **Payout:** {'2x' if is_vs_bot else '1x'} on win, refund on draw")
        
        # Show spirit beast stats
        profA_stats = _get_spirit_profile(ctx.author.id)
        embed.add_field(
            name=f"{ctx.author.display_name} — {nameA.title() if nameA else 'No Spirit'}", 
            value=_spirit_health_bar(hpA, 100, profA_stats.get("level", 1), nameA) + 
                  f"\n**Level:** {profA_stats.get('level', 1)} | **Critical:** {profA_stats.get('critical_chance', 5)}% | **Dodge:** {profA_stats.get('dodge_chance', 3)}%", 
            inline=False
        )
        
        if is_vs_bot:
            embed.add_field(
                name=f"{target_display} — {nameB.title() if nameB else 'No Spirit'}", 
                value=_spirit_health_bar(hpB, 100, 1, nameB) + 
                      f"\n**Level:** 1 | **Critical:** 5% | **Dodge:** 3%", 
                inline=False
            )
        else:
            profB_stats = _get_spirit_profile(opponent_member.id)
            embed.add_field(
                name=f"{target_display} — {nameB.title() if nameB else 'No Spirit'}", 
                value=_spirit_health_bar(hpB, 100, profB_stats.get("level", 1), nameB) + 
                      f"\n**Level:** {profB_stats.get('level', 1)} | **Critical:** {profB_stats.get('critical_chance', 5)}% | **Dodge:** {profB_stats.get('dodge_chance', 3)}%", 
                inline=False
            )
        
        msg = await ctx.send(embed=embed)

        # Enhanced fight loop — update every 5 seconds
        round_idx = 0
        while hpA > 0 and hpB > 0 and round_idx < 30:
            await asyncio.sleep(5)
            
            # Pull latest profiles
            profA3 = _get_spirit_profile(ctx.author.id)
            if is_vs_bot:
                profB3 = getB(None)
            else:
                profB3 = _get_spirit_profile(opponent_member.id)

            # Apply gambling role bonus for blackjack
            role_bonus_a = await _get_gamble_bonus("blackjack", ctx.author)
            chanceA = max(0, min(100, int(profA3.get("win_chance", 0)) + role_bonus_a))
            if not is_vs_bot:
                role_bonus_b = await _get_gamble_bonus("blackjack", opponent_member)
            else:
                role_bonus_b = 0
            chanceB = max(0, min(100, int(profB3.get("win_chance", 50)) + role_bonus_b))
            
            # Use enhanced combat system
            dmgA, dmgA_type, dmgA_desc = _calculate_spirit_damage(profA3, chanceA, "A")
            dmgB, dmgB_type, dmgB_desc = _calculate_spirit_damage(profB3, chanceB, "B")
            
            # Apply damage with dodge mechanics
            hpB, dmgA_actual = _apply_spirit_damage(hpB, dmgA, profA3.get("dodge_chance", 3))
            hpA, dmgB_actual = _apply_spirit_damage(hpA, dmgB, profB3.get("dodge_chance", 3))

            # Create enhanced battle embed
            upd = discord.Embed(title="⚔️ Spirit Fight - Round " + str(round_idx + 1), color=0x9b59b6)
            
            # Player status with enhanced health bars
            upd.add_field(
                name=f"{ctx.author.display_name} — {nameA.title() if nameA else 'No Spirit'}", 
                value=_spirit_health_bar(hpA, 100, profA3.get("level", 1), nameA), 
                inline=False
            )
            upd.add_field(
                name=f"{target_display} — {nameB.title() if nameB else 'No Spirit'}", 
                value=_spirit_health_bar(hpB, 100, profB3.get("level", 1), nameB), 
                inline=False
            )
            
            # Battle log for this round
            battle_log = []
            if dmgA_actual > 0:
                battle_log.append(f"**{nameA.title()}** {dmgA_desc} for **{dmgA_actual}** damage!")
            elif dmgA > 0:
                battle_log.append(f"**{nameB.title()}** dodged the attack!")
            
            if dmgB_actual > 0:
                battle_log.append(f"**{nameB.title()}** {dmgB_desc} for **{dmgB_actual}** damage!")
            elif dmgB > 0:
                battle_log.append(f"**{nameA.title()}** dodged the attack!")
            
            if battle_log:
                upd.add_field(name="⚔️ Round " + str(round_idx + 1) + " Battle Log", value="\n".join(battle_log), inline=False)
            
            upd.set_footer(text="Next attack in 5s…")
            await msg.edit(embed=upd)

            round_idx += 1

        # Results and payouts
        if hpA <= 0 and hpB <= 0:
            result = "It's a draw!"
            # Refund both sides
            add_cash(ctx.author.id, bet_amt)
            if not is_vs_bot:
                add_cash(opponent_member.id, bet_amt)
            payout = 0
        elif hpB <= 0:
            result = f"{ctx.author.mention} wins!"
            payout = bet_amt * (2 if is_vs_bot else 2)  # both parties staked 1x each in PvP
            add_cash(ctx.author.id, bet_amt + (bet_amt if is_vs_bot else bet_amt))
        else:
            result = f"{target_display} wins!"
            payout = 0

        fin = discord.Embed(title="🏁 Spirit Fight Result", color=0x2ecc71 if payout > 0 else 0xe74c3c)
        fin.description = result
        fin.add_field(name="Bet (each)", value=f"{MONEY_ICON} {bet_amt:,}", inline=True)
        if payout > 0:
            fin.add_field(name="Payout", value=f"{MONEY_ICON} {bet_amt * (2 if is_vs_bot else 2):,}", inline=True)
        fin.add_field(name=f"{ctx.author.display_name}", value=_spirit_health_bar(hpA, 100, profA_stats.get("level", 1), nameA), inline=True)
        fin.add_field(name=f"{target_display}", value=_spirit_health_bar(hpB, 100, 1 if is_vs_bot else profB_stats.get("level", 1), nameB), inline=True)
        await ctx.send(embed=fin)

    # If fighting the bot, deduct initiator and run immediately
    if opponent is None or opponent.bot:
        set_cash(ctx.author.id, payer_cash - bet_amt)
        await run_fight(True, None)
        return

    # PvP: require opponent acceptance and deduct both
    profB = _get_spirit_profile(opponent.id)
    if not profB.get("name") or not profB.get("active"):
        return await send_embed(ctx, "Spirit Fight", f"{opponent.mention} has no active spirit beast.", 0xe67e22)

    # Show challenge view
    class FightInviteView(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=120)

        @discord.ui.button(label="Accept", style=discord.ButtonStyle.success)
        async def accept(self, interaction: discord.Interaction, button: discord.Button):
            if interaction.user.id != opponent.id:
                return await interaction.response.send_message("This challenge is not for you.", ephemeral=True)
            # Re-validate funds and deduct from both
            a_cash, _ = get_balances(ctx.author.id)
            b_cash, _ = get_balances(opponent.id)
            if a_cash < bet_amt:
                return await interaction.response.send_message("Challenger no longer has enough funds.", ephemeral=True)
            if b_cash < bet_amt:
                return await interaction.response.send_message("You don't have enough funds to accept.", ephemeral=True)
            set_cash(ctx.author.id, a_cash - bet_amt)
            set_cash(opponent.id, b_cash - bet_amt)
            await interaction.response.edit_message(content=f"Challenge accepted by {opponent.mention}!", view=None)
            await run_fight(False, opponent)

        @discord.ui.button(label="Reject", style=discord.ButtonStyle.danger)
        async def reject(self, interaction: discord.Interaction, button: discord.Button):
            if interaction.user.id != opponent.id:
                return await interaction.response.send_message("This challenge is not for you.", ephemeral=True)
            await interaction.response.edit_message(content=f"{opponent.mention} rejected the spirit fight.", view=None)

        async def on_timeout(self):
            try:
                await challenge_msg.edit(content="Spirit fight challenge timed out.", view=None)
            except Exception:
                pass

    view = FightInviteView()
    challenge_msg = await ctx.send(content=f"{opponent.mention}, {ctx.author.mention} challenges you to a Spirit Fight for {MONEY_ICON} {bet_amt:,} each!", view=view)


def _get_spirit_profile(user_id: int) -> dict:
    meta = get_user_meta(user_id)
    spirit = meta.get("spirit_animal") or {}
    name = spirit.get("name") or None
    win_chance = int(spirit.get("win_chance", 0))
    active = bool(spirit.get("active", False))
    
    # Enhanced spirit beast stats
    level = spirit.get("level", 1)
    experience = spirit.get("experience", 0)
    max_experience = level * 100
    
    # Spirit beast abilities and stats
    abilities = spirit.get("abilities", [])
    critical_chance = spirit.get("critical_chance", 5)
    dodge_chance = spirit.get("dodge_chance", 3)
    special_attack_chance = spirit.get("special_attack_chance", 15)
    
    return {
        "name": name, 
        "win_chance": win_chance, 
        "active": active,
        "level": level,
        "experience": experience,
        "max_experience": max_experience,
        "abilities": abilities,
        "critical_chance": critical_chance,
        "dodge_chance": dodge_chance,
        "special_attack_chance": special_attack_chance
    }


def _spirit_health_bar(cur: int, maxhp: int = 100, level: int = 1, name: str = "") -> str:
    cur = max(0, min(maxhp, cur))
    filled = int((cur / maxhp) * 10)
    empty = 10 - filled
    
    # Enhanced health bar with level and status
    health_bar = "█" * filled + "░" * empty + f" {cur}/{maxhp}"
    
    # Add level indicator
    level_text = f" [Lv.{level}]" if level > 1 else ""
    
    # Add status effects
    status_text = ""
    if cur <= maxhp * 0.2:
        status_text = " 🔥"  # Critical health
    elif cur <= maxhp * 0.5:
        status_text = " ⚠️"  # Low health
    
    return f"{name}{level_text}: {health_bar}{status_text}"


async def _spirit_fight_round(ctx, message: discord.Message, A: discord.Member, B: discord.Member, hpA: int, hpB: int, nameA: str, nameB: str) -> Tuple[int, int]:
    """Enhanced spirit fight round with special abilities and dynamic combat"""
    profA = _get_spirit_profile(A.id)
    profB = _get_spirit_profile(B.id)
    
    # Base attack chances
    chanceA = profA.get("win_chance", 0)
    chanceB = profB.get("win_chance", 0)
    
    # Enhanced combat mechanics
    dmgA, dmgA_type, dmgA_desc = _calculate_spirit_damage(profA, chanceA, "A")
    dmgB, dmgB_type, dmgB_desc = _calculate_spirit_damage(profB, chanceB, "B")
    
    # Apply damage with special effects
    hpB, dmgB_actual = _apply_spirit_damage(hpB, dmgB, profA.get("dodge_chance", 3))
    hpA, dmgA_actual = _apply_spirit_damage(hpA, dmgA, profB.get("dodge_chance", 3))
    
    # Create enhanced battle embed
    embed = discord.Embed(title="⚔️ Spirit Fight - Round Update", color=0x9b59b6)
    
    # Player A status
    embed.add_field(
        name=f"{A.display_name} — {nameA.title() if nameA else 'No Spirit'}", 
        value=_spirit_health_bar(hpA, 100, profA.get("level", 1), nameA), 
        inline=False
    )
    
    # Player B status
    embed.add_field(
        name=f"{B.display_name} — {nameB.title() if nameB else 'No Spirit'}", 
        value=_spirit_health_bar(hpB, 100, profB.get("level", 1), nameB), 
        inline=False
    )
    
    # Battle log
    battle_log = []
    if dmgA_actual > 0:
        battle_log.append(f"**{nameA.title()}** {dmgA_desc} for **{dmgA_actual}** damage!")
    if dmgB_actual > 0:
        battle_log.append(f"**{nameB.title()}** {dmgB_desc} for **{dmgB_actual}** damage!")
    
    if battle_log:
        embed.add_field(name="⚔️ Battle Log", value="\n".join(battle_log), inline=False)
    
    embed.set_footer(text="Next attack in 5s…")
    await message.edit(embed=embed)

    return hpA, hpB

def _calculate_spirit_damage(profile: dict, base_chance: int, player_id: str) -> tuple[int, str, str]:
    """Calculate damage with special abilities and effects"""
    if random.random() * 100 >= base_chance:
        return 0, "miss", "missed"
    
    # Base damage calculation
    base_damage = random.randint(15, 25)
    damage_type = "normal"
    damage_desc = "attacks"
    
    # Check for critical hit
    critical_chance = profile.get("critical_chance", 5)
    if random.random() * 100 < critical_chance:
        base_damage = int(base_damage * 1.8)
        damage_type = "critical"
        damage_desc = "**CRITICAL STRIKES**"
    
    # Check for special attack
    special_chance = profile.get("special_attack_chance", 15)
    if random.random() * 100 < special_chance:
        special_abilities = ["Lightning Strike", "Shadow Claw", "Spirit Blast", "Elemental Burst", "Mystic Fang"]
        ability = random.choice(special_abilities)
        base_damage = int(base_damage * 1.5)
        damage_type = "special"
        damage_desc = f"uses **{ability}**"
    
    # Level bonus
    level = profile.get("level", 1)
    if level > 1:
        level_bonus = (level - 1) * 2
        base_damage += level_bonus
    
    return base_damage, damage_type, damage_desc

def _apply_spirit_damage(current_hp: int, damage: int, dodge_chance: int) -> tuple[int, int]:
    """Apply damage with dodge mechanics"""
    if damage <= 0:
        return current_hp, 0
    
    # Check for dodge
    if random.random() * 100 < dodge_chance:
        return current_hp, 0  # Dodged!
    
    # Apply damage
    new_hp = max(0, current_hp - damage)
    actual_damage = current_hp - new_hp
    
    return new_hp, actual_damage





# Old spirit_fight command remnants removed - functionality consolidated into /spirit command

# Removed crafting_guide command to stay under 100 command limit




# -----------------------
# Use Item Command - FIXED VERSION
# -----------------------

@bot.hybrid_command(name="use_item", description="Use an item from your inventory")
@app_commands.autocomplete(item_name=use_item_autocomplete)
async def use_item(ctx, *, item_name: str):
    """Use an item from your inventory with full store effects support - FIXED VERSION"""
    try:
        # Check if this is a slash command
        is_slash = hasattr(ctx, 'interaction') and ctx.interaction is not None
        
        if is_slash:
            try:
                await ctx.defer()
            except Exception as defer_error:
                print(f"Failed to defer slash command: {defer_error}")
                # If defer fails, treat it as a prefix command
                is_slash = False
        
        # Get user data
        meta = get_user_meta(ctx.author.id)
        if not meta:
            error_msg = "❌ Failed to load user data. Please try again."
            if is_slash and hasattr(ctx, 'followup'):
                await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
            else:
                await send_embed(ctx, "Error", error_msg, color=0xe74c3c)
            return
            
        inv = meta.get("inventory", [])
        
        # Find the item in inventory
        found_item = None
        for item in inv:
            if isinstance(item, dict) and item.get("name") == item_name:
                found_item = item
                break
            elif isinstance(item, str) and item == item_name:
                # Convert legacy string items to dict format
                found_item = {"name": item, "type": "item", "effects": {}, "usable": True}
                break
        
        if not found_item:
            error_msg = f"You don't have **{item_name}** in your inventory."
            if is_slash and hasattr(ctx, 'followup'):
                await ctx.followup.send(embed=discord.Embed(title="❌ Item Not Found", description=error_msg, color=0xe74c3c))
            else:
                await send_embed(ctx, "❌ Item Not Found", error_msg, color=0xe74c3c)
            return
        
        # ALL ITEMS CAN BE USED - only check if explicitly marked as unusable
        effects = found_item.get("effects", {})
        
        # Check if item is explicitly marked as unusable
        if found_item.get("usable") == False:
            error_msg = f"**{item_name}** cannot be used."
            if is_slash and hasattr(ctx, 'followup'):
                await ctx.followup.send(embed=discord.Embed(title="❌ Cannot Use Item", description=error_msg, color=0xe74c3c))
            else:
                await send_embed(ctx, "❌ Cannot Use Item", error_msg, color=0xe74c3c)
            return
        
        # Track applied effects
        effects_applied = []
        money_gain = 0
        xp_gain = 0
        sect_xp_gain = 0
        immortal_art_rerolls = 0
        
        # Process each effect
        for effect_type, effect_value in effects.items():
            try:
                if effect_type in ["money", "add_money"]:
                    money_gain += int(effect_value)
                    effects_applied.append(f"{MONEY_ICON} {effect_value:,} Spirit Stones")
                    
                elif effect_type in ["xp", "xp_boost"]:
                    xp_gain += int(effect_value)
                    effects_applied.append(f"🌟 {effect_value:,} XP")
                    
                elif effect_type == "sect_xp":
                    sect_xp_gain += int(effect_value)
                    effects_applied.append(f"🏛️ {effect_value:,} Sect XP")
                    
                elif effect_type == "immortal_art_reroll":
                    immortal_art_rerolls += int(effect_value)
                    effects_applied.append(f"🎲 {effect_value} Immortal Art Rerolls")
                    
                elif effect_type == "health":
                    effects_applied.append(f"❤️ {effect_value} Health")
                    
                elif effect_type == "add_role":
                    if ctx.guild:
                        role = ctx.guild.get_role(int(effect_value))
                        if role:
                            try:
                                await ctx.author.add_roles(role, reason=f"Used {item_name}")
                                effects_applied.append(f"👑 Role Added: {role.name}")
                            except Exception as e:
                                effects_applied.append(f"❌ Failed to add role: {str(e)}")
                        else:
                            effects_applied.append(f"❌ Role not found: {effect_value}")
                    else:
                        effects_applied.append(f"👑 Role ID: {effect_value}")
                        
                elif effect_type == "temp_role":
                    # Handle temporary role effects
                    if isinstance(effect_value, dict) and "role_id" in effect_value:
                        role_id = effect_value["role_id"]
                        duration_days = effect_value.get("duration_days", 7)
                        
                        if ctx.guild:
                            role = ctx.guild.get_role(int(role_id))
                            if role:
                                try:
                                    await ctx.author.add_roles(role, reason=f"Used {item_name} (temp)")
                                    effects_applied.append(f"👑 Temporary Role Added: {role.name} for {duration_days} days")
                                except Exception as e:
                                    effects_applied.append(f"❌ Failed to add temp role: {str(e)}")
                            else:
                                effects_applied.append(f"❌ Temp role not found: {role_id}")
                        else:
                            effects_applied.append(f"👑 Temp Role ID: {role_id} for {duration_days} days")
                    else:
                        effects_applied.append(f"👑 Temporary Role: {effect_value}")
                        
                elif effect_type == "command":
                    # Handle command effects (like XP pills)
                    try:
                        command_value = int(effect_value)
                        if command_value > 0:
                            # Add XP based on command value
                            xp_gain += command_value
                            effects_applied.append(f"🌟 {command_value:,} XP (from command)")
                    except ValueError:
                        effects_applied.append(f"📜 Command: {effect_value}")
                        
                else:
                    # Handle unknown effects
                    effects_applied.append(f"{effect_type.title()}: {effect_value}")
                    
            except (ValueError, TypeError) as e:
                print(f"Error processing effect {effect_type}: {e}")
                effects_applied.append(f"❌ Invalid effect: {effect_type}")
                continue
        
        # Apply all the gains
        if money_gain > 0:
            add_cash(ctx.author.id, money_gain)
        
        if xp_gain > 0:
            current_xp = meta.get("cultivation_xp", 0)
            meta["cultivation_xp"] = current_xp + xp_gain
        
        if sect_xp_gain > 0:
            add_sect_xp(ctx.author.id, sect_xp_gain)
        
        if immortal_art_rerolls > 0:
            if "immortal_arts" not in meta:
                meta["immortal_arts"] = {"rerolls": 0, "slots": [], "unlocked_slots": 1}
            current_rerolls = meta["immortal_arts"].get("rerolls", 0)
            meta["immortal_arts"]["rerolls"] = current_rerolls + immortal_art_rerolls
        
        # Check if item is consumable (should be removed after use)
        is_consumable = found_item.get("consumable", True)
        
        if is_consumable:
            # Remove item from inventory
            inv.remove(found_item)
            meta["inventory"] = inv
        
        # Save all changes to user meta (XP, immortal arts, inventory)
        set_user_meta(ctx.author.id, meta)
        
        if is_consumable:
            removal_msg = "Item consumed and removed from inventory."
        else:
            removal_msg = "Item used but kept in inventory (non-consumable)."
        
        # Create success embed
        embed = discord.Embed(title="✅ Item Used Successfully", color=0x2ecc71)
        embed.description = f"You used **{found_item['name']}**!"
        
        if effects_applied:
            embed.add_field(name="✨ Effects Applied", value="\n".join(effects_applied), inline=False)
        else:
            embed.add_field(name="📝 Note", value="This item has no effects but was used successfully.", inline=False)
        
        embed.add_field(name="📦 Inventory", value=removal_msg, inline=False)
        
        # Add item info
        item_type = found_item.get("type", "item")
        item_rarity = found_item.get("rarity", "common")
        embed.add_field(name="📋 Item Info", value=f"**Type:** {item_type.title()}\n**Rarity:** {item_rarity.title()}", inline=True)
        
        if is_slash and hasattr(ctx, 'followup'):
            await ctx.followup.send(embed=embed)
        else:
            await ctx.send(embed=embed)
            
    except Exception as e:
        print(f"Error in use_item command: {e}")
        import traceback
        traceback.print_exc()  # Print full error traceback
        
        error_msg = f"❌ An error occurred while using the item: {str(e)}"
        
        try:
            if is_slash and hasattr(ctx, 'followup'):
                await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
            else:
                await send_embed(ctx, "Error", error_msg, color=0xe74c3c)
        except Exception as send_error:
            print(f"Failed to send error message: {send_error}")
            try:
                await ctx.send(error_msg)
            except Exception as final_error:
                print(f"Final fallback failed: {final_error}")


# Removed duplicate pvp_fight command - keeping the better equipment-based one below



from io import BytesIO

AUCTIONS_FILE = os.path.join(DATA_DIR, "auctions.json")
ensure_file(AUCTIONS_FILE, {})
# -----------------------
# PvP Boundary-based Fight
# -----------------------

def _get_boundary_info(member: discord.Member) -> Tuple[str, int, int]:
    """Return (boundary, max_hp, success_pct) based on member attributes and equipment.
    Everyone gets 100 base HP. Attributes: Longevity increases HP, Luck increases success rate.
    Equipment: Armor adds HP, Artifacts add HP, Immortal Arts add HP%.
    """
    # Everyone gets 100 base HP regardless of roles
    base_hp = 100
    base_pct = 50  # Base 50% success rate
    
    # Apply attribute bonuses
    attributes, _ = get_user_attributes(member.id)
    longevity_bonus = attributes.get("longevity", 0) * 1  # +1 HP per longevity point (fixed from +20)
    luck_bonus = attributes.get("luck", 0) * 0.25  # +0.25% success rate per luck point
    
    # Get equipment bonuses
    equipment = get_user_equipment(member.id)
    armor_hp = 0
    artifact_hp = 0
    
    if equipment:
        # Armor HP bonus
        if equipment.get("armor"):
            armor_item = equipment["armor"]
            if isinstance(armor_item, dict) and "hp" in armor_item:
                armor_hp = armor_item["hp"]
        
        # Artifact HP bonus
        if equipment.get("artifact"):
            artifact_item = equipment["artifact"]
            if isinstance(artifact_item, dict) and "hp" in artifact_item:
                artifact_hp = artifact_item["hp"]
    
    # Get Immortal Arts HP percentage bonus
    meta = get_user_meta(member.id)
    immortal_arts_hp_bonus = 0
    if meta and "immortal_arts" in meta and "slots" in meta["immortal_arts"]:
        slots = meta["immortal_arts"]["slots"]
        for slot in slots:
            if slot and "effects" in slot:
                effects = slot["effects"]
                if "health_bonus_pct" in effects:
                    immortal_arts_hp_bonus += effects["health_bonus_pct"]
    
    # Calculate total HP
    total_hp = base_hp + longevity_bonus + armor_hp + artifact_hp
    
    # Apply Immortal Arts percentage bonus
    if immortal_arts_hp_bonus > 0:
        total_hp = int(total_hp * (1 + immortal_arts_hp_bonus / 100))
    
    final_hp = max(100, total_hp)  # Minimum 100 HP
    final_pct = min(95, base_pct + luck_bonus)  # Cap at 95%
    
    return "standard", final_hp, final_pct


def _hp_bar(cur: int, maxhp: int) -> str:
    cur_c = max(0, min(maxhp, cur))
    filled = int((cur_c / maxhp) * 10)
    return "█" * filled + "░" * (10 - filled) + f" {cur_c}/{maxhp}"


class PvPActionView(discord.ui.View):
    def __init__(self, a_id: int, b_id: int):
        super().__init__(timeout=120)
        self.choices: Dict[int, str] = {}
        self.a_id = a_id
        self.b_id = b_id

    async def _choose(self, interaction: discord.Interaction, action: str):
        try:
            if interaction.user.id not in (self.a_id, self.b_id):
                if interaction.response and not interaction.response.is_done():
                    return await interaction.response.send_message("This is not your duel.", ephemeral=True)
                return
            
            self.choices[interaction.user.id] = action
            
            if interaction.response and not interaction.response.is_done():
                await interaction.response.send_message(f"Action selected: {action.title()}", ephemeral=True)
        except Exception as e:
            print(f"Error in PvP action selection: {e}")
            # Try to send a followup message if the response is already done
            try:
                if interaction.response and interaction.response.is_done():
                    await interaction.followup.send(f"Action selected: {action.title()}", ephemeral=True)
            except:
                pass

    @discord.ui.button(label="Attack", style=discord.ButtonStyle.danger)
    async def attack_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self._choose(interaction, "attack")

    @discord.ui.button(label="Counter", style=discord.ButtonStyle.primary)
    async def counter_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self._choose(interaction, "counter")

    @discord.ui.button(label="Pill", style=discord.ButtonStyle.success)
    async def pill_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self._choose(interaction, "pill")

    @discord.ui.button(label="Special", style=discord.ButtonStyle.secondary)
    async def special_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self._choose(interaction, "special")


@bot.hybrid_command(name="pvp_fight", description="Challenge another user to an enhanced equipment-based duel")
async def pvp_fight(ctx, opponent: discord.Member):
    if opponent.bot or opponent.id == ctx.author.id:
        return await send_embed(ctx, "PvP", "Choose a valid opponent.", 0xe74c3c)

    # Ensure both are in guild
    if not ctx.guild:
        return await send_embed(ctx, "PvP", "This command must be used in a server.", 0xe74c3c)

    # Boundary info
    bA, hpA_max, pctA = _get_boundary_info(ctx.author)
    bB, hpB_max, pctB = _get_boundary_info(opponent)
    # If same boundary, both success = 50%
    if bA == bB:
        pctA = pctB = 50

        # Ask for acceptance
    class DuelInvite(discord.ui.View):
        def __init__(self, ctx, opponent, bA, hpA_max, pctA, bB, hpB_max, pctB):
            super().__init__(timeout=120)
            self.ctx = ctx
            self.opponent = opponent
            self.bA = bA
            self.hpA_max = hpA_max
            self.pctA = pctA
            self.bB = bB
            self.hpB_max = hpB_max
            self.pctB = pctB
            
        @discord.ui.button(label="Accept", style=discord.ButtonStyle.success)
        async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
            try:
                if interaction.user.id != self.opponent.id:
                    if interaction.response and not interaction.response.is_done():
                        return await interaction.response.send_message("This invite is not for you.", ephemeral=True)
                    return
                
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.edit_message(content=f"{self.opponent.mention} accepted the duel!", view=None)
                await self.run_duel()
            except Exception as e:
                print(f"Error in duel accept: {e}")
                # Try to send a followup message if the response is already done
                try:
                    if interaction.response and interaction.response.is_done():
                        await interaction.followup.send(f"{self.opponent.mention} accepted the duel!", ephemeral=False)
                except:
                    pass
                await self.run_duel()
            
        @discord.ui.button(label="Reject", style=discord.ButtonStyle.danger)
        async def reject(self, interaction: discord.Interaction, button: discord.ui.Button):
            try:
                if interaction.user.id != self.opponent.id:
                    if interaction.response and not interaction.response.is_done():
                        return await interaction.response.send_message("This invite is not for you.", ephemeral=True)
                    return
                
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.edit_message(content=f"{self.opponent.mention} rejected the duel.", view=None)
            except Exception as e:
                print(f"Error in duel reject: {e}")
                # Try to send a followup message if the response is already done
                try:
                    if interaction.response and interaction.response.is_done():
                        await interaction.followup.send(f"{self.opponent.mention} rejected the duel.", ephemeral=True)
                except:
                    pass
            
        async def on_timeout(self):
            try:
                await self.ctx.send("Duel request timed out.")
            except Exception:
                pass
                
        async def run_duel(self):
            # Get full combat stats for both players
            statsA = calculate_combat_stats(self.ctx.author.id)
            statsB = calculate_combat_stats(self.opponent.id)
            
            # Get attributes for both players
            attributesA, _ = get_user_attributes(self.ctx.author.id)
            attributesB, _ = get_user_attributes(self.opponent.id)
            
            # Use equipment-enhanced health and base boundary health
            # Base HP already includes longevity bonus from boundary calculation
            # Equipment health includes armor bonus + artifact health bonus
            # We need to avoid double-counting longevity
            base_hpA = self.hpA_max  # This already includes longevity bonus
            base_hpB = self.hpB_max  # This already includes longevity bonus
            
            # Get only the equipment bonuses (armor + artifacts), not base health
            # Calculate equipment health more accurately by using the actual equipment
            equipment_healthA = 0
            equipment_healthB = 0
            
            # Get user equipment to calculate actual equipment bonuses
            equipmentA = get_user_equipment(self.ctx.author.id)
            equipmentB = get_user_equipment(self.opponent.id)
            
            # Calculate armor health bonus
            if equipmentA.get("armor") and isinstance(equipmentA["armor"], dict):
                equipment_healthA += equipmentA["armor"].get("health", 0)
            if equipmentB.get("armor") and isinstance(equipmentB["armor"], dict):
                equipment_healthB += equipmentB["armor"].get("health", 0)
            
            # Calculate artifact health bonuses
            if equipmentA.get("artifacts"):
                for artifact in equipmentA["artifacts"]:
                    if artifact and isinstance(artifact, dict):
                        equipment_healthA += artifact.get("health", 0)
            if equipmentB.get("artifacts"):
                for artifact in equipmentB["artifacts"]:
                    if artifact and isinstance(artifact, dict):
                        equipment_healthB += artifact.get("health", 0)
            
            hpA = base_hpA + equipment_healthA
            hpB = base_hpB + equipment_healthB
            hpA_max = hpA  # Update max HP to include equipment
            hpB_max = hpB  # Update max HP to include equipment
            
            pills_left: Dict[int, int] = {self.ctx.author.id: 3, self.opponent.id: 3}
            view = PvPActionView(self.ctx.author.id, self.opponent.id)

            # Opening embed with equipment info
            embed = discord.Embed(title="⚔️ Enhanced Duel Begins!", color=0x9b59b6)
            embed.add_field(name=f"{self.ctx.author.display_name} — {self.bA.title()}", value=_hp_bar(hpA, hpA_max), inline=False)
            embed.add_field(name=f"{self.opponent.display_name} — {self.bB.title()}", value=_hp_bar(hpB, hpB_max), inline=False)
            
            # Show equipment bonuses
            weapon_bonusA = statsA['total_damage'] - (attributesA.get('strength', 0) * 2)
            weapon_bonusB = statsB['total_damage'] - (attributesB.get('strength', 0) * 2)
            armor_bonusA = equipment_healthA
            armor_bonusB = equipment_healthB
            
            equipment_bonusA = f"**Weapon:** +{weapon_bonusA} damage\n**Armor:** +{armor_bonusA} health\n**Defense:** +{statsA['total_defense']} defense\n**Crit:** +{statsA['critical_chance']}%"
            equipment_bonusB = f"**Weapon:** +{weapon_bonusB} damage\n**Armor:** +{armor_bonusB} health\n**Defense:** +{statsB['total_defense']} defense\n**Crit:** +{statsB['critical_chance']}%"
            
            embed.add_field(name=f"⚔️ {self.ctx.author.display_name}'s Equipment", value=equipment_bonusA, inline=True)
            embed.add_field(name=f"⚔️ {self.opponent.display_name}'s Equipment", value=equipment_bonusB, inline=True)
            embed.set_footer(text="Choose: Attack • Counter • Pill • Special — next resolve in 5s")
            msg = await self.ctx.send(embed=embed, view=view)

            round_idx = 0
            while hpA > 0 and hpB > 0 and round_idx < 20:
                await asyncio.sleep(5)
                
                # Get choices from the view
                choiceA = view.choices.pop(self.ctx.author.id, None)
                choiceB = view.choices.pop(self.opponent.id, None)

                # Defaults: no choice = idle (acts as failed action)
                defendA = False
                defendB = False
                dmg_to_B = 0
                dmg_to_A = 0
                healA = 0
                healB = 0
                notes = []

                # Success rolls with some failure variance (±10% randomness)
                succA = (random.random() * 100) < max(0, min(100, self.pctA + random.randint(-10, 10)))
                succB = (random.random() * 100) < max(0, min(100, self.pctB + random.randint(-10, 10)))

                # Process A's turn
                if choiceA == "attack" and succA:
                    base_dmg = random.randint(15, 25)
                    strength_bonus = attributesA.get("strength", 0) * 2
                    weapon_bonus = statsA["total_damage"] - strength_bonus
                    
                    # Check for critical hit
                    is_crit = random.random() * 100 < statsA["critical_chance"]
                    if is_crit:
                        weapon_bonus = int(weapon_bonus * 1.5)
                        notes.append(f"🔥 {self.ctx.author.display_name} landed a critical hit!")
                    
                    dmg_to_B = base_dmg + strength_bonus + weapon_bonus
                    
                elif choiceA == "counter" and succA:
                    defendA = True
                    notes.append(f"🛡️ {self.ctx.author.display_name} takes defensive stance")
                    
                elif choiceA == "pill" and succA and pills_left[self.ctx.author.id] > 0:
                    base_heal = random.randint(20, 30)
                    armor_bonus = equipment_healthA
                    healA = base_heal + armor_bonus
                    pills_left[self.ctx.author.id] -= 1
                    notes.append(f"💊 {self.ctx.author.display_name} used healing pill (+{healA} HP)")
                    
                elif choiceA == "special" and succA:
                    # Special ability based on artifacts
                    artifact_count = len(statsA.get("artifacts", []))
                    if artifact_count >= 2:
                        weapon_bonus = statsA["total_damage"] - (attributesA.get("strength", 0) * 2)
                        dmg_to_B = random.randint(25, 35) + weapon_bonus
                        notes.append(f"✨ {self.ctx.author.display_name} uses artifact synergy!")
                    else:
                        defendA = True
                        notes.append(f"✨ {self.ctx.author.display_name} channels artifact power!")

                # Process B's turn
                if choiceB == "attack" and succB:
                    base_dmg = random.randint(15, 25)
                    strength_bonus = attributesB.get("strength", 0) * 2
                    weapon_bonus = statsB["total_damage"] - strength_bonus
                    
                    is_crit = random.random() * 100 < statsB["critical_chance"]
                    if is_crit:
                        weapon_bonus = int(weapon_bonus * 1.5)
                        notes.append(f"🔥 {self.opponent.display_name} landed a critical hit!")
                    
                    dmg_to_A = base_dmg + strength_bonus + weapon_bonus
                    
                elif choiceB == "counter" and succB:
                    defendB = True
                    notes.append(f"🛡️ {self.opponent.display_name} takes defensive stance")
                    
                elif choiceB == "pill" and succB and pills_left[self.opponent.id] > 0:
                    base_heal = random.randint(20, 30)
                    armor_bonus = equipment_healthB
                    healB = base_heal + armor_bonus
                    pills_left[self.opponent.id] -= 1
                    notes.append(f"💊 {self.opponent.display_name} used healing pill (+{healB} HP)")
                    
                elif choiceB == "special" and succB:
                    artifact_count = len(statsB.get("artifacts", []))
                    if artifact_count >= 2:
                        weapon_bonus = statsB["total_damage"] - (attributesB.get("strength", 0) * 2)
                        dmg_to_A = random.randint(25, 35) + weapon_bonus
                        notes.append(f"✨ {self.opponent.display_name} uses artifact synergy!")
                    else:
                        defendB = True
                        notes.append(f"✨ {self.opponent.display_name} channels artifact power!")

                # Apply defend mitigation
                if defendB and dmg_to_B > 0:
                    base_mitigation = 0.6
                    defense_bonus = statsB["total_defense"] * 0.01
                    total_mitigation = min(0.85, base_mitigation + defense_bonus)
                    dmg_to_B = max(1, int(dmg_to_B * (1 - total_mitigation)))
                    notes.append(f"🛡️ {self.opponent.display_name} blocks {int(total_mitigation * 100)}% damage")
                    
                if defendA and dmg_to_A > 0:
                    base_mitigation = 0.6
                    defense_bonus = statsA["total_defense"] * 0.01
                    total_mitigation = min(0.85, base_mitigation + defense_bonus)
                    dmg_to_A = max(1, int(dmg_to_A * (1 - total_mitigation)))
                    notes.append(f"🛡️ {self.ctx.author.display_name} blocks {int(total_mitigation * 100)}% damage")

                # Update hp
                hpB = max(0, min(hpB_max, hpB - dmg_to_B + healB))
                hpA = max(0, min(hpA_max, hpA - dmg_to_A + healA))

                # Build action summary
                action_summary = f"**Round {round_idx + 1}**\n"
                if dmg_to_A > 0:
                    action_summary += f"💥 {self.opponent.display_name} deals {dmg_to_A} damage to {self.ctx.author.display_name}\n"
                if dmg_to_B > 0:
                    action_summary += f"💥 {self.ctx.author.display_name} deals {dmg_to_B} damage to {self.opponent.display_name}\n"
                if healA > 0:
                    action_summary += f"💚 {self.ctx.author.display_name} heals {healA} HP\n"
                if healB > 0:
                    action_summary += f"💚 {self.opponent.display_name} heals {healB} HP\n"
                
                # Add notes
                if notes:
                    action_summary += "\n" + "\n".join(notes)

                # Update embed
                upd = discord.Embed(title="⚔️ Duel in Progress", color=0x9b59b6)
                upd.description = action_summary
                upd.add_field(name=f"{self.ctx.author.display_name} — {self.bA.title()}", value=_hp_bar(hpA, hpA_max), inline=False)
                upd.add_field(name=f"{self.opponent.display_name} — {self.bB.title()}", value=_hp_bar(hpB, hpB_max), inline=False)
                upd.set_footer(text=f"Round {round_idx + 1}/20 • Choose: Attack • Counter • Pill • Special — next resolve in 5s")
                
                try:
                    await msg.edit(embed=upd, view=view)
                except Exception as e:
                    print(f"ERROR editing duel message: {e}")
                    break

                round_idx += 1

            # Final result
            winner = self.ctx.author if hpA > 0 else self.opponent
            loser = self.opponent if hpA > 0 else self.ctx.author
            winner_hp = hpA if hpA > 0 else hpB
            
            final_embed = discord.Embed(title="🏆 Duel Complete!", color=0x2ecc71)
            final_embed.add_field(name="Winner", value=f"{winner.mention} ({winner_hp} HP remaining)", inline=True)
            final_embed.add_field(name="Loser", value=f"{loser.mention} (0 HP)", inline=True)
            final_embed.add_field(name="Rounds", value=f"{round_idx} rounds", inline=True)
            final_embed.set_footer(text="The duel has ended!")
            
            try:
                await msg.edit(embed=final_embed, view=None)
            except Exception as e:
                print(f"ERROR editing final duel message: {e}")
            
            # Disable the view
            view.stop()

    # Create and send the invite view
    invite_view = DuelInvite(ctx, opponent, bA, hpA_max, pctA, bB, hpB_max, pctB)
    invite_msg = await ctx.send(content=f"{opponent.mention}, {ctx.author.mention} challenges you to a duel!", view=invite_view)


# -----------------------
# Tournament (Bracketed 1v1 using PvP system)
# -----------------------

def _load_tournaments() -> Dict[str, Any]:
    data = load_json(TOURNAMENTS_FILE)
    if not isinstance(data, dict):
        return {}
    return data


def _save_tournaments(data: Dict[str, Any]) -> None:
    save_json(TOURNAMENTS_FILE, data)


def _generate_tournament_id() -> str:
    """Generate a unique tournament ID"""
    import uuid
    return str(uuid.uuid4())[:8]


def _build_bracket_pairs(user_ids: list[int]) -> list[tuple[int, int | None]]:
    # Shuffle and pair adjacent users; if odd, last gets a bye (pair with None)
    ids = [int(x) for x in user_ids]
    random.shuffle(ids)
    pairs: list[tuple[int, int | None]] = []
    i = 0
    while i < len(ids):
        if i + 1 < len(ids):
            pairs.append((ids[i], ids[i + 1]))
            i += 2
        else:
            pairs.append((ids[i], None))
            i += 1
    return pairs


async def _run_tournament_duel(channel: discord.abc.Messageable, a: discord.Member, b: discord.Member) -> discord.Member | None:
    # Reuse enhanced PvP mechanics without invite/accept, in the provided channel
    bA, hpA_max, pctA = _get_boundary_info(a)
    bB, hpB_max, pctB = _get_boundary_info(b)
    if bA == bB:
        pctA = pctB = 50

    # Get full combat stats for both players
    statsA = calculate_combat_stats(a.id)
    statsB = calculate_combat_stats(b.id)
    
    # Get attributes for both players
    attributesA, _ = get_user_attributes(a.id)
    attributesB, _ = get_user_attributes(b.id)
    
    # Use equipment-enhanced health and base boundary health
    # Base HP already includes longevity bonus from boundary calculation
    # Equipment health includes armor bonus + artifact health bonus
    # We need to avoid double-counting longevity
    base_hpA = hpA_max  # This already includes longevity bonus
    base_hpB = hpB_max  # This already includes longevity bonus
    
    # Get only the equipment bonuses (armor + artifacts), not base health
    # Calculate equipment health more accurately by using the actual equipment
    equipment_healthA = 0
    equipment_healthB = 0
    
    # Get user equipment to calculate actual equipment bonuses
    equipmentA = get_user_equipment(a.id)
    equipmentB = get_user_equipment(b.id)
    
    # Calculate armor health bonus
    if equipmentA.get("armor") and isinstance(equipmentA["armor"], dict):
        equipment_healthA += equipmentA["armor"].get("health", 0)
    if equipmentB.get("armor") and isinstance(equipmentB["armor"], dict):
        equipment_healthB += equipmentB["armor"].get("health", 0)
    
    # Calculate artifact health bonuses
    if equipmentA.get("artifacts"):
        for artifact in equipmentA["artifacts"]:
            if artifact and isinstance(artifact, dict):
                equipment_healthA += artifact.get("health", 0)
    if equipmentB.get("artifacts"):
        for artifact in equipmentB["artifacts"]:
            if artifact and isinstance(artifact, dict):
                equipment_healthB += artifact.get("health", 0)
    
    hpA = base_hpA + equipment_healthA
    hpB = base_hpB + equipment_healthB
    hpA_max = hpA  # Update max HP to include equipment
    hpB_max = hpB  # Update max HP to include equipment
    
    pills_left: Dict[int, int] = {a.id: 3, b.id: 3}
    view = PvPActionView(a.id, b.id)

    # Opening embed with equipment info
    embed = discord.Embed(title="🏆 Enhanced Tournament Duel Begins!", color=0x9b59b6)
    embed.add_field(name=f"{a.display_name} — {bA.title()}", value=_hp_bar(hpA, hpA_max), inline=False)
    embed.add_field(name=f"{b.display_name} — {bB.title()}", value=_hp_bar(hpB, hpB_max), inline=False)
    
    # Show equipment bonuses
    weapon_bonusA = statsA['total_damage'] - (attributesA.get('strength', 0) * 2)
    weapon_bonusB = statsB['total_damage'] - (attributesB.get('strength', 0) * 2)
    armor_bonusA = equipment_healthA
    armor_bonusB = equipment_healthB
    
    equipment_bonusA = f"**Weapon:** +{weapon_bonusA} damage\n**Armor:** +{armor_bonusA} health\n**Defense:** +{statsA['total_defense']} defense\n**Crit:** +{statsA['critical_chance']}%"
    equipment_bonusB = f"**Weapon:** +{weapon_bonusB} damage\n**Armor:** +{armor_bonusB} health\n**Crit:** +{statsB['critical_chance']}%"
    
    embed.add_field(name=f"⚔️ {a.display_name}'s Equipment", value=equipment_bonusA, inline=True)
    embed.add_field(name=f"⚔️ {b.display_name}'s Equipment", value=equipment_bonusB, inline=True)
    embed.set_footer(text="Choose: Attack • Counter • Pill • Special — next resolve in 5s")
    msg = await channel.send(embed=embed, view=view)

    round_idx = 0
    while hpA > 0 and hpB > 0 and round_idx < 40:
        await asyncio.sleep(5)
        choiceA = view.choices.pop(a.id, None)
        choiceB = view.choices.pop(b.id, None)

        defendA = False
        defendB = False
        dmg_to_B = 0
        dmg_to_A = 0
        healA = 0
        healB = 0
        notes = []

        succA = (random.random() * 100) < max(0, min(100, pctA + random.randint(-10, 10)))
        succB = (random.random() * 100) < max(0, min(100, pctB + random.randint(-10, 10)))

        # Process A's turn
        if choiceA == "attack" and succA:
            base_dmg = random.randint(15, 25)
            strength_bonus = attributesA.get("strength", 0) * 2
            weapon_bonus = statsA["total_damage"] - strength_bonus
            
            # Check for critical hit
            is_crit = random.random() * 100 < statsA["critical_chance"]
            if is_crit:
                weapon_bonus = int(weapon_bonus * 1.5)
                notes.append(f"🔥 {a.display_name} landed a critical hit!")
            
            dmg_to_B = base_dmg + strength_bonus + weapon_bonus
            
        elif choiceA == "counter" and succA:
            defendA = True
            notes.append(f"🛡️ {a.display_name} takes defensive stance")
            
        elif choiceA == "pill" and succA and pills_left[a.id] > 0:
            base_heal = random.randint(20, 30)
            armor_bonus = equipment_healthA
            healA = base_heal + armor_bonus
            pills_left[a.id] -= 1
            notes.append(f"💊 {a.display_name} used healing pill (+{healA} HP)")
            
        elif choiceA == "special" and succA:
            artifact_count = len(statsA.get("artifacts", []))
            if artifact_count >= 2:
                weapon_bonus = statsA["total_damage"] - (attributesA.get("strength", 0) * 2)
                dmg_to_B = random.randint(25, 35) + weapon_bonus
                notes.append(f"✨ {a.display_name} uses artifact synergy!")
            else:
                defendA = True
                notes.append(f"✨ {a.display_name} channels artifact power!")

        # Process B's turn
        if choiceB == "attack" and succB:
            base_dmg = random.randint(15, 25)
            strength_bonus = attributesB.get("strength", 0) * 2
            weapon_bonus = statsB["total_damage"] - strength_bonus
            
            is_crit = random.random() * 100 < statsB["critical_chance"]
            if is_crit:
                weapon_bonus = int(weapon_bonus * 1.5)
                notes.append(f"🔥 {b.display_name} landed a critical hit!")
            
            dmg_to_A = base_dmg + strength_bonus + weapon_bonus
            
        elif choiceB == "counter" and succB:
            defendB = True
            notes.append(f"🛡️ {b.display_name} takes defensive stance")
            
        elif choiceB == "pill" and succB and pills_left[b.id] > 0:
            base_heal = random.randint(20, 30)
            armor_bonus = equipment_healthB
            healB = base_heal + armor_bonus
            pills_left[b.id] -= 1
            notes.append(f"💊 {b.display_name} used healing pill (+{healB} HP)")
            
        elif choiceB == "special" and succB:
            artifact_count = len(statsB.get("artifacts", []))
            if artifact_count >= 2:
                weapon_bonus = statsB["total_damage"] - (attributesB.get("strength", 0) * 2)
                dmg_to_A = random.randint(25, 35) + weapon_bonus
                notes.append(f"✨ {b.display_name} uses artifact synergy!")
            else:
                defendB = True
                notes.append(f"✨ {b.display_name} channels artifact power!")

        # Apply defend mitigation with full defense stats
        if defendB and dmg_to_B > 0:
            base_mitigation = 0.6
            defense_bonus = statsB["total_defense"] * 0.01
            total_mitigation = min(0.85, base_mitigation + defense_bonus)
            dmg_to_B = max(1, int(dmg_to_B * (1 - total_mitigation)))
            notes.append(f"🛡️ {b.display_name} blocks {int(total_mitigation * 100)}% damage")
            
        if defendA and dmg_to_A > 0:
            base_mitigation = 0.6
            defense_bonus = statsA["total_defense"] * 0.01
            total_mitigation = min(0.85, base_mitigation + defense_bonus)
            dmg_to_A = max(1, int(dmg_to_A * (1 - total_mitigation)))
            notes.append(f"🛡️ {a.display_name} blocks {int(total_mitigation * 100)}% damage")

        hpB = max(0, min(hpB_max, hpB - dmg_to_B + healB))
        hpA = max(0, min(hpA_max, hpA - dmg_to_A + healA))

        def fmt(u, c, ok):
            if c is None:
                return f"{u}: idle"
            return f"{u}: {c} {'✅' if ok else '❌'}"

        # Build action summary with notes
        action_summary = (
            f"{fmt(a.display_name, choiceA, succA)}  |  {fmt(b.display_name, choiceB, succB)}\n"
            f"Damage → {b.display_name}: {dmg_to_B}, {a.display_name}: {dmg_to_A}"
        )
        
        if notes:
            action_summary += "\n\n" + "\n".join(notes)

        upd = discord.Embed(title="🏆 Enhanced Tournament Duel", color=0x9b59b6)
        upd.description = action_summary
        upd.add_field(name=f"{a.display_name} — {bA.title()}", value=_hp_bar(hpA, hpA_max), inline=False)
        upd.add_field(name=f"{b.display_name} — {bB.title()}", value=_hp_bar(hpB, hpB_max), inline=False)
        upd.set_footer(text="Next resolve in 5s — choose actions")
        try:
            await msg.edit(embed=upd, view=view)
        except Exception:
            pass

        round_idx += 1

    if hpA <= 0 and hpB <= 0:
        await channel.send(embed=discord.Embed(title="🏁 Duel Result", description="It's a draw! Replaying...", color=0xF1C40F))
        return await _run_tournament_duel(channel, a, b)
    elif hpB <= 0:
        await channel.send(embed=discord.Embed(title="🏁 Duel Result", description=f"{a.mention} wins!", color=0x2ecc71))
        return a
    else:
        await channel.send(embed=discord.Embed(title="🏁 Duel Result", description=f"{b.mention} wins!", color=0xe74c3c))
        return b


class TournamentLobbyView(discord.ui.View):
    def __init__(self, tournament_id: str, host_id: int):
        super().__init__(timeout=None)
        self.tournament_id = tournament_id
        self.host_id = int(host_id)

    @discord.ui.button(label="Join", style=discord.ButtonStyle.primary, emoji="➕")
    async def join(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            await interaction.response.defer(ephemeral=True)
            tournaments = _load_tournaments()
            t = tournaments.get(self.tournament_id)
            if not t:
                await interaction.followup.send("❌ Tournament not found.", ephemeral=True)
                return
            if t.get("status") != "recruiting":
                await interaction.followup.send("❌ Joining is closed.", ephemeral=True)
                return
            participants = t.setdefault("participants", [])
            uid = int(interaction.user.id)
            if uid in participants:
                await interaction.followup.send("You have already joined.", ephemeral=True)
                return
            # Allow hosts to join their own tournaments
            participants.append(uid)
            _save_tournaments(tournaments)
            
            # Update the embed to show new participant count
            await self._update_embed(interaction)
            await interaction.followup.send(f"✅ Joined tournament! Current participants: {len(participants)}", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"❌ Error joining tournament: {str(e)}", ephemeral=True)

    @discord.ui.button(label="Leave", style=discord.ButtonStyle.secondary, emoji="➖")
    async def leave(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            await interaction.response.defer(ephemeral=True)
            tournaments = _load_tournaments()
            t = tournaments.get(self.tournament_id)
            if not t:
                await interaction.followup.send("❌ Tournament not found.", ephemeral=True)
                return
            if t.get("status") != "recruiting":
                await interaction.followup.send("❌ Cannot leave after tournament starts.", ephemeral=True)
                return
            
            participants = t.get("participants", [])
            uid = int(interaction.user.id)
            if uid not in participants:
                await interaction.followup.send("You haven't joined this tournament.", ephemeral=True)
                return
            
            participants.remove(uid)
            _save_tournaments(tournaments)
            
            # Update the embed to show new participant count
            await self._update_embed(interaction)
            await interaction.followup.send(f"✅ Left tournament. Current participants: {len(participants)}", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"❌ Error leaving tournament: {str(e)}", ephemeral=True)

    async def _update_embed(self, interaction: discord.Interaction):
        """Update the tournament embed with current participant count"""
        try:
            tournaments = _load_tournaments()
            t = tournaments.get(self.tournament_id)
            if not t:
                return
            
            # Update participant count field
            for field in interaction.message.embeds[0].fields:
                if field.name == "Participants":
                    field.value = str(len(t.get("participants", [])))
                    break
            
            await interaction.message.edit(embed=interaction.message.embeds[0])
        except Exception as e:
            # If update fails, just log it
            print(f"Failed to update tournament embed: {e}")

    @discord.ui.button(label="Start", style=discord.ButtonStyle.success, emoji="▶️")
    async def start(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            await interaction.response.defer(ephemeral=True)
            # Only host or admins can start
            is_admin = interaction.user.guild_permissions.administrator if interaction.guild else False
            if int(interaction.user.id) != self.host_id and not is_admin:
                await interaction.followup.send("❌ Only the host or an admin can start.", ephemeral=True)
                return

            tournaments = _load_tournaments()
            t = tournaments.get(self.tournament_id)
            if not t:
                await interaction.followup.send("❌ Tournament not found.", ephemeral=True)
                return

            participants = [int(x) for x in t.get("participants", [])]
            if len(participants) < 2:
                await interaction.followup.send("❌ Need at least 2 participants.", ephemeral=True)
                return

            t["status"] = "active"
            _save_tournaments(tournaments)

            # Disable all buttons
            for child in self.children:
                child.disabled = True

            await interaction.message.edit(view=self)
            await interaction.followup.send("🏁 Tournament starting!", ephemeral=True)
            
            # Start the tournament in the background
            asyncio.create_task(self._run_tournament_bracket(interaction.channel, participants))
            
        except Exception as e:
            await interaction.followup.send(f"❌ Error starting tournament: {str(e)}", ephemeral=True)

    async def _run_tournament_bracket(self, channel, participants):
        """Run the tournament bracket in the background"""
        try:
            guild = channel.guild
            current = participants[:]
            round_num = 1
        
            # Send tournament start announcement
            start_embed = discord.Embed(title="🏆 Tournament Begins!", description=f"**Tournament** is now underway!", color=0x2ecc71)
            start_embed.add_field(name="Participants", value=f"{len(participants)}", inline=True)
            start_embed.add_field(name="Format", value="Single Elimination", inline=True)
            start_embed.add_field(name="Status", value="Round 1", inline=True)
            await channel.send(embed=start_embed)
        
            while len(current) > 1:
                round_embed = discord.Embed(title=f"🏆 Round {round_num}", description=f"**{len(current)}** participants remaining", color=0x9b59b6)
                round_embed.add_field(name="Participants", value=", ".join([f"<@{p}>" for p in current]), inline=False)
                await channel.send(embed=round_embed)
            
                pairs = _build_bracket_pairs(current)
                winners: list[int] = []
            
                for a_id, b_id in pairs:
                    if b_id is None:
                        # Bye
                        member_a = guild.get_member(a_id)
                        if member_a:
                            bye_embed = discord.Embed(title="🎉 Bye Round", description=f"{member_a.mention} gets a bye and advances to the next round!", color=0xf1c40f)
                            await channel.send(embed=bye_embed)
                            winners.append(a_id)
                        continue
                
                    member_a = guild.get_member(a_id)
                    member_b = guild.get_member(b_id)
                    if not member_a or not member_b:
                        # If one missing, advance the other
                        survivor = a_id if member_a else (b_id if member_b else None)
                        if survivor is not None:
                            winners.append(survivor)
                            auto_embed = discord.Embed(title="⚠️ Auto-Advance", description=f"<@{survivor}> advances automatically (opponent unavailable)", color=0xe67e22)
                            await channel.send(embed=auto_embed)
                        continue
                
                    match_embed = discord.Embed(title="⚔️ Match", description=f"{member_a.mention} **VS** {member_b.mention}", color=0xe74c3c)
                    match_embed.add_field(name="Round", value=f"Round {round_num}", inline=True)
                    match_embed.add_field(name="Participants Left", value=f"{len(current)}", inline=True)
                    await channel.send(embed=match_embed)
                
                    try:
                        winner_member = await _run_tournament_duel(channel, member_a, member_b)
                        if winner_member:
                            winners.append(winner_member.id)
                            # Update tournament status
                            tournaments = _load_tournaments()
                            if self.tournament_id in tournaments:
                                tournaments[self.tournament_id]["current_round"] = round_num
                                tournaments[self.tournament_id]["remaining_participants"] = len(winners)
                                _save_tournaments(tournaments)
                    except Exception as e:
                        print(f"Error in tournament duel: {e}")
                        # If duel fails, randomly select winner
                        winner = random.choice([a_id, b_id])
                        winners.append(winner)
                        error_embed = discord.Embed(title="⚠️ Duel Error", description=f"Duel failed, {guild.get_member(winner).mention} advances randomly", color=0xe67e22)
                        await channel.send(embed=error_embed)
            
                current = winners
                round_num += 1
            
                # Small delay between rounds
                await asyncio.sleep(2)

            # Declare champion and give rewards
            champion_id = current[0]
        
            # Update tournament status
            tournaments = _load_tournaments()
            if self.tournament_id in tournaments:
                tournaments[self.tournament_id]["status"] = "completed"
                tournaments[self.tournament_id]["winner_id"] = int(champion_id)
                tournaments[self.tournament_id]["completed_at"] = int(time.time())
                _save_tournaments(tournaments)
        
            # Get tournament data for rewards
            tournament_data = tournaments.get(self.tournament_id, {})
            money_reward = tournament_data.get("money_reward", 0)
            xp_reward = tournament_data.get("xp_reward", 0)
        
            # Give rewards to winner
            if money_reward > 0:
                add_cash(champion_id, money_reward)
            if xp_reward > 0:
                # Add to personal XP instead of sect XP for tournaments
                user_meta = get_user_meta(champion_id)
                current_xp = user_meta.get("personal_xp", 0)
                user_meta["personal_xp"] = current_xp + xp_reward
                set_user_meta(champion_id, user_meta)
        
            # Send winner announcement
            winner_embed = discord.Embed(title="🎉 Tournament Champion!", description=f"<@{champion_id}> has won the tournament!", color=0x2ecc71)
            winner_embed.add_field(name="Rewards", value=f"{MONEY_ICON} {money_reward:,} + {xp_reward} XP", inline=True)
            winner_embed.add_field(name="Participants", value=f"{len(participants)}", inline=True)
            winner_embed.add_field(name="Total Rounds", value=f"{round_num - 1}", inline=True)
        
            try:
                winner = await bot.fetch_user(champion_id)
                if winner.display_avatar:
                    winner_embed.set_thumbnail(url=winner.display_avatar.url)
            except:
                pass
        
            await channel.send(embed=winner_embed)
        
            # Send final tournament summary
            summary_embed = discord.Embed(title="🏆 Tournament Complete!", color=0x2ecc71)
            summary_embed.add_field(name="Champion", value=f"<@{champion_id}>", inline=True)
            summary_embed.add_field(name="Total Participants", value=f"{len(participants)}", inline=True)
            summary_embed.add_field(name="Total Rounds", value=f"{round_num - 1}", inline=True)
            summary_embed.add_field(name="Final Rewards", value=f"{MONEY_ICON} {money_reward:,} + {xp_reward} XP", inline=True)
            summary_embed.set_footer(text="Tournament completed successfully!")
            await channel.send(embed=summary_embed)
        
        except Exception as e:
            print(f"Error in tournament bracket: {e}")
            import traceback
            traceback.print_exc()
        
            # Send error message to channel
            error_embed = discord.Embed(title="❌ Tournament Error", description="An error occurred during the tournament. Please contact an administrator.", color=0xe74c3c)
            await channel.send(embed=error_embed)

    async def _update_embed(self, interaction: discord.Interaction):
        """Update the tournament embed with current participant count"""
        tournaments = _load_tournaments()
        t = tournaments.get(self.tournament_id)
        if not t:
            return
        
        participants = t.get("participants", [])
        embed = interaction.message.embeds[0]
        
        # Update participant count field
        for field in embed.fields:
            if field.name == "Participants":
                field.value = str(len(participants))
                break
        
        await interaction.message.edit(embed=embed)





@bot.command(name="tournament_edit_rewards")
@commands.has_permissions(administrator=True)
async def tournament_edit_rewards(ctx: commands.Context, tournament_id: str, money_reward: int, xp_reward: int):
    """Edit the rewards for a specific tournament"""
    tournaments = _load_tournaments()
    
    if tournament_id not in tournaments:
        await send_embed(ctx, "Tournament Not Found", "Tournament ID not found.", 0xe74c3c)
        return
    
    tournament = tournaments[tournament_id]
    
    # Update rewards
    tournament["rewards"]["money"] = money_reward
    tournament["rewards"]["xp"] = xp_reward
    
    _save_tournaments(tournaments)
    
    embed = discord.Embed(title="🏆 Tournament Rewards Updated", color=TOURNAMENT_COLOR)
    embed.description = f"**Tournament:** {tournament['title']}"
    embed.add_field(name="New Money Reward", value=f"{MONEY_ICON} {money_reward:,}", inline=True)
    embed.add_field(name="New XP Reward", value=f"🎯 {xp_reward:,}", inline=True)
    embed.set_footer(text=f"Tournament ID: {tournament_id[:8]}...")
    
    await ctx.send(embed=embed)





@bot.hybrid_command(name="tournament_info", description="Get detailed info about a tournament")
async def tournament_info(ctx, tournament_id: str):
    tournaments = _load_tournaments()
    t = tournaments.get(tournament_id)
    
    if not t:
        await send_embed(ctx, "Tournament Not Found", "Tournament ID not found.", 0xe74c3c)
        return
    
    embed = discord.Embed(title=f"🏆 {t.get('title', 'Untitled')}", color=TOURNAMENT_COLOR)
    embed.description = t.get("description", "No description provided.")
    
    # Status and participants
    status = t.get("status", "unknown").title()
    participants = t.get("participants", [])
    host_id = t.get("host_id")
    
    embed.add_field(name="Status", value=status, inline=True)
    embed.add_field(name="Participants", value=f"{len(participants)}", inline=True)
    
    # Host info
    try:
        host = await bot.fetch_user(host_id)
        host_name = host.display_name
    except:
        host_name = f"User {host_id}"
    embed.add_field(name="Host", value=host_name, inline=True)
    
    # Rewards
    rewards = t.get("rewards", {})
    if rewards:
        money = rewards.get("money", 0)
        xp = rewards.get("xp", 0)
        embed.add_field(name="Rewards", value=f"{MONEY_ICON} {money:,} + {xp} XP", inline=True)
    
    # Winner
    winner_id = t.get("winner_id")
    if winner_id:
        try:
            winner = await bot.fetch_user(winner_id)
            winner_name = winner.display_name
        except:
            winner_name = f"User {winner_id}"
        embed.add_field(name="Winner", value=winner_name, inline=True)
    
    # Participants list
    if participants:
        participant_names = []
        for p_id in participants[:10]:  # Show first 10
            try:
                p_user = await bot.fetch_user(p_id)
                participant_names.append(p_user.display_name)
            except:
                participant_names.append(f"User {p_id}")
        
        if len(participants) > 10:
            participant_names.append(f"... and {len(participants) - 10} more")
        
        embed.add_field(name="Participants", value="\n".join(participant_names), inline=False)
    
    await ctx.send(embed=embed)






# -----------------------
# Helper: human-friendly currency
def format_currency(amount: int) -> str:
    if amount < 0:
        return f"⚠️ **DEBT** {MONEY_ICON} {abs(amount):,}"
    else:
        return f"{MONEY_ICON} {amount:,}"


# -----------------------
# Auction hall - list, sell, buy
@bot.hybrid_command(name="auction_list", description="List auction hall items")
async def auction_list(ctx):
    try:
        auctions = load_json(AUCTIONS_FILE)
        if not auctions:
            await send_embed(ctx, "Auction Hall", "The auction hall is empty.", 0xe67e22)
            return
        embed = discord.Embed(title="🏛 Auction Hall", color=0xf1c40f)
        for item_key, data in auctions.items():
            price = data.get("price", 0)
            seller = data.get("seller")
            item_name = data.get("item_name", item_key)
            listed_at = data.get("listed_at", 0)
            
            # Format time
            time_str = ""
            if listed_at:
                time_ago = int(time.time()) - listed_at
                if time_ago < 3600:  # Less than 1 hour
                    time_str = f" ({time_ago // 60}m ago)"
                elif time_ago < 86400:  # Less than 1 day
                    time_str = f" ({time_ago // 3600}h ago)"
                else:
                    time_str = f" ({time_ago // 86400}d ago)"
            
            embed.add_field(
                name=f"🏷️ {item_name.title()}", 
                value=f"{format_currency(price)} — Seller: <@{seller}>{time_str}", 
                inline=False
            )
        await ctx.send(embed=embed)
    except Exception as e:
        await send_embed(ctx, "Auction Error", f"An error occurred: {str(e)}", 0xe74c3c)


@bot.hybrid_command(name="auction_sell", description="List an item in the auction hall (must be in your inventory)")
@app_commands.autocomplete(item_name=inventory_item_autocomplete)
async def auction_sell(ctx, item_name: str, price: int):
    try:
        # verify owner has item
        meta = get_user_meta(ctx.author.id)
        inv = meta.get("inventory", [])
        
        # Find the actual item in inventory
        item_found = None
        for item in inv:
            if isinstance(item, dict) and item.get("name") == item_name:
                item_found = item
                break
            elif isinstance(item, str) and item == item_name:
                item_found = {"name": item, "type": "unknown", "rarity": "common"}
                break
        
        if not item_found:
            await send_embed(ctx, "Auction", "You don't own that item in your inventory.", 0xe74c3c)
            return

        auctions = load_json(AUCTIONS_FILE)
        # ensure unique listing key (append seller id if conflict)
        key = item_name
        if key in auctions:
            key = f"{item_name}_{ctx.author.id}"
        
        # Store complete item data in auction
        auctions[key] = {
            "price": int(price), 
            "seller": ctx.author.id,
            "item_name": item_name,
            "item_data": item_found,
            "listed_at": int(time.time())
        }
        save_json(AUCTIONS_FILE, auctions)

        # remove from user's inventory
        if isinstance(item_found, dict):
            # Handle stacked items properly
            if item_found.get("amount", 1) > 1:
                # Reduce stack amount
                item_found["amount"] -= 1
                meta["inventory"] = inv
                set_user_meta(ctx.author.id, meta)
            else:
                # Remove entire item
                inv.remove(item_found)
                meta["inventory"] = inv
                set_user_meta(ctx.author.id, meta)
        else:
            inv.remove(item_name)
            meta["inventory"] = inv
            set_user_meta(ctx.author.id, meta)

        await send_embed(ctx, "Auction", f"Listed **{item_name}** for {format_currency(price)} in the auction hall.", 0x2ecc71)
    except Exception as e:
        await send_embed(ctx, "Auction Error", f"An error occurred: {str(e)}", 0xe74c3c)


@bot.hybrid_command(name="auction_buy", description="Buy an item from the auction hall")
@app_commands.autocomplete(listing_key=auction_item_autocomplete)
async def auction_buy(ctx, listing_key: str):
    try:
        auctions = load_json(AUCTIONS_FILE)
        if listing_key not in auctions:
            await send_embed(ctx, "Auction", "Listing not found.", 0xe74c3c)
            return
        listing = auctions[listing_key]
        price = int(listing.get("price", 0))
        seller = int(listing.get("seller"))

        cash, _ = get_balances(ctx.author.id)
        if cash < price:
            await send_embed(ctx, "Auction", "You don't have enough Spirit Stones.", 0xe74c3c)
            return
        if seller == ctx.author.id:
            await send_embed(ctx, "Auction", "You cannot buy your own listing.", 0xe74c3c)
            return

        # transfer funds
        set_cash(ctx.author.id, cash - price)
        add_cash(seller, price)

        # give item to buyer
        meta = get_user_meta(ctx.author.id)
        inv = meta.get("inventory", [])
        
        # Use the stored item data if available, otherwise create default
        if "item_data" in listing and listing["item_data"]:
            inventory_item = listing["item_data"].copy()
            inventory_item["added_by"] = ctx.author.id
            inventory_item["added_at"] = int(time.time())
            inventory_item["source"] = "auction_purchase"
            inventory_item["purchased_price"] = price
        else:
            # Fallback to default format
            original_item_name = listing.get("item_name", listing_key.split("_")[0])
            inventory_item = {
                "name": original_item_name,
                "rarity": "common",
                "type": "artifact",
                "description": f"Item purchased from auction: {original_item_name}",
                "value": price,
                "added_by": ctx.author.id,
                "added_at": int(time.time()),
                "source": "auction_purchase",
                "purchased_price": price
            }
        
        # Use the stacking function to add the item
        add_item_to_inventory(ctx.author.id, inventory_item)

        # remove auction
        del auctions[listing_key]
        save_json(AUCTIONS_FILE, auctions)

        await send_embed(ctx, "Auction", f"You bought **{listing.get('item_name', listing_key.split('_')[0])}** for {format_currency(price)}!", 0x2ecc71)
    except Exception as e:
        await send_embed(ctx, "Auction Error", f"An error occurred: {str(e)}", 0xe74c3c)


@bot.hybrid_command(name="auction_cancel", description="Cancel your auction listing")
@app_commands.autocomplete(listing_key=auction_item_autocomplete)
async def auction_cancel(ctx, listing_key: str):
    try:
        auctions = load_json(AUCTIONS_FILE)
        if listing_key not in auctions:
            await send_embed(ctx, "Auction", "Listing not found.", 0xe74c3c)
            return
        
        listing = auctions[listing_key]
        seller = int(listing.get("seller"))
        
        if seller != ctx.author.id:
            await send_embed(ctx, "Auction", "You can only cancel your own listings.", 0xe74c3c)
            return
        
        # Return item to seller's inventory
        meta = get_user_meta(ctx.author.id)
        inv = meta.get("inventory", [])
        
        if "item_data" in listing and listing["item_data"]:
            # Return the original item data
            returned_item = listing["item_data"].copy()
            returned_item["returned_from_auction"] = True
            returned_item["returned_at"] = int(time.time())
            # Use the stacking function to add the item
            add_item_to_inventory(ctx.author.id, returned_item)
        else:
            # Fallback: create basic item
            item_name = listing.get("item_name", listing_key.split("_")[0])
            returned_item = {
                "name": item_name,
                "type": "artifact",
                "rarity": "common",
                "description": f"Item returned from auction: {item_name}",
                "returned_from_auction": True,
                "returned_at": int(time.time())
            }
            # Use the stacking function to add the item
            add_item_to_inventory(ctx.author.id, returned_item)
        
        # Remove auction
        del auctions[listing_key]
        save_json(AUCTIONS_FILE, auctions)
        
        await send_embed(ctx, "Auction Cancelled", f"Your listing for **{listing.get('item_name', listing_key.split('_')[0])}** has been cancelled and the item returned to your inventory.", 0x2ecc71)
    except Exception as e:
        await send_embed(ctx, "Auction Error", f"An error occurred: {str(e)}", 0xe74c3c)


@bot.hybrid_command(name="give_item", aliases=["give", "gift"])
@app_commands.describe(
    user="The user to give the item to",
    item_name="The name of the item to give",
    amount="Amount of items to give (default: 1, or 'all' for entire stack)"
)
@app_commands.autocomplete(item_name=inventory_item_autocomplete)
async def give_item(ctx, user: discord.Member, item_name: str, amount: str = "1"):
    try:
        # Check if user is trying to give to themselves
        if user.id == ctx.author.id:
            await send_embed(ctx, "Give Item", "You cannot give items to yourself.", 0xe74c3c)
            return
        
        # Check if target user is a bot
        if user.bot:
            await send_embed(ctx, "Give Item", "You cannot give items to bots.", 0xe74c3c)
            return
        
        # Get sender's inventory
        sender_meta = get_user_meta(ctx.author.id)
        sender_inv = sender_meta.get("inventory", [])
        
        # Find the item in sender's inventory
        found_item = None
        item_index = -1
        for i, item in enumerate(sender_inv):
            if isinstance(item, dict) and item.get("name") == item_name:
                found_item = item
                item_index = i
                break
            elif isinstance(item, str) and item == item_name:
                found_item = {"name": item, "type": "unknown", "rarity": "common"}
                item_index = i
                break
        
        if not found_item:
            await send_embed(ctx, "Give Item", "You don't have that item in your inventory.", 0xe74c3c)
            return
        
        # Parse amount parameter
        give_amount = 1
        give_all_from_stack = False
        
        if amount.lower() == "all":
            give_all_from_stack = True
            give_amount = found_item.get("amount", 1) if isinstance(found_item, dict) else 1
        else:
            try:
                give_amount = int(amount)
                if give_amount <= 0:
                    return await send_embed(ctx, "Give Item Error", "Amount must be a positive number or 'all'.", 0xe74c3c)
            except ValueError:
                return await send_embed(ctx, "Give Item Error", "Amount must be a number or 'all'.", 0xe74c3c)
        
        # Check if user has enough of the item to give
        item_amount = found_item.get("amount", 1) if isinstance(found_item, dict) else 1
        if give_amount > item_amount:
            return await send_embed(ctx, "Give Item Error", f"You only have {item_amount} of that item, but you're trying to give {give_amount}.", 0xe74c3c)
        
        # Get receiver's inventory
        receiver_meta = get_user_meta(user.id)
        receiver_inv = receiver_meta.get("inventory", [])
        
        # Create a copy of the item for the receiver with the specified amount
        if isinstance(found_item, dict):
            given_item = found_item.copy()
            given_item["amount"] = give_amount  # Set the amount to give
            given_item["given_by"] = ctx.author.id
            given_item["given_at"] = int(time.time())
            given_item["source"] = "gifted"
        else:
            # Handle legacy string items
            given_item = {
                "name": found_item,
                "type": "unknown",
                "rarity": "common",
                "amount": give_amount,  # Set the amount to give
                "given_by": ctx.author.id,
                "given_at": int(time.time()),
                "source": "gifted"
            }
        
        # Add item to receiver's inventory using the stacking function
        add_item_to_inventory(user.id, given_item)
        
        # Get updated receiver meta to ensure we have the latest data
        receiver_meta = get_user_meta(user.id)
        
        # Remove item from sender's inventory
        if item_index >= 0 and item_index < len(sender_inv):
            if give_amount == item_amount:
                # Giving entire stack, remove the item completely
                sender_inv.pop(item_index)
            else:
                # Giving partial stack, reduce the amount
                found_item["amount"] = item_amount - give_amount
        else:
            # Fallback removal
            if isinstance(found_item, dict):
                sender_inv.remove(found_item)
            else:
                sender_inv.remove(found_item)
        
        sender_meta["inventory"] = sender_inv
        set_user_meta(ctx.author.id, sender_meta)
        
        # Create success message
        item_display_name = found_item.get("name", found_item) if isinstance(found_item, dict) else found_item
        rarity = found_item.get("rarity", "common") if isinstance(found_item, dict) else "common"
        emoji = RARITY_EMOJI.get(rarity, "")
        
        embed = discord.Embed(title=f"Item Given {emoji}", color=0x2ecc71)
        if give_amount > 1:
            embed.description = f"You gave **{give_amount}x {item_display_name.title()}** ({rarity.title()}) to {user.mention}"
        else:
            embed.description = f"You gave **{item_display_name.title()}** ({rarity.title()}) to {user.mention}"
        embed.add_field(name="From", value=ctx.author.mention, inline=True)
        embed.add_field(name="To", value=user.mention, inline=True)
        embed.add_field(name="Item", value=f"{give_amount}x {item_display_name.title()} ({rarity.title()})" if give_amount > 1 else f"{item_display_name.title()} ({rarity.title()})", inline=False)
        embed.set_footer(text=f"Item transferred at {time.strftime('%Y-%m-%d %H:%M:%S')}")
        
        await ctx.send(embed=embed)
        
        # Try to DM the receiver (optional)
        try:
            receiver_embed = discord.Embed(title=f"Item Received {emoji}", color=0x2ecc71)
            if give_amount > 1:
                receiver_embed.description = f"You received **{give_amount}x {item_display_name.title()}** ({rarity.title()}) from {ctx.author.mention}"
            else:
                receiver_embed.description = f"You received **{item_display_name.title()}** ({rarity.title()}) from {ctx.author.mention}"
            receiver_embed.add_field(name="Item", value=f"{give_amount}x {item_display_name.title()} ({rarity.title()})" if give_amount > 1 else f"{item_display_name.title()} ({rarity.title()})", inline=False)
            receiver_embed.add_field(name="From", value=ctx.author.mention, inline=True)
            receiver_embed.add_field(name="Received At", value=time.strftime('%Y-%m-%d %H:%M:%S'), inline=True)
            receiver_embed.set_footer(text="Use ?use_item to use this item")
            
            await user.send(embed=receiver_embed)
        except discord.Forbidden:
            # User has DMs disabled, that's okay
            pass
        
    except Exception as e:
        await send_embed(ctx, "Give Item Error", f"An error occurred: {str(e)}", 0xe74c3c)


@bot.command(name="gifted_items", aliases=["gifted", "received"])
async def gifted_items(ctx):
    try:
        # Get user's inventory
        meta = get_user_meta(ctx.author.id)
        inv = meta.get("inventory", [])
        
        # Find gifted items
        gifted_items_list = []
        for item in inv:
            if isinstance(item, dict) and item.get("source") == "gifted":
                gifted_items_list.append(item)
        
        if not gifted_items_list:
            await send_embed(ctx, "Gifted Items", "You don't have any items that were given to you by other users.", 0xe67e22)
            return
        
        # Create embed showing gifted items
        embed = discord.Embed(title="🎁 Items Given to You", color=0xf1c40f)
        
        for item in gifted_items_list:
            item_name = item.get("name", "Unknown Item")
            rarity = item.get("rarity", "common")
            emoji = RARITY_EMOJI.get(rarity, "")
            given_by = item.get("given_by", 0)
            given_at = item.get("given_at", 0)
            
            # Format time
            time_str = ""
            if given_at:
                time_ago = int(time.time()) - given_at
                if time_ago < 3600:  # Less than 1 hour
                    time_str = f" ({time_ago // 60}m ago)"
                elif time_ago < 86400:  # Less than 1 day
                    time_str = f" ({time_ago // 3600}h ago)"
                else:
                    time_str = f" ({time_ago // 86400}d ago)"
            
            embed.add_field(
                name=f"{emoji} {item_name.title()} ({rarity.title()})",
                value=f"From: <@{given_by}>{time_str}",
                inline=False
            )
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Gifted Items Error", f"An error occurred: {str(e)}", 0xe74c3c)


# -----------------------
# Item Robbing Helper Function
# -----------------------
async def try_rob_items(ctx, target):
    """Try to rob items from target (low chance, random selection)"""
    try:
        # Low chance to rob items (20% - increased slightly for better engagement)
        if random.random() > 0.20:
            return
        
        target_meta = get_user_meta(target.id)
        target_inventory = target_meta.get("inventory", [])
        
        if not target_inventory:
            return
        
        # Get non-favorite items only
        robbable_items = []
        for item in target_inventory:
            if isinstance(item, dict) and not item.get("favorite", False):
                robbable_items.append(item)
            elif isinstance(item, str):
                robbable_items.append({"name": item, "type": "unknown", "rarity": "common"})
        
        if not robbable_items:
            return
        
        # Enhanced item selection - prefer rarer items but still random
        # Weight items by rarity for more interesting robberies
        weighted_items = []
        for item in robbable_items:
            if isinstance(item, dict):
                rarity = item.get("rarity", "common").lower()
                # Higher weight for rarer items
                if rarity == "primordial":
                    weight = 10
                elif rarity == "divine":
                    weight = 8
                elif rarity == "mythic":
                    weight = 6
                elif rarity == "legendary":
                    weight = 5
                elif rarity == "epic":
                    weight = 4
                elif rarity == "rare":
                    weight = 3
                elif rarity == "uncommon":
                    weight = 2
                else:
                    weight = 1
                
                # Add item multiple times based on weight
                for _ in range(weight):
                    weighted_items.append(item)
            else:
                # String items get base weight
                weighted_items.append(item)
        
        # Check for rare double robbery (5% chance)
        double_robbery = random.random() < 0.05 and len(robbable_items) > 1
        
        # Randomly select items to steal (weighted by rarity)
        if double_robbery:
            stolen_items = random.sample(weighted_items, min(2, len(weighted_items)))
        else:
            stolen_items = [random.choice(weighted_items)]
        
        # Process each stolen item
        robbed_items = []
        for stolen_item in stolen_items:
            # Remove from target's inventory (find and remove the exact item)
            if isinstance(stolen_item, dict):
                # Find the item by matching properties
                for i, item in enumerate(target_inventory):
                    if (isinstance(item, dict) and 
                        item.get("name") == stolen_item.get("name") and
                        item.get("rarity") == stolen_item.get("rarity") and
                        item.get("type") == stolen_item.get("type")):
                        target_inventory.pop(i)
                        break
            else:
                # For string items, remove the first match
                try:
                    target_inventory.remove(stolen_item)
                except ValueError:
                    # Item not found, skip this item
                    continue
            
            # Prepare item for robber's inventory
            if isinstance(stolen_item, dict):
                robbed_item = stolen_item.copy()
                robbed_item["robbed_from"] = target.id
                robbed_item["robbed_at"] = int(time.time())
                robbed_item["source"] = "robbed"
            else:
                robbed_item = {
                    "name": stolen_item, 
                    "type": "unknown", 
                    "rarity": "common",
                    "robbed_from": target.id,
                    "robbed_at": int(time.time()),
                    "source": "robbed"
                }
            
            robbed_items.append(robbed_item)
        
        # Add all robbed items to robber's inventory
        robber_meta = get_user_meta(ctx.author.id)
        robber_inventory = robber_meta.get("inventory", [])
        robber_inventory.extend(robbed_items)
        
        # Save both users' metadata
        target_meta["inventory"] = target_inventory
        set_user_meta(target.id, target_meta)
        
        robber_meta["inventory"] = robber_inventory
        set_user_meta(ctx.author.id, robber_meta)
        
        # Enhanced item robbery notification
        if len(robbed_items) == 1:
            # Single item robbery
            stolen_item = robbed_items[0]
            item_name = stolen_item.get("name", stolen_item) if isinstance(stolen_item, dict) else stolen_item
            item_rarity = stolen_item.get("rarity", "common") if isinstance(stolen_item, dict) else "common"
            item_type = stolen_item.get("type", "unknown") if isinstance(stolen_item, dict) else "unknown"
            
            # Color based on rarity
            rarity_colors = {
                "primordial": 0xffd700,  # Gold
                "divine": 0x9b59b6,      # Purple
                "mythic": 0xe74c3c,      # Red
                "legendary": 0xf39c12,   # Orange
                "epic": 0x3498db,        # Blue
                "rare": 0x2ecc71,        # Green
                "uncommon": 0x95a5a6,    # Gray
                "common": 0xff6b35       # Default orange
            }
            
            embed_color = rarity_colors.get(item_rarity.lower(), 0xff6b35)
            
            embed = discord.Embed(title="🦹 **ITEM ROBBERY SUCCESS!** 🦹", color=embed_color)
            embed.description = f"**{ctx.author.mention}** successfully stole a valuable item from **{target.mention}**!"
            
            # Enhanced item display
            if isinstance(stolen_item, dict):
                embed.add_field(
                    name="🎯 Stolen Item", 
                    value=f"**{item_name}**\n"
                          f"📦 Type: {item_type.title()}\n"
                          f"⭐ Rarity: {item_rarity.title()}", 
                    inline=False
                )
            else:
                embed.add_field(name="🎯 Stolen Item", value=f"**{item_name}**", inline=False)
            
            embed.add_field(name="🦹 Robber", value=ctx.author.mention, inline=True)
            embed.add_field(name="😱 Victim", value=target.mention, inline=True)
            
            # Add rarity-specific message
            if item_rarity.lower() in ["primordial", "divine", "mythic"]:
                embed.add_field(
                    name="💎 **RARE FIND!** 💎", 
                    value=f"This was a **{item_rarity.title()}** item! What a lucky robbery!", 
                    inline=False
                )
        else:
            # Multiple items robbery (rare event!)
            embed = discord.Embed(title="🦹 **DOUBLE ROBBERY SUCCESS!** 🦹", color=0xffd700)
            embed.description = f"**{ctx.author.mention}** pulled off an incredible heist and stole **{len(robbed_items)} items** from **{target.mention}**!"
            
            # List all stolen items
            items_text = ""
            for i, item in enumerate(robbed_items, 1):
                if isinstance(item, dict):
                    item_name = item.get("name", "Unknown Item")
                    item_rarity = item.get("rarity", "common").title()
                    items_text += f"{i}. **{item_name}** ({item_rarity})\n"
                else:
                    items_text += f"{i}. **{item}**\n"
            
            embed.add_field(name="🎯 Stolen Items", value=items_text, inline=False)
            embed.add_field(name="🦹 Master Thief", value=ctx.author.mention, inline=True)
            embed.add_field(name="😱 Unfortunate Victim", value=target.mention, inline=True)
            embed.add_field(
                name="🌟 **LEGENDARY HEIST!** 🌟", 
                value="This was an extremely rare double robbery! The thief's skills are legendary!", 
                inline=False
            )
        
        embed.set_footer(text="💡 Tip: Mark important items as favorites to protect them from robbery!")
        embed.timestamp = datetime.now(timezone.utc)
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Error in try_rob_items: {e}")


# -----------------------
# Rob command
# Rules:
# - Steals from target's cash only (not bank)
# - Robber has 1-hour cooldown (per robber)
# - If target has less than `min_cash` -> cannot be robbed
# - Success chance and stolen amount are random (and scaled)
# - On failure robber pays penalty to target
# - All timestamps saved in economy.json under user meta keys `last_rob` (robber) and `last_robbed` (target)
@bot.hybrid_command(name="rob", description="Attempt to rob another player (1 hour cooldown)")
async def rob(ctx, target: discord.Member):
    if target.bot:
        await send_embed(ctx, "Rob", "You can't rob bots.", 0xe74c3c)
        return
    if target.id == ctx.author.id:
        await send_embed(ctx, "Rob", "You can't rob yourself.", 0xe74c3c)
        return

    # Use simple integer timestamps for cooldown handling
    current_timestamp = int(time.time())
    robber_meta = get_user_meta(ctx.author.id)
    
    # Support legacy ISO string (last_rob) but prefer integer timestamp (last_rob_timestamp)
    last_rob_timestamp = int(robber_meta.get("last_rob_timestamp", 0) or 0)
    if last_rob_timestamp == 0:
        legacy_last_rob = robber_meta.get("last_rob")
        if legacy_last_rob:
            try:
                legacy_dt = datetime.fromisoformat(legacy_last_rob)
                if legacy_dt.tzinfo is None:
                    legacy_dt = legacy_dt.replace(tzinfo=timezone.utc)
                last_rob_timestamp = int(legacy_dt.timestamp())
            except Exception:
                last_rob_timestamp = 0
    
    cooldown_seconds = 3600  # 1 hour
    time_since_last = current_timestamp - last_rob_timestamp
    if time_since_last < cooldown_seconds:
        remaining = cooldown_seconds - time_since_last
        hours = remaining // 3600
        minutes = (remaining % 3600) // 60
        if hours > 0:
            await send_embed(ctx, "Rob Cooldown", f"You must wait {hours}h {minutes}m before robbing again.", 0xe67e22)
        else:
            await send_embed(ctx, "Rob Cooldown", f"You must wait {minutes}m before robbing again.", 0xe67e22)
        return

    # Check if target has enough cash
    target_cash, _ = get_balances(target.id)
    min_cash = 100  # Minimum cash required to be robbed
    if target_cash < min_cash:
        await send_embed(ctx, "Rob", f"{target.display_name} doesn't have enough cash to rob (minimum: {MONEY_ICON} {min_cash:,}).", 0xe67e22)
        return

    # Enhanced success chance calculation (lowered base chance)
    base_success = 25  # Lowered from 65% to 25%
    luck_bonus = 0
    
    # Apply luck attribute bonus
    try:
        attributes, _ = get_user_attributes(ctx.author.id)
        if isinstance(attributes, dict):
            luck_bonus = attributes.get("luck", 0) * 1  # Reduced from +2% to +1% per luck point for robbing
    except Exception:
        pass
    
    success_chance = min(45, base_success + luck_bonus)  # Cap at 45% instead of 85%
    success = random.random() * 100 < success_chance

    robber_cash, robber_bank = get_balances(ctx.author.id)

    if success:
        # steal random portion of target's cash (20% - 60%)
        pct = random.uniform(0.2, 0.6)
        stolen = max(1, int(target_cash * pct))
        # cap stolen to target_cash
        stolen = min(stolen, target_cash)
        # transfer
        set_cash(target.id, target_cash - stolen)
        add_cash(ctx.author.id, stolen)
        # record cooldowns using integer timestamp (and keep legacy key for compatibility)
        robber_meta["last_rob_timestamp"] = current_timestamp
        robber_meta["last_rob"] = datetime.fromtimestamp(current_timestamp, tz=timezone.utc).isoformat()
        set_user_meta(ctx.author.id, robber_meta)

        target_meta = get_user_meta(target.id)
        target_meta.setdefault("last_robbed", None)
        target_meta["last_robbed_timestamp"] = current_timestamp
        target_meta["last_robbed"] = datetime.fromtimestamp(current_timestamp, tz=timezone.utc).isoformat()
        set_user_meta(target.id, target_meta)

        embed = discord.Embed(title="Robbery Success!", color=0x2ecc71)
        embed.add_field(name="Robber", value=ctx.author.mention, inline=True)
        embed.add_field(name="Victim", value=target.mention, inline=True)
        embed.add_field(name="Amount Stolen", value=format_currency(stolen), inline=False)
        embed.add_field(name="Success Chance", value=f"{success_chance:.1f}%", inline=True)
        await ctx.send(embed=embed)
        
        # Try to rob items (low chance)
        await try_rob_items(ctx, target)
        
    else:
        # failure penalty: robber pays 20% of their total income (cash + bank) or a flat 50 (min), transferred to target as compensation
        total_income = robber_cash + robber_bank
        penalty = max(50, int(total_income * 0.20))
        penalty = min(penalty, total_income)
        if penalty > 0:
            # Take from cash first, then from bank if needed
            if penalty <= robber_cash:
                set_cash(ctx.author.id, robber_cash - penalty)
                add_cash(target.id, penalty)
            else:
                # Take all cash and remaining from bank
                remaining_penalty = penalty - robber_cash
                set_cash(ctx.author.id, 0)
                set_bank(ctx.author.id, robber_bank - remaining_penalty)
                add_cash(target.id, penalty)
        robber_meta["last_rob_timestamp"] = current_timestamp
        robber_meta["last_rob"] = datetime.fromtimestamp(current_timestamp, tz=timezone.utc).isoformat()
        set_user_meta(ctx.author.id, robber_meta)

        embed = discord.Embed(title="Robbery Failed!", color=0xff0000)
        embed.add_field(name="Robber", value=ctx.author.mention, inline=True)
        embed.add_field(name="Victim", value=target.mention, inline=True)
        embed.add_field(name="Penalty Paid", value=format_currency(penalty), inline=False)
        embed.add_field(name="Success Chance", value=f"{success_chance:.1f}%", inline=True)
        embed.add_field(name="Note", value="Penalty is 20% of total income (cash + bank)", inline=False)
        await ctx.send(embed=embed)


# -----------------------
# Favorite Items System
# -----------------------
@bot.command(name="favorite", aliases=["fav"])
async def favorite_item(ctx, *, item_name: str):
    try:
        user_meta = get_user_meta(ctx.author.id)
        inventory = user_meta.get("inventory", [])
        
        # Find the item
        found_item = None
        item_index = -1
        for i, item in enumerate(inventory):
            if isinstance(item, dict) and item.get("name") == item_name:
                found_item = item
                item_index = i
                break
            elif isinstance(item, str) and item == item_name:
                found_item = {"name": item, "type": "unknown", "rarity": "common"}
                item_index = i
                break
        
        if not found_item:
            await send_embed(ctx, "Favorite", "You don't have that item in your inventory.", 0xe74c3c)
            return
        
        # Check if already favorited
        if isinstance(found_item, dict) and found_item.get("favorite", False):
            await send_embed(ctx, "Favorite", f"**{item_name}** is already marked as favorite!", 0xe67e22)
            return
        
        # Count current favorites
        current_favorites = 0
        for item in inventory:
            if isinstance(item, dict) and item.get("favorite", False):
                current_favorites += 1
        
        if current_favorites >= 3:
            await send_embed(ctx, "Favorite Limit", "You can only have 3 favorite items. Unfavorite one first.", 0xe74c3c)
            return
        
        # Mark as favorite
        if isinstance(found_item, dict):
            inventory[item_index]["favorite"] = True
            inventory[item_index]["favorited_at"] = int(time.time())
        else:
            # Convert string item to dict with favorite
            inventory[item_index] = {
                "name": found_item,
                "type": "unknown",
                "rarity": "common",
                "favorite": True,
                "favorited_at": int(time.time())
            }
        
        user_meta["inventory"] = inventory
        set_user_meta(ctx.author.id, user_meta)
        
        await send_embed(ctx, "Item Favorited", f"**{item_name}** is now marked as favorite and cannot be robbed!", 0x2ecc71)
        
    except Exception as e:
        await send_embed(ctx, "Favorite Error", f"An error occurred: {str(e)}", 0xe74c3c)


@bot.command(name="unfavorite", aliases=["unfav"])
async def unfavorite_item(ctx, *, item_name: str):
    try:
        user_meta = get_user_meta(ctx.author.id)
        inventory = user_meta.get("inventory", [])
        
        # Find the item
        found_item = None
        item_index = -1
        for i, item in enumerate(inventory):
            if isinstance(item, dict) and item.get("name") == item_name:
                found_item = item
                item_index = i
                break
            elif isinstance(item, str) and item == item_name:
                found_item = {"name": item, "type": "unknown", "rarity": "common"}
                item_index = i
                break
        
        if not found_item:
            await send_embed(ctx, "Unfavorite", "You don't have that item in your inventory.", 0xe74c3c)
            return
        
        # Check if favorited
        if isinstance(found_item, dict) and not found_item.get("favorite", False):
            await send_embed(ctx, "Unfavorite", f"**{item_name}** is not marked as favorite.", 0xe67e22)
            return
        
        # Remove favorite status
        if isinstance(found_item, dict):
            inventory[item_index]["favorite"] = False
            if "favorited_at" in inventory[item_index]:
                del inventory[item_index]["favorited_at"]
        else:
            # Convert string item to dict without favorite
            inventory[item_index] = {
                "name": found_item,
                "type": "unknown",
                "rarity": "common"
            }
        
        user_meta["inventory"] = inventory
        set_user_meta(ctx.author.id, user_meta)
        
        await send_embed(ctx, "Item Unfavorited", f"**{item_name}** is no longer marked as favorite and can be robbed.", 0xe67e22)
        
    except Exception as e:
        await send_embed(ctx, "Unfavorite Error", f"An error occurred: {str(e)}", 0xe74c3c)


@bot.command(name="favorites", aliases=["favs"])
async def view_favorites(ctx):
    try:
        user_meta = get_user_meta(ctx.author.id)
        inventory = user_meta.get("inventory", [])
        
        favorites = []
        for item in inventory:
            if isinstance(item, dict) and item.get("favorite", False):
                favorites.append(item)
        
        if not favorites:
            await send_embed(ctx, "Favorites", "You don't have any favorite items.", 0xe67e22)
            return
        
        embed = discord.Embed(title="⭐ Your Favorite Items", color=0xf1c40f)
        embed.description = "These items are protected from robbery!"
        
        for i, item in enumerate(favorites[:3], 1):
            name = item.get("name", "Unknown Item")
            rarity = item.get("rarity", "common")
            item_type = item.get("type", "unknown")
            favorited_at = item.get("favorited_at", 0)
            
            rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
            type_emoji = ITEM_TYPE_EMOJI.get(item_type, "📦")
            
            if favorited_at > 0:
                date_str = f"<t:{favorited_at}:R>"
            else:
                date_str = "Unknown"
            
            embed.add_field(
                name=f"{i}. {rarity_emoji} {name}",
                value=f"Type: {type_emoji} {item_type.title()}\nFavorited: {date_str}",
                inline=False
            )
        
        embed.set_footer(text=f"You have {len(favorites)}/3 favorite items")
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Favorites Error", f"An error occurred: {str(e)}", 0xe74c3c)



# Balance command (hybrid)
@bot.hybrid_command(name="balance", description="Check your balance", aliases=["bal"])
async def balance(ctx, member: discord.Member = None):
    await ctx.defer()
    target = member or ctx.author
    cash, bank = get_balances(target.id)
    networth = cash + bank
    embed = discord.Embed(title=f"{target.display_name}'s Balance", color=0x2f3136)
    embed.set_author(name=str(target), icon_url=target.display_avatar.url)
    embed.set_thumbnail(url=target.display_avatar.url)
    embed.add_field(name="Spirit Stones", value=f"{MONEY_ICON} {cash:,}", inline=True)
    embed.add_field(name="Spirit Bank", value=f"{MONEY_ICON} {bank:,}", inline=True)
    embed.add_field(name="Networth", value=f"{MONEY_ICON} {networth:,}", inline=True)
    await ctx.send(embed=embed)


# deposit / withdraw (hybrid)
@bot.hybrid_command(name="deposit", description="Deposit Spirit Stones into your Spirit Bank", aliases=["dep"])
@app_commands.autocomplete(amount=amount_autocomplete)
async def deposit(ctx, amount: str):
    cash, bank = get_balances(ctx.author.id)
    amt = parse_amount_arg(amount, cash)
    if amt is None:
        embed = discord.Embed(title="Invalid Amount", description="Please provide a valid amount (number, `all`, `half`, `1k`, `1m`, `1b`, etc.).", color=0xe74c3c)
        await ctx.send(embed=embed)
        return
    if amt <= 0:
        embed = discord.Embed(title="Nothing To Deposit", description="Your wallet balance is zero.", color=0xe67e22)
        await ctx.send(embed=embed)
        return
    if amt > cash:
        embed = discord.Embed(title="Not Enough Funds", description="You don't have enough Spirit Stones in your wallet.", color=0xe74c3c)
        await ctx.send(embed=embed)
        return

    new_cash = cash - amt
    new_bank = bank + amt
    set_cash(ctx.author.id, new_cash)
    set_bank(ctx.author.id, new_bank)
    print(f"DEBUG: User {ctx.author.id} deposited {amt}, new cash: {new_cash}, new bank: {new_bank}")

    embed = discord.Embed(title="Deposit Successful", color=0x2ecc71)
    embed.description = f"Deposited {MONEY_ICON} {amt:,} to your bank!"
    embed.add_field(name="Wallet", value=f"{MONEY_ICON} {cash:,} → {MONEY_ICON} {new_cash:,}", inline=True)
    embed.add_field(name="Bank", value=f"{MONEY_ICON} {bank:,} → {MONEY_ICON} {new_bank:,}", inline=True)
    await ctx.send(embed=embed)


@bot.hybrid_command(name="withdraw", description="Withdraw Spirit Stones from your Spirit Bank", aliases=["with"])
@app_commands.autocomplete(amount=amount_autocomplete)
async def withdraw(ctx, amount: str):
    cash, bank = get_balances(ctx.author.id)
    amt = parse_amount_arg(amount, bank)
    if amt is None:
        embed = discord.Embed(title="Invalid Amount", description="Please provide a valid amount (number, `all`, `half`, `1k`, `1m`, `1b`, etc.).", color=0xe74c3c)
        await ctx.send(embed=embed)
        return
    if amt <= 0:
        embed = discord.Embed(title="Nothing To Withdraw", description="Your bank balance is zero.", color=0xe67e22)
        await ctx.send(embed=embed)
        return
    if amt > bank:
        embed = discord.Embed(title="Not Enough Bank Funds", description="You don't have enough Spirit Stones in your Spirit Bank.", color=0xe74c3c)
        await ctx.send(embed=embed)
        return

    new_bank = bank - amt
    new_cash = cash + amt
    set_bank(ctx.author.id, new_bank)
    set_cash(ctx.author.id, new_cash)
    print(f"DEBUG: User {ctx.author.id} withdrew {amt}, new cash: {new_cash}, new bank: {new_bank}")

    embed = discord.Embed(title="Withdrawal Successful", color=0x2ecc71)
    embed.description = f"Withdrew {MONEY_ICON} {amt:,} from your bank!"
    embed.add_field(name="Wallet", value=f"{MONEY_ICON} {cash:,} → {MONEY_ICON} {new_cash:,}", inline=True)
    embed.add_field(name="Bank", value=f"{MONEY_ICON} {bank:,} → {MONEY_ICON} {new_bank:,}", inline=True)
    await ctx.send(embed=embed)


# -----------------------
# Money Leaderboard
@bot.hybrid_command(name="leaderboard", description="Show leaderboard by money or sect wealth")
@app_commands.autocomplete(type=leaderboard_type_autocomplete, top=tictactoe_position_autocomplete)
async def leaderboard(ctx, type: str = "money", top: int = 10):
    # Normalize the type parameter
    type = type.lower()

    # Validate the type parameter
    if type not in ["money", "sect"]:
        embed = discord.Embed(
            title="❌ Invalid Leaderboard Type",
            description="Please specify either `money` or `sect` as the leaderboard type.",
            color=0xe74c3c
        )
        await ctx.send(embed=embed)
        return

    # Defer the response since this might take time
    await ctx.defer()

    if type == "money":
        # Money leaderboard
        money_data = load_json(MONEY_FILE)
        
        # Validate money data structure
        if not isinstance(money_data, dict):
            money_data = {}
        
        entries = []
        for uid, meta in money_data.items():
            try:
                # Ensure meta is a dict
                if not isinstance(meta, dict):
                    continue
                
                cash = int(meta.get("cash", 0))
                bank = int(meta.get("bank", 0))
                total = cash + bank
                entries.append((int(uid), total, cash, bank))
            except (ValueError, TypeError):
                continue
        
        entries.sort(key=lambda x: x[1], reverse=True)

        # If no entries, return early
        if not entries:
            embed = discord.Embed(
                title="💰 Wealth Leaderboard", 
                description="No users with balances yet.", 
                color=0xe67e22
            )
            await ctx.send(embed=embed)
            return

        # Limit to requested number of entries
        entries = entries[:top]

        # Create a beautiful embed with rich formatting
        embed = discord.Embed(
            title="🏆 **CULTIVATION WEALTH LEADERBOARD** 🏆", 
            color=0xffd700
        )
        
        # Add subtitle
        embed.description = f"**Top {min(top, len(entries))} Wealthiest Cultivators** • Total Players: {len(entries)}"
        
        # Build beautiful leaderboard entries
        medals = ["🥇", "🥈", "🥉"]
        rank_colors = [0xffd700, 0xc0c0c0, 0xcd7f32]  # Gold, Silver, Bronze
        
        for i, (uid, total, cash, bank) in enumerate(entries, start=1):
            try:
                member = await bot.fetch_user(uid)
                name = member.display_name
                pfp = member.display_avatar.url
            except Exception:
                name = f"User {uid}"
                pfp = None
            
            # Determine rank styling
            if i <= 3:
                medal = medals[i-1]
                rank_style = f"**{medal} #{i}**"
                color = rank_colors[i-1]
            else:
                rank_style = f"**#{i}**"
                color = 0x95a5a6  # Gray for other ranks
            
            # Format the wealth display
            if total >= 1_000_000_000:  # Billions
                wealth_display = f"{MONEY_ICON} {total/1_000_000_000:.1f}B"
            elif total >= 1_000_000:  # Millions
                wealth_display = f"{MONEY_ICON} {total/1_000_000:.1f}M"
            elif total >= 1_000:  # Thousands
                wealth_display = f"{MONEY_ICON} {total/1_000:.1f}K"
            else:
                wealth_display = f"{MONEY_ICON} {total:,}"
            
            # Create the entry field
            entry_value = f"{rank_style} **{name}**\n"
            entry_value += f"💰 **Total Wealth:** {wealth_display}\n"
            entry_value += f"💵 **Cash:** {MONEY_ICON} {cash:,}\n"
            entry_value += f"🏦 **Bank:** {MONEY_ICON} {bank:,}"
            
            # Add special styling for top 3
            if i <= 3:
                entry_value += f"\n✨ **Rank {i} Cultivator** ✨"
            
            embed.add_field(
                name=f"{medal if i <= 3 else '#'}{i} • {name}", 
                value=entry_value, 
                inline=False
            )
            
            # Set thumbnail to first place
            if i == 1 and pfp:
                embed.set_thumbnail(url=pfp)
        
        # Add footer with additional info
        embed.set_footer(text=f"🏆 Wealth Rankings • Use /leaderboard money <number> to see more • Updated in real-time")
        
        # Add timestamp
        embed.timestamp = datetime.now(timezone.utc)

    else:  # type == "sect"
        # Sect leaderboard
        sects = load_json(SECTS_FILE)
        if not isinstance(sects, dict):
            sects = {}

        if not sects:
            embed = discord.Embed(
                title="🏯 Sect Wealth Leaderboard",
                description="No sects have been established yet.",
                color=0x9b59b6
            )
            await ctx.send(embed=embed)
            return

        money_data = load_json(MONEY_FILE)
        sect_wealth = {}
        sect_members = {}

        for sect_name, info in sects.items():
            total = 0
            members_list = []
            for member_id in info.get("members", []):
                member_cash = money_data.get(str(member_id), {}).get("cash", 0)
                member_bank = money_data.get(str(member_id), {}).get("bank", 0)
                total += member_cash + member_bank

                # Get member info for top sects
                try:
                    member = await bot.fetch_user(member_id)
                    members_list.append(member.display_name)
                except:
                    members_list.append(f"<@{member_id}>")

            sect_wealth[sect_name] = total
            sect_members[sect_name] = members_list

        # Calculate combined score using both wealth and member count
        sect_scores = {}
        for sect_name, wealth in sect_wealth.items():
            member_count = len(sect_members[sect_name])
            # Combined score: 70% wealth + 30% member count (normalized)
            # Normalize member count to wealth scale (assuming 10 members = 1M wealth)
            member_score = member_count * 100000  # 100k per member
            combined_score = (wealth * 0.7) + (member_score * 0.3)
            sect_scores[sect_name] = {
                'wealth': wealth,
                'member_count': member_count,
                'combined_score': combined_score
            }
        
        # Sort by combined score
        sorted_sects = sorted(sect_scores.items(), key=lambda x: x[1]['combined_score'], reverse=True)
        sorted_sects = sorted_sects[:top]  # Limit to requested number

        # Create a beautiful sect leaderboard embed
        embed = discord.Embed(
            title="🏯 ═══ **SECT DOMINANCE RANKINGS** ═══ 🏯", 
            color=0x9b59b6
        )
        
        # Add subtitle with more detailed information
        total_wealth = sum(sect_data['wealth'] for _, sect_data in sorted_sects)
        avg_wealth = total_wealth // len(sorted_sects) if sorted_sects else 0
        # Calculate totals for the new scoring system
        total_combined_score = sum(sect_data['combined_score'] for _, sect_data in sorted_sects)
        avg_combined_score = total_combined_score // len(sorted_sects) if sorted_sects else 0
        
        embed.description = (
            f"**⚡ Top {min(top, len(sorted_sects))} Most Powerful Sects ⚡**\n"
            f"🌟 **Total Sects:** {len(sorted_sects)} • **Combined Wealth:** {MONEY_ICON} {total_wealth:,}\n"
            f"📊 **Scoring System:** 70% Wealth + 30% Member Count • **Total Score:** {total_combined_score:,.0f}\n"
            f"📈 **Average Score:** {avg_combined_score:,.0f}\n"
            f"{'═' * 40}"
        )
        
        # Add special top 3 highlight section if we have sects
        if len(sorted_sects) >= 3:
            top_3_names = [name for name, _ in sorted_sects[:3]]
            embed.add_field(
                name="🏆 **HALL OF FAME - TOP 3 ELITE SECTS** 🏆",
                value=(
                    f"🥇 **{top_3_names[0]}** - *The Supreme Sect*\n"
                    f"🥈 **{top_3_names[1]}** - *The Ascendant Sect*\n"
                    f"🥉 **{top_3_names[2]}** - *The Rising Sect*\n"
                    f"*These sects receive special cultivation bonuses!*"
                ),
                inline=False
            )
            embed.add_field(name="━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━", value="", inline=False)
        
        # Build beautiful sect entries
        medals = ["🥇", "🥈", "🥉"]
        rank_colors = [0xffd700, 0xc0c0c0, 0xcd7f32]  # Gold, Silver, Bronze
        
        for i, (sname, sect_data) in enumerate(sorted_sects, start=1):
            wealth = sect_data['wealth']
            member_count = sect_data['member_count']
            combined_score = sect_data['combined_score']
            leader_id = sects[sname].get("leader")
            try:
                leader_user = await bot.fetch_user(leader_id)
                leader_name = leader_user.display_name
                leader_avatar = leader_user.display_avatar.url
            except Exception:
                leader_name = f"<@{leader_id}>"
                leader_avatar = None
            
            sect_path = sects[sname].get("path", "righteous").title()
            
            # Determine rank styling
            if i <= 3:
                medal = medals[i-1]
                rank_style = f"**{medal} #{i}**"
                color = rank_colors[i-1]
            else:
                rank_style = f"**#{i}**"
                color = 0x95a5a6  # Gray for other ranks
            
            # Format the wealth display
            if wealth >= 1_000_000_000:  # Billions
                wealth_display = f"{MONEY_ICON} {wealth/1_000_000_000:.1f}B"
            elif wealth >= 1_000_000:  # Millions
                wealth_display = f"{MONEY_ICON} {wealth/1_000_000:.1f}M"
            elif wealth >= 1_000:  # Thousands
                wealth_display = f"{MONEY_ICON} {wealth/1_000:.1f}K"
            else:
                wealth_display = f"{MONEY_ICON} {wealth:,}"
            
            # Get sect bank balance and bonuses for additional info
            sect_bank = sects[sname].get("bank", 0)
            
            # Get sect bonuses for top 3
            sect_bonuses = ""
            if i <= 3:
                # Get the actual bonus data for top sects
                try:
                    bonuses = get_sect_boosts(sname)
                    income_boost = bonuses.get('income_boost', 0)
                    xp_boost = bonuses.get('xp_boost', 0)
                    if income_boost > 0 or xp_boost > 0:
                        sect_bonuses = f"║ 🎯 **Bonuses:** Income +{income_boost}% • XP +{xp_boost}%\n"
                except:
                    pass
            
            # Create enhanced entry field with better visual structure
            if i <= 3:
                # Special formatting for top 3 sects
                entry_value = f"╔══ {rank_style} **{sname}** ══╗\n"
                entry_value += f"║ 💰 **Total Wealth:** {wealth_display}\n"
                entry_value += f"║ 🏦 **Sect Bank:** {MONEY_ICON} {sect_bank:,}\n"
                entry_value += sect_bonuses  # Add bonuses if available
                entry_value += f"║ 👑 **Leader:** {leader_name}\n"
                entry_value += f"║ 🛤️ **Path:** {sect_path} • 👥 **Members:** {member_count}\n"
                entry_value += f"╚══ ✨ **ELITE SECT** ✨ ══╝"
            else:
                # Standard formatting for other sects
                entry_value = f"▬▬ {rank_style} **{sname}** ▬▬\n"
                entry_value += f"💰 **Wealth:** {wealth_display} • 🏦 **Bank:** {MONEY_ICON} {sect_bank:,}\n"
                entry_value += f"👑 **Leader:** {leader_name} • 🛤️ **Path:** {sect_path}\n"
                entry_value += f"👥 **Members:** {member_count}"
            
            # Enhanced field name with better styling
            if i <= 3:
                field_name = f"{medal} **RANK {i}** • {sname}"
            else:
                field_name = f"🔹 **#{i}** • {sname}"
            
            embed.add_field(
                name=field_name, 
                value=entry_value, 
                inline=False
            )
            
            # Set thumbnail to first place
            if i == 1 and leader_avatar:
                embed.set_thumbnail(url=leader_avatar)
        
        # Add enhanced footer with more detailed info
        if sorted_sects:
            top_sect_name = sorted_sects[0][0]
            top_sect_data = sorted_sects[0][1]
            top_sect_wealth = top_sect_data['wealth']
            top_sect_score = top_sect_data['combined_score']
            footer_text = (
                f"🏆 Current Champion: {top_sect_name} (Score: {top_sect_score:,.0f}) • "
                f"📈 Use /leaderboard sect <number> to see more • "
                f"⏰ Live Rankings • 🎯 Scoring: 70% Wealth + 30% Members"
            )
        else:
            footer_text = "🏯 No sects found • Create one with /sect_create!"
        
        embed.set_footer(text=footer_text)
        
        # Add timestamp
        embed.timestamp = datetime.now(timezone.utc)
        
        # Add author field for extra visual appeal
        embed.set_author(
            name="Cultivation Realm Sect Rankings", 
            icon_url="https://cdn.discordapp.com/emojis/1234567890123456789.png"  # You can replace with a custom icon
        )

    await ctx.send(embed=embed)


# -----------------------
# End of Part 3/6
# -----------------------
# Sect Commands Continued
# -----------------------

@bot.hybrid_command(name="sect_create", description="Create a new sect (costs 1,000,000 Spirit Stones)")
@app_commands.autocomplete(privacy=privacy_autocomplete, path=sect_path_autocomplete)
async def sect_create(ctx, sect_name: str, privacy: str = "public", *, description: str = "", path: str = "righteous"):
    # Check if name is valid
    if len(sect_name) < 3 or len(sect_name) > 20:
        await send_embed(ctx, "Sect", "Sect name must be between 3 and 20 characters.", 0xe74c3c)
        return

    # Check if user already in a sect
    user_meta = get_user_meta(ctx.author.id)
    if user_meta.get("sect"):
        await send_embed(ctx, "Sect", "You are already in a sect. Leave your current sect first.", 0xe74c3c)
        return

    # Check if sect already exists
    data = load_json(SECTS_FILE)
    if sect_name in data:
        await send_embed(ctx, "Sect", "A sect with that name already exists.", 0xe74c3c)
        return

    # Check if user has enough money
    creation_cost = 10_000_000
    cash, bank = get_balances(ctx.author.id)
    if cash < creation_cost:
        await send_embed(ctx, "Sect", f"You need {MONEY_ICON} {creation_cost} to create a sect. You only have {MONEY_ICON} {cash}.", 0xe74c3c)
        return

    # Deduct cost and create sect
    add_cash(ctx.author.id, -creation_cost)

    # Create the sect
    data[sect_name] = {
        "leader": ctx.author.id,
        "members": [ctx.author.id],
        "invites": [],
        "created_at": datetime.now(timezone.utc).isoformat(),
        "privacy": "private" if privacy.lower() == "private" else "public",
        "description": description,
        "path": (path or "righteous").lower()
    }
    save_json(SECTS_FILE, data)

    # Update user meta
    user_meta["sect"] = sect_name
    set_user_meta(ctx.author.id, user_meta)

    # Send confirmation
    embed = discord.Embed(title="🏯 Sect Created", color=0x9b59b6)
    embed.description = f"You have successfully created the sect **{sect_name}**!"
    embed.add_field(name="Cost", value=f"{MONEY_ICON} {creation_cost:,}")
    embed.add_field(name="Leader", value=ctx.author.mention)
    embed.add_field(name="Privacy", value=data[sect_name]["privacy"], inline=True)
    embed.add_field(name="Path", value=data[sect_name]["path"].title(), inline=True)
    if description:
        embed.add_field(name="Description", value=description[:256], inline=False)
    embed.set_footer(text="Use /sect_invite to invite members to your sect • Public sects can be joined directly by anyone")
    await ctx.send(embed=embed)


# Sect edit: leader can change name, description, and path
@bot.hybrid_command(name="sect_edit", description="Sect leader: edit sect name, description, path, or privacy")
@app_commands.autocomplete(path=sect_path_autocomplete, privacy=privacy_autocomplete)
async def sect_edit(ctx, *, new_name: str = None, description: str = None, path: str = None, privacy: str = None):
    data = load_json(SECTS_FILE)
    user_meta = get_user_meta(ctx.author.id)
    sect_name = user_meta.get("sect")
    if not sect_name or sect_name not in data:
        return await send_embed(ctx, "Sect", "You are not in a valid sect.", 0xe74c3c)

    # Only leader can edit
    if data[sect_name].get("leader") != ctx.author.id:
        return await send_embed(ctx, "Sect", "Only the sect leader can edit sect details.", 0xe74c3c)

    # Validate path
    if path is not None:
        path_norm = path.lower()
        if path_norm not in ("righteous", "demonic"):
            return await send_embed(ctx, "Sect", "Path must be 'righteous' or 'demonic'.", 0xe74c3c)
        data[sect_name]["path"] = path_norm

    # Update description
    if description is not None:
        data[sect_name]["description"] = str(description)[:512]

    # Update privacy
    if privacy is not None:
        privacy_norm = privacy.lower()
        if privacy_norm not in ("public", "private"):
            return await send_embed(ctx, "Sect", "Privacy must be 'public' or 'private'.", 0xe74c3c)
        data[sect_name]["privacy"] = privacy_norm

    # Rename sect (ensure unique and valid)
    rename_info = ""
    if new_name is not None:
        if len(new_name) < 3 or len(new_name) > 20:
            return await send_embed(ctx, "Sect", "New name must be 3-20 characters.", 0xe74c3c)
        if new_name != sect_name and new_name in data:
            return await send_embed(ctx, "Sect", "Another sect already has that name.", 0xe74c3c)
        # Perform rename by moving key
        sect_obj = data.pop(sect_name)
        data[new_name] = sect_obj
        # Update members' meta
        for mid in sect_obj.get("members", []):
            m_meta = get_user_meta(mid)
            m_meta["sect"] = new_name
            set_user_meta(mid, m_meta)
        rename_info = f"\nRenamed from **{sect_name}** to **{new_name}**."
        sect_name = new_name

    save_json(SECTS_FILE, data)

    # Response embed
    sect = data[sect_name]
    embed = discord.Embed(title="✏️ Sect Updated", color=0x2ecc71)
    embed.add_field(name="Name", value=sect_name, inline=True)
    if description is not None:
        embed.add_field(name="Description", value=sect.get("description", "-"), inline=False)
    if path is not None:
        embed.add_field(name="Path", value=sect.get("path", "righteous").title(), inline=True)
    if privacy is not None:
        embed.add_field(name="Privacy", value=sect.get("privacy", "public").title(), inline=True)
    if rename_info:
        embed.add_field(name="Rename", value=rename_info, inline=False)
    await ctx.send(embed=embed)

@bot.hybrid_command(name="create_sect", description="Create a new cultivation sect (costs 1,000,000 Spirit Stones)")
@app_commands.autocomplete(privacy=privacy_autocomplete, path=sect_path_autocomplete)
async def create_sect(ctx, sect_name: str, sect_description: str = "", privacy: str = "public", path: str = "righteous"):
    # Defer the response since this might take time
    await ctx.defer()

    try:
        # Check if name is valid
        if len(sect_name) < 3 or len(sect_name) > 20:
            embed = discord.Embed(title="❌ Sect Creation Failed", color=0xe74c3c)
            embed.description = "Sect name must be between 3 and 20 characters."
            embed.set_thumbnail(url=ctx.author.display_avatar.url)
            await ctx.send(embed=embed)
            return

        # Check if user already in a sect
        user_meta = get_user_meta(ctx.author.id)
        if user_meta.get("sect"):
            embed = discord.Embed(title="❌ Sect Creation Failed", color=0xe74c3c)
            embed.description = "You are already in a sect. Leave your current sect first."
            embed.set_footer(text="Use /sect_leave to leave your current sect")
            embed.set_thumbnail(url=ctx.author.display_avatar.url)
            await ctx.send(embed=embed)
            return

        # Check if sect already exists
        data = load_json(SECTS_FILE)
        if data is None or not isinstance(data, dict):
            data = {}  # Ensure data is a dictionary
            save_json(SECTS_FILE, data)  # Initialize the file if it doesn't exist

        if sect_name in data:
            embed = discord.Embed(title="❌ Sect Creation Failed", color=0xe74c3c)
            embed.description = f"A sect named **{sect_name}** already exists."
            embed.set_thumbnail(url=ctx.author.display_avatar.url)
            await ctx.send(embed=embed)
            return

        # Check if user has enough money
        creation_cost = 10_000_000
        cash, bank = get_balances(ctx.author.id)
        if cash < creation_cost:
            embed = discord.Embed(title="❌ Insufficient Funds", color=0xe74c3c)
            embed.description = f"Creating a sect requires {MONEY_ICON} {creation_cost:,}."
            embed.add_field(name="Your Cash", value=f"{MONEY_ICON} {cash:,}")
            embed.add_field(name="Needed", value=f"{MONEY_ICON} {creation_cost - cash:,} more")
            embed.set_thumbnail(url=ctx.author.display_avatar.url)
            await ctx.send(embed=embed)
            return

        # Deduct cost and create sect
        add_cash(ctx.author.id, -creation_cost)

        # Create the sect with optional description
        now = datetime.now(timezone.utc)
        sect_data = {
            "leader": ctx.author.id,
            "members": [ctx.author.id],
            "invites": [],
            "created_at": now.isoformat(),
            "privacy": "private" if privacy.lower() == "private" else "public",
            "path": (path or "righteous").lower(),
            "positions": {str(ctx.author.id): "sect leader"}  # Initialize leader position
        }

        # Add description if provided
        if sect_description:
            sect_data["description"] = sect_description

        data[sect_name] = sect_data
        save_json(SECTS_FILE, data)

        # Update user meta
        user_meta["sect"] = sect_name
        set_user_meta(ctx.author.id, user_meta)

        # Send confirmation with enhanced visuals
        embed = discord.Embed(title="🏯 New Sect Established", color=0x9b59b6)
        embed.description = f"The **{sect_name}** sect has been founded under your leadership!"

        if sect_description:
            embed.add_field(name="Sect Motto", value=sect_description, inline=False)

        embed.add_field(name="Founder", value=ctx.author.mention, inline=True)
        embed.add_field(name="Cost", value=f"{MONEY_ICON} {creation_cost:,}", inline=True)
        embed.add_field(name="Privacy", value=sect_data["privacy"], inline=True)
        embed.add_field(name="Path", value=sect_data["path"].title(), inline=True)

        # Use proper Discord timestamp format
        timestamp = int(now.timestamp())
        embed.add_field(
            name="Founded On",
            value=f"<t:{timestamp}:F> (<t:{timestamp}:R>)",
            inline=True
        )

        # Add user avatar as thumbnail
        embed.set_thumbnail(url=ctx.author.display_avatar.url)

        embed.set_footer(text="Use /sect_invite to recruit new disciples to your sect • Public sects can be joined directly by anyone")
        await ctx.send(embed=embed)
    except Exception as e:
        # Error handling
        embed = discord.Embed(title="❌ Sect Creation Error", color=0xe74c3c)
        embed.description = f"An error occurred while creating your sect: {str(e)}"
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
        await ctx.send(embed=embed)


@bot.hybrid_command(name="sect_invite", description="Invite a member to join your sect (Sect Leader and Elders only)")
async def sect_invite(ctx, member: discord.Member):
    data = load_json(SECTS_FILE)
    user_meta = get_user_meta(ctx.author.id)
    sect_name = user_meta.get("sect")

    if not sect_name or sect_name not in data:
        await send_embed(ctx, "Sect", "You are not in a sect.", 0xe74c3c)
        return

    # Check if user is sect leader or elder
    user_rank = user_meta.get("sect_rank", "outer disciple")
    is_elder = user_rank in ["outer elder", "inner elder", "core elder"]
    
    if ctx.author.id != data[sect_name]["leader"] and not is_elder:
        await send_embed(ctx, "Access Denied", "Only the sect leader and elders can invite members.", 0xe74c3c)
        return

    # Add pending invitation and send buttons
    data[sect_name].setdefault("invites", []).append(member.id)
    save_json(SECTS_FILE, data)

    class InviteView(discord.ui.View):
        def __init__(self, inviter_id: int, sect: str):
            super().__init__(timeout=300)
            self.inviter_id = inviter_id
            self.sect = sect

        @discord.ui.button(label="Accept", style=discord.ButtonStyle.success)
        async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
            if interaction.user.id != member.id:
                return await interaction.response.send_message("This invite is not for you.", ephemeral=True)
            data = load_json(SECTS_FILE)
            if self.sect not in data:
                return await interaction.response.edit_message(content="Sect no longer exists.", view=None)
            if interaction.user.id not in data[self.sect].get("invites", []):
                return await interaction.response.edit_message(content="Invite expired or already used.", view=None)
            data[self.sect]["invites"].remove(interaction.user.id)
            data[self.sect].setdefault("members", []).append(interaction.user.id)
            save_json(SECTS_FILE, data)
            meta = get_user_meta(interaction.user.id)
            meta["sect"] = self.sect
            meta.setdefault("sect_rank", SECT_RANKS[0])
            set_user_meta(interaction.user.id, meta)
            await interaction.response.edit_message(content=f"{interaction.user.mention} joined {self.sect}.", view=None)

        @discord.ui.button(label="Reject", style=discord.ButtonStyle.danger)
        async def reject(self, interaction: discord.Interaction, button: discord.ui.Button):
            if interaction.user.id != member.id:
                return await interaction.response.send_message("This invite is not for you.", ephemeral=True)
            data = load_json(SECTS_FILE)
            if self.sect in data and interaction.user.id in data[self.sect].get("invites", []):
                data[self.sect]["invites"].remove(interaction.user.id)
                save_json(SECTS_FILE, data)
            await interaction.response.edit_message(content="Invite rejected.", view=None)

    view = InviteView(ctx.author.id, sect_name)
    embed = discord.Embed(title="Sect Invite", description=f"{ctx.author.mention} invited {member.mention} to join {sect_name}.", color=0x3498db)
    await ctx.send(embed=embed, view=view)


@bot.hybrid_command(name="sect_list", description="List all public sects available to join")
async def sect_list(ctx):
    """List all public sects that users can join"""
    # Show info about sect privacy first
    info_embed = discord.Embed(title="🏯 Sect Privacy Information", color=0x3498db)
    info_embed.description = "**Public Sects:** Anyone can join directly without an invitation.\n**Private Sects:** Require an invitation from a member to join."
    info_embed.add_field(name="💡 Tip", value="Use `/sect_join <sect_name>` to join any public sect, or ask for an invite to join a private sect.", inline=False)
    
    await ctx.send(embed=info_embed)
    
    data = load_json(SECTS_FILE)
    
    # Filter for public sects only
    public_sects = []
    for sect_name, sect_data in data.items():
        if sect_data.get("privacy", "public").lower() == "public":
            public_sects.append((sect_name, sect_data))
    
    if not public_sects:
        embed = discord.Embed(title="🏯 Public Sects", color=0x9b59b6)
        embed.description = "No public sects are currently available to join."
        embed.set_footer(text="Create your own sect with /sect_create")
        await ctx.send(embed=embed)
        return
    
    # Sort by member count (descending)
    public_sects.sort(key=lambda x: len(x[1].get("members", [])), reverse=True)
    
    embed = discord.Embed(title="🏯 Public Sects Available", color=0x9b59b6)
    embed.description = f"Found **{len(public_sects)}** public sects you can join:"
    
    for sect_name, sect_data in public_sects:
        leader_id = sect_data.get("leader")
        leader = ctx.guild.get_member(leader_id) if ctx.guild else None
        leader_name = leader.display_name if leader else f"User {leader_id}"
        
        member_count = len(sect_data.get("members", []))
        path = sect_data.get("path", "righteous").title()
        description = sect_data.get("description", "No description")
        
        # Truncate description if too long
        if len(description) > 100:
            description = description[:97] + "..."
        
        sect_info = f"👑 **Leader:** {leader_name}\n"
        sect_info += f"👥 **Members:** {member_count}\n"
        sect_info += f"⚖️ **Path:** {path}\n"
        sect_info += f"📝 **Description:** {description}"
        
        embed.add_field(
            name=f"🏯 {sect_name}",
            value=sect_info,
            inline=False
        )
    
    embed.set_footer(text="Use /sect_join <sect_name> to join a public sect • Use /sect_list to refresh this list")
    await ctx.send(embed=embed)


@bot.hybrid_command(name="sect_join", description="Join a sect (public sects can be joined directly, private sects require invites)")
@app_commands.autocomplete(sect_name=sect_name_autocomplete)
async def sect_join(ctx, sect_name: str):
    data = load_json(SECTS_FILE)
    if sect_name not in data:
        await send_embed(ctx, "Sect Join", "That sect does not exist.", 0xe74c3c)
        return

    sect = data[sect_name]
    
    # Check if user is already in any sect first
    user_meta = get_user_meta(ctx.author.id)
    current_sect = user_meta.get("sect")
    
    if current_sect:
        # Check if the current sect actually exists and user is still a member
        if current_sect in data and ctx.author.id in data[current_sect].get("members", []):
            await send_embed(ctx, "Sect Join", f"You are already in the sect **{current_sect}**. Leave your current sect first with `/sect_leave`.", 0xe74c3c)
            return
        else:
            # User has invalid sect data, clean it up
            user_meta["sect"] = None
            user_meta["sect_rank"] = None
            set_user_meta(ctx.author.id, user_meta)
            current_sect = None
    
    # Check if already a member of the target sect
    if ctx.author.id in sect.get("members", []):
        await send_embed(ctx, "Sect Join", "You are already in this sect.", 0xe74c3c)
        return

    # Check if sect is private and user has invite
    if sect.get("privacy", "private").lower() == "private":
        if ctx.author.id not in sect.get("invites", []):
            await send_embed(ctx, "Sect Join", "This is a private sect and you do not have an invitation to join.", 0xe74c3c)
        return
    # For public sects, no invite needed

    # Remove from invites if they had one (for private sects)
    if ctx.author.id in sect.get("invites", []):
        sect["invites"].remove(ctx.author.id)
    
    # Add to members
    sect["members"].append(ctx.author.id)
    
    # Initialize positions field if it doesn't exist
    if "positions" not in sect:
        sect["positions"] = {}
    
    # Add member to positions as outer disciple
    sect["positions"][str(ctx.author.id)] = "outer disciple"
    
    save_json(SECTS_FILE, data)

    # Update user meta
    meta = get_user_meta(ctx.author.id)
    meta["sect"] = sect_name
    meta["sect_rank"] = SECT_RANKS[0]  # Start as lowest rank
    set_user_meta(ctx.author.id, meta)

    # Create success embed
    embed = discord.Embed(title="🎉 Sect Joined!", color=0x2ecc71)
    embed.description = f"You have successfully joined the sect **{sect_name}**!"
    
    # Show sect details
    leader_id = sect.get("leader")
    leader = ctx.guild.get_member(leader_id) if ctx.guild else None
    leader_name = leader.display_name if leader else f"User {leader_id}"
    
    embed.add_field(name="👑 Leader", value=leader_name, inline=True)
    embed.add_field(name="⚖️ Path", value=sect.get("path", "righteous").title(), inline=True)
    embed.add_field(name="👥 Members", value=len(sect.get("members", [])), inline=True)
    
    if sect.get("description"):
        embed.add_field(name="📝 Description", value=sect["description"][:256], inline=False)
    
    embed.set_footer(text="Use /sect_info to view sect details")
    await ctx.send(embed=embed)


@bot.hybrid_command(name="sect_leave", description="Leave your sect")
async def sect_leave(ctx):
    meta = get_user_meta(ctx.author.id)
    sect_name = meta.get("sect")

    if not sect_name:
        await ctx.send("❌ You are not in a sect.")
        return

    data = load_json(SECTS_FILE)
    if sect_name not in data:
        # Sect doesn't exist, clean up user data
        meta["sect"] = None
        meta["sect_rank"] = None
        set_user_meta(ctx.author.id, meta)
        await ctx.send("❌ This sect no longer exists. Your sect data has been cleaned up.")
        return

    # Check if user is actually a member
    if ctx.author.id not in data[sect_name].get("members", []):
        # User not in member list, clean up user data
        meta["sect"] = None
        meta["sect_rank"] = None
        set_user_meta(ctx.author.id, meta)
        await ctx.send("❌ You are not a member of this sect. Your sect data has been cleaned up.")
        return

    if ctx.author.id == data[sect_name]["leader"]:
        await ctx.send("❌ You are the leader. Use `/sect_disband` to delete the sect.")
        return

    data[sect_name]["members"].remove(ctx.author.id)
    save_json(SECTS_FILE, data)

    meta["sect"] = None
    meta["sect_rank"] = None
    set_user_meta(ctx.author.id, meta)

    await ctx.send(f"✅ You have left the sect **{sect_name}**.")


# Removed cleanup_sect_data command - no longer needed


# Removed fix_sect_data command - no longer needed


@bot.hybrid_command(name="sect_disband", description="Disband your sect (Leader only)")
async def sect_disband(ctx):
    meta = get_user_meta(ctx.author.id)
    sect_name = meta.get("sect")

    if not sect_name:
        await ctx.send("❌ You are not in a sect.")
        return

    data = load_json(SECTS_FILE)
    if sect_name not in data:
        await ctx.send("❌ This sect no longer exists.")
        return

    if ctx.author.id != data[sect_name]["leader"]:
        await ctx.send("❌ Only the leader can disband the sect.")
        return

    # Remove sect from all members
    for member_id in data[sect_name]["members"]:
        m_meta = get_user_meta(member_id)
        m_meta["sect"] = None
        m_meta["sect_rank"] = None
        set_user_meta(member_id, m_meta)

    del data[sect_name]
    save_json(SECTS_FILE, data)

    await ctx.send(f"⚠️ The sect **{sect_name}** has been disbanded.")


@bot.hybrid_command(name="sect_info", description="View information about a sect")
@app_commands.autocomplete(sect_name=sect_name_autocomplete)
async def sect_info(ctx, sect_name: str = None):
    try:
        # Defer response to prevent timeout (only for slash commands)
        if hasattr(ctx, 'interaction') and ctx.interaction:
            await ctx.defer()
        
        data = load_json(SECTS_FILE)

        if not sect_name:
            meta = get_user_meta(ctx.author.id)
            sect_name = meta.get("sect")
            if not sect_name:
                embed = discord.Embed(title="❌ Sect Info Error", color=0xe74c3c)
                embed.description = "You are not in a sect and did not specify one."
                await ctx.send(embed=embed)
                return

        if sect_name not in data:
            embed = discord.Embed(title="❌ Sect Info Error", color=0xe74c3c)
            embed.description = "That sect does not exist."
            await ctx.send(embed=embed)
            return
        


        sect = data[sect_name]
        leader = ctx.guild.get_member(sect.get("leader")) if ctx.guild else None
        members_ids = sect.get("members", [])
        members = [ctx.guild.get_member(m) if ctx.guild else None for m in members_ids]

        # Calculate total wealth of sect
        total_wealth = 0
        for member_id in sect["members"]:
            try:
                cash, bank = get_balances(member_id)
                total_wealth += cash + bank
            except:
                # Fallback to old system if new system fails
                try:
                    user_data = load_json(DATA_FILE).get(str(member_id), {})
                    total_wealth += user_data.get("cash", 0) + user_data.get("bank", 0)
                except:
                    pass  # Skip this user if both systems fail

        # Create enhanced embed with sect bank and member progress
        bank_amount = int(sect.get("bank", 0))
        
        # Build description with bank info and sect description if available
        description_parts = [f"Bank: {MONEY_ICON} {bank_amount:,}"]
        if "description" in sect:
            description_parts.append(f"*\"{sect['description']}\"*")
        
        embed = discord.Embed(title=f"🏯 Sect: {sect_name}", description="\n".join(description_parts), color=0x9b59b6)

        # Add creation date
        if "created_at" in sect:
            try:
                created_dt = datetime.fromisoformat(sect["created_at"])
                embed.add_field(
                    name="Founded",
                    value=f"<t:{int(created_dt.timestamp())}:R> at <t:{int(created_dt.timestamp())}:t>",
                    inline=True
                )
            except:
                pass

        # Add leader with icon
        embed.add_field(name="👑 Leader", value=leader.mention if leader else "Unknown", inline=True)

        # Add wealth
        embed.add_field(
            name="💰 Total Wealth",
            value=f"{MONEY_ICON} {total_wealth:,}",
            inline=True
        )
        
        # Add sect rank and top 3 status
        sect_rank = get_sect_rank(sect_name)
        if sect_rank <= 3:
            rank_info = TOP_SECT_BOOSTERS[sect_rank]
            embed.add_field(
                name=f"🏆 {rank_info['name']} - Rank #{sect_rank}",
                value=f"**Income Boost:** +{rank_info['income_boost']}%\n"
                      f"**XP Boost:** +{rank_info['xp_boost']}%\n"
                      f"*Automatic bonus for top 3 sects*",
                inline=True
            )
        else:
            embed.add_field(
                name="📊 Current Rank",
                value=f"Rank #{sect_rank}\n*Work together to reach top 3 for automatic bonuses!*",
                inline=True
            )

        # Add path (Righteous/Demonic)
        sect_path = sect.get("path", "righteous").title()
        embed.add_field(name="⚖️ Path", value=sect_path, inline=True)
        
        # Add privacy status
        privacy_status = sect.get("privacy", "public").title()
        embed.add_field(name="🔒 Privacy", value=privacy_status, inline=True)
        
        # Add current sect upgrades and total boosts
        current_upgrades = get_sect_upgrades(sect_name)
        sect_boosts = get_sect_boosts(sect_name)
        
        if current_upgrades:
            upgrades_text = ""
            for upgrade_id, level in current_upgrades.items():
                if upgrade_id in SECT_SHOP_UPGRADES:
                    upgrade_data = SECT_SHOP_UPGRADES[upgrade_id]
                    emoji = upgrade_data["emoji"]
                    effect = upgrade_data["effect_per_level"] * level
                    upgrades_text += f"{emoji} {upgrade_data['name']} (Lv.{level})\n"
            
            embed.add_field(
                name="🏗️ Active Upgrades",
                value=upgrades_text.strip(),
                inline=True
            )
        
        # Show total combined bonuses
        embed.add_field(
            name="🎯 Total Bonuses",
            value=f"**Income:** +{sect_boosts['income_boost']}%\n"
                  f"**XP:** +{sect_boosts['xp_boost']}%\n"
                  f"**Expedition:** +{sect_boosts['expedition_boost']}%",
            inline=True
        )
        # Show rank limits summary
        limits_lines = []
        for rank, lim in RANK_LIMITS.items():
            if lim != float('inf'):
                limits_lines.append(f"{rank.title()}: {lim}")
        if limits_lines:
            embed.add_field(name="📏 Position Limits", value="\n".join(limits_lines), inline=True)

        # Add roster with position and standing (level/realm)
        roster_lines = []
        for member_id in members_ids:  # show all members
            # Resolve display and mention
            if ctx.guild:
                member_obj = ctx.guild.get_member(member_id)
                display = member_obj.mention if member_obj else f"<@{member_id}>"
                display_name = member_obj.display_name if member_obj else str(member_id)
            else:
                display = f"<@{member_id}>"
                display_name = str(member_id)

            m_meta = get_user_meta(member_id)
            
            # Determine rank with proper priority
            if sect.get("leader") == member_id:
                rank = "Sect Leader"
            else:
                # Check sect positions first, then user meta, then default
                sect_positions = sect.get("positions", {})
                member_position = sect_positions.get(str(member_id))
                
                if member_position:
                    rank = member_position.title()
                elif m_meta.get("sect_rank"):
                    rank = m_meta.get("sect_rank").title()
                else:
                    rank = "Outer Disciple"  # Default fallback
            
            user_xp = int(m_meta.get("sect_xp", 0))
            lvl, _, _, _ = get_member_level_and_progress(user_xp)
            # Get user title instead of realm
            user_title = get_decorative_title(lvl, sect_name)
            roster_lines.append(f"{display} — {rank} • Lvl {lvl} • {user_title}")

        roster_value = "\n".join(roster_lines) if roster_lines else "None"
        embed.add_field(name=f"📜 Roster ({len(members_ids)})", value=roster_value, inline=False)

        # Add leader's avatar as thumbnail if available
        if leader and leader.avatar:
            embed.set_thumbnail(url=leader.avatar.url)

        if hasattr(ctx, 'interaction') and ctx.interaction and not ctx.interaction.response.is_done():
            await ctx.followup.send(embed=embed)
        else:
            await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Error in sect_info command: {e}")
        error_embed = discord.Embed(title="❌ Error", description=f"An error occurred while fetching sect information: {str(e)}", color=0xe74c3c)
        if hasattr(ctx, 'interaction') and ctx.interaction and not ctx.interaction.response.is_done():
            try:
                await ctx.followup.send(embed=error_embed)
            except:
                await ctx.send(embed=error_embed)
        else:
            await ctx.send(embed=error_embed)


# The leaderboards command is no longer needed since we've merged both into the main leaderboard command

# -----------------------
# Sect Commands Continued
# -----------------------


# -----------------------
# Leaderboard Commands
# -----------------------

# Note: The sect_leaderboard command has been merged into the main leaderboard command
# with the 'type' parameter to select between money and sect leaderboards
# -----------------------
# Part 6/6 - Final Commands and Bot Start
# -----------------------

# -----------------------
# Admin Money Commands
# -----------------------
@bot.tree.command(name="money_set", description="Set a user's balance (Admin only)")
@app_commands.describe(member="The user to set money for", amount="Amount (can be negative for debt)", account="Account type")
@app_commands.checks.has_permissions(administrator=True)
@app_commands.autocomplete(amount=amount_autocomplete, account=account_type_autocomplete)
async def money_set(interaction: discord.Interaction, member: discord.Member, amount: str, account: str = "wallet"):
    ctx = await commands.Context.from_interaction(interaction)
    account_norm = account.lower()
    
    # Parse amount (supports shortened formats like 1k, 1m, 1b)
    amt = parse_amount_arg(amount, 0)
    if amt is None:
        embed = discord.Embed(title="Invalid Amount", description="Please provide a valid amount (number, `1k`, `1m`, `1b`, etc.).", color=0xe74c3c)
        await ctx.send(embed=embed)
        return
    
    # Allow negative amounts for admin debt setting
    if account_norm in ("wallet", "cash"):
        set_cash(member.id, amt)
        title = "Money Set (Wallet)"
    elif account_norm == "bank":
        set_bank(member.id, amt)
        title = "Money Set (Bank)"
    else:
        embed = discord.Embed(title="Invalid Account Type", description="Use 'wallet' or 'bank'.", color=0xe74c3c)
        await ctx.send(embed=embed)
        return
    
    cash, bank = get_balances(member.id)
    
    # Choose color based on whether balance is negative
    color = 0xe74c3c if amt < 0 else 0x2ecc71
    
    embed = discord.Embed(title=title, color=color)
    
    # Handle negative amounts (debt)
    if amt < 0:
        embed.description = f"Set {member.mention}'s {account_norm} to **DEBT** of {MONEY_ICON} {abs(amt):,}."
        embed.add_field(name="⚠️ Current Status", value=f"**IN DEBT** - {MONEY_ICON} {abs(amt):,} owed", inline=False)
    else:
        embed.description = f"Updated {member.mention}'s {account_norm} to {MONEY_ICON} {amt:,}."
    
    embed.add_field(name="Wallet", value=f"{MONEY_ICON} {cash:,}", inline=True)
    embed.add_field(name="Bank", value=f"{MONEY_ICON} {bank:,}", inline=True)
    
    if amt < 0:
        embed.set_footer(text="⚠️ User is now in debt - they cannot spend money until balance is positive")
    
    await ctx.send(embed=embed)


@bot.tree.command(name="money_give", description="Give money to a user (Admin only)")
@app_commands.checks.has_permissions(administrator=True)
@app_commands.autocomplete(amount=amount_autocomplete, account=account_type_autocomplete)
async def money_give(interaction: discord.Interaction, member: discord.Member, amount: str, account: str = "wallet"):
    ctx = await commands.Context.from_interaction(interaction)
    account_norm = account.lower()
    
    # Parse amount (supports shortened formats like 1k, 1m, 1b)
    amt = parse_amount_arg(amount, 0)
    if amt is None:
        embed = discord.Embed(title="Invalid Amount", description="Please provide a valid amount (number, `1k`, `1m`, `1b`, etc.).", color=0xe74c3c)
        await ctx.send(embed=embed)
        return
    
    if account_norm in ("wallet", "cash"):
        add_cash(member.id, amt)
        title = "Money Given (Wallet)"
    elif account_norm == "bank":
        add_bank(member.id, amt)
        title = "Money Given (Bank)"
    else:
        embed = discord.Embed(title="Invalid Account Type", description="Use 'wallet' or 'bank'.", color=0xe74c3c)
        await ctx.send(embed=embed)
        return
    cash, bank = get_balances(member.id)
    embed = discord.Embed(title=title, color=0x2ecc71)
    embed.description = f"Gave {member.mention} {MONEY_ICON} {amt:,}."
    embed.add_field(name="Wallet", value=f"{MONEY_ICON} {cash:,}", inline=True)
    embed.add_field(name="Bank", value=f"{MONEY_ICON} {bank:,}", inline=True)
    await ctx.send(embed=embed)


@bot.tree.command(name="money_remove", description="Remove money from a user (Admin only)")
@app_commands.describe(member="The user to remove money from", amount="Amount to remove (can exceed current balance)", account="Account type")
@app_commands.checks.has_permissions(administrator=True)
@app_commands.autocomplete(amount=amount_autocomplete, account=account_type_autocomplete)
async def money_remove(interaction: discord.Interaction, member: discord.Member, amount: str, account: str = "wallet"):
    ctx = await commands.Context.from_interaction(interaction)
    account_norm = account.lower()
    
    # Parse amount (supports shortened formats like 1k, 1m, 1b)
    amt = parse_amount_arg(amount, 0)
    if amt is None:
        embed = discord.Embed(title="Invalid Amount", description="Please provide a valid amount (number, `1k`, `1m`, `1b`, etc.).", color=0xe74c3c)
        await ctx.send(embed=embed)
        return
    
    if account_norm in ("wallet", "cash"):
        cash, bank = get_balances(member.id)
        # Allow removing more than current balance (creates debt)
        new_balance = cash - abs(amt)
        set_cash(member.id, new_balance)
        title = "Money Removed (Wallet)"
        removed = abs(amt)
    elif account_norm == "bank":
        cash, bank = get_balances(member.id)
        # Allow removing more than current balance (creates debt)
        new_balance = bank - abs(amt)
        set_bank(member.id, new_balance)
        title = "Money Removed (Bank)"
        removed = abs(amt)
    else:
        embed = discord.Embed(title="Invalid Account Type", description="Use 'wallet' or 'bank'.", color=0xe74c3c)
        await ctx.send(embed=embed)
        return
    
    new_cash, new_bank = get_balances(member.id)
    
    # Choose color based on whether new balance is negative
    color = 0xe74c3c if new_balance < 0 else 0xe67e22
    
    embed = discord.Embed(title=title, color=color)
    embed.description = f"Removed {MONEY_ICON} {removed:,} from {member.mention}."
    
    # Show debt warning if balance went negative
    if new_balance < 0:
        embed.add_field(name="⚠️ Debt Created", value=f"User is now in debt: {MONEY_ICON} {abs(new_balance):,} owed", inline=False)
    
    embed.add_field(name="Wallet", value=f"{MONEY_ICON} {new_cash:,}", inline=True)
    embed.add_field(name="Bank", value=f"{MONEY_ICON} {new_bank:,}", inline=True)
    
    if new_balance < 0:
        embed.set_footer(text="⚠️ User is now in debt - they cannot spend money until balance is positive")
    
    await ctx.send(embed=embed)


@bot.tree.command(name="set_debt", description="Set a user into debt (Admin only)")
@app_commands.describe(member="The user to put into debt", amount="Amount of debt to create", account="Account type")
@app_commands.checks.has_permissions(administrator=True)
@app_commands.autocomplete(amount=amount_autocomplete, account=account_type_autocomplete)
async def set_debt(interaction: discord.Interaction, member: discord.Member, amount: str, account: str = "wallet"):
    """Set a user into debt - useful for testing loan systems and admin abuse"""
    ctx = await commands.Context.from_interaction(interaction)
    account_norm = account.lower()
    
    # Parse amount (supports shortened formats like 1k, 1m, 1b)
    amt = parse_amount_arg(amount, 0)
    if amt is None:
        embed = discord.Embed(title="Invalid Amount", description="Please provide a valid amount (number, `1k`, `1m`, `1b`, etc.).", color=0xe74c3c)
        await ctx.send(embed=embed)
        return
    
    # Ensure amount is positive (we'll make it negative)
    debt_amount = abs(amt)
    
    if account_norm in ("wallet", "cash"):
        set_cash(member.id, -debt_amount)
        title = "Debt Set (Wallet)"
    elif account_norm == "bank":
        set_bank(member.id, -debt_amount)
        title = "Debt Set (Bank)"
    else:
        embed = discord.Embed(title="Invalid Account Type", description="Use 'wallet' or 'bank'.", color=0xe74c3c)
        await ctx.send(embed=embed)
        return
    
    cash, bank = get_balances(member.id)
    
    embed = discord.Embed(title=title, color=0xe74c3c)
    embed.description = f"Set {member.mention} into **DEBT** of {MONEY_ICON} {debt_amount:,} in their {account_norm}."
    embed.add_field(name="⚠️ Current Status", value=f"**IN DEBT** - {MONEY_ICON} {debt_amount:,} owed", inline=False)
    embed.add_field(name="Wallet", value=f"{MONEY_ICON} {cash:,}", inline=True)
    embed.add_field(name="Bank", value=f"{MONEY_ICON} {bank:,}", inline=True)
    embed.set_footer(text="⚠️ User is now in debt - they cannot spend money until balance is positive")
    
    await ctx.send(embed=embed)


@bot.tree.command(name="debt_status", description="Check a user's debt status (Admin only)")
@app_commands.describe(member="The user to check debt status for")
@app_commands.checks.has_permissions(administrator=True)
async def debt_status(interaction: discord.Interaction, member: discord.Member):
    """Check if a user is in debt and show their financial status"""
    ctx = await commands.Context.from_interaction(interaction)
    
    cash, bank = get_balances(member.id)
    
    # Determine overall status
    total_balance = cash + bank
    has_debt = cash < 0 or bank < 0
    
    if has_debt:
        embed = discord.Embed(title="⚠️ User in Debt", color=0xe74c3c)
        embed.description = f"{member.mention} is currently in debt."
        
        # Show debt details
        if cash < 0:
            embed.add_field(name="🚨 Wallet Debt", value=f"⚠️ **DEBT** {MONEY_ICON} {abs(cash):,}", inline=True)
        else:
            embed.add_field(name="💰 Wallet", value=f"{MONEY_ICON} {cash:,}", inline=True)
            
        if bank < 0:
            embed.add_field(name="🚨 Bank Debt", value=f"⚠️ **DEBT** {MONEY_ICON} {abs(bank):,}", inline=True)
        else:
            embed.add_field(name="🏦 Bank", value=f"{MONEY_ICON} {bank:,}", inline=True)
            
        embed.add_field(name="📊 Total Balance", value=f"{format_currency(total_balance)}", inline=False)
        embed.set_footer(text="⚠️ User cannot spend money until all debts are cleared")
        
    else:
        embed = discord.Embed(title="✅ User Financially Stable", color=0x2ecc71)
        embed.description = f"{member.mention} has no outstanding debts."
        embed.add_field(name="💰 Wallet", value=f"{MONEY_ICON} {cash:,}", inline=True)
        embed.add_field(name="🏦 Bank", value=f"{MONEY_ICON} {bank:,}", inline=True)
        embed.add_field(name="📊 Total Balance", value=f"{MONEY_ICON} {total_balance:,}", inline=False)
    
    await ctx.send(embed=embed)


# -----------------------
# User Pay Command
# -----------------------
@bot.hybrid_command(name="pay", description="Pay another user from your wallet")
async def pay(ctx, user: discord.Member, amount: str):
    member = user

    if member.bot:
        return await send_embed(ctx, "Pay", "You cannot pay bots.", 0xe74c3c)
    if member.id == ctx.author.id:
        return await send_embed(ctx, "Pay", "You cannot pay yourself.", 0xe74c3c)

    payer_cash, _ = get_balances(ctx.author.id)
    amt = parse_amount_arg(amount, payer_cash)
    if amt is None:
        return await send_embed(ctx, "Pay", "Provide a valid amount (number, `all`, `half`, `1k`, `1m`, `1b`, etc.).", 0xe74c3c)
    if amt <= 0:
        return await send_embed(ctx, "Pay", "Amount must be greater than zero.", 0xe74c3c)
    if amt > payer_cash:
        return await send_embed(ctx, "Pay", "You don't have enough in your wallet.", 0xe74c3c)

    # Transfer
    set_cash(ctx.author.id, payer_cash - amt)
    add_cash(member.id, amt)

    receiver_cash, _ = get_balances(member.id)
    new_payer_cash, _ = get_balances(ctx.author.id)

    await send_embed(
        ctx,
        "Payment Sent",
        f"You paid {member.mention} {MONEY_ICON} {amt:,}.\nYour Wallet: {MONEY_ICON} {payer_cash:,} → {MONEY_ICON} {new_payer_cash:,}\n{member.display_name}'s Wallet: {MONEY_ICON} {receiver_cash:,}",
        0x2ecc71,
    )


# -----------------------
# Sect XP Conversion (money -> sect xp)
# -----------------------
@bot.hybrid_command(name="sect_xp_convert", description="Convert money to cultivation XP (100 stones = 1 XP, max 5k XP per conversion, 1h cooldown)")
@app_commands.autocomplete(amount=amount_autocomplete)
async def sect_xp_convert(ctx, amount: str):
    meta = get_user_meta(ctx.author.id)
    
    # Check 1-hour cooldown
    current_time = int(time.time())
    last_convert = meta.get("last_sect_xp_convert", 0)
    cooldown_remaining = 3600 - (current_time - last_convert)  # 1 hour = 3600 seconds
    
    if cooldown_remaining > 0:
        hours = cooldown_remaining // 3600
        minutes = (cooldown_remaining % 3600) // 60
        seconds = cooldown_remaining % 60
        
        if hours > 0:
            time_str = f"{hours}h {minutes}m {seconds}s"
        elif minutes > 0:
            time_str = f"{minutes}m {seconds}s"
        else:
            time_str = f"{seconds}s"
        
        return await send_embed(ctx, "Cooldown Active", f"You must wait **{time_str}** before converting XP again.", 0xe67e22)
    
    sect_name = meta.get("sect")
    
    # Check if user is in a valid sect
    data = load_json(SECTS_FILE)
    if sect_name and sect_name not in data:
        # Clean up invalid sect data
        meta["sect"] = None
        meta["sect_rank"] = None
        set_user_meta(ctx.author.id, meta)
        sect_name = None
    
    cash, _ = get_balances(ctx.author.id)
    # interpret amount like pay (all/half/number)
    stones = parse_amount_arg(amount, cash)
    if stones is None or stones <= 0:
        return await send_embed(ctx, "XP Conversion", "Provide a valid amount (number, `all`, `half`, `1k`, `1m`, `1b`, etc.).", 0xe74c3c)
    if stones > cash:
        return await send_embed(ctx, "XP Conversion", "You don't have enough Spirit Stones.", 0xe67e22)
    
    # 100 stones = 1 XP
    xp_gained = stones // 100
    if xp_gained <= 0:
        return await send_embed(ctx, "XP Conversion", "Amount too small. Minimum 100 stones (1 XP).", 0xe67e22)
    
    # Apply 5k XP limit per conversion
    if xp_gained > 5000:
        xp_gained = 5000
        stones = 5000 * 100  # Recalculate stones needed for 5k XP
        await send_embed(ctx, "XP Conversion Limit", f"XP capped at 5,000 per conversion. Using {MONEY_ICON} {stones:,} stones.", 0xf39c12)
    
    # Apply sect bonus if user is in a sect
    sect_bonus = 0
    sect_bonus_xp = 0
    if sect_name:
        # Check if sect exists and user is actually a member
        if sect_name in data and ctx.author.id in data[sect_name].get("members", []):
            # Sect members get 5% bonus XP
            sect_bonus = 5
            sect_bonus_xp = int(xp_gained * sect_bonus / 100)
            xp_gained += sect_bonus_xp
        else:
            # Clean up invalid sect data
            meta["sect"] = None
            meta["sect_rank"] = None
            set_user_meta(ctx.author.id, meta)
            sect_name = None
    
    # Deduct exact stones used for XP (no sect bank deposit)
    if sect_name:
        # Calculate stones used for the base XP (excluding bonus)
        base_xp = xp_gained - sect_bonus_xp
        stones_used = base_xp * 100
        set_cash(ctx.author.id, cash - stones_used)
        
        # Update sect XP but don't deposit money to sect bank
        sect = data[sect_name]
        total_xp = int(sect.get("xp", 0)) + int(base_xp)
        sect["xp"] = total_xp
        save_json(SECTS_FILE, data)
        
        # Member leveling progress shown instead of realms
        user_total_xp = add_sect_xp(ctx.author.id, xp_gained)
        level, cur_xp, needed, req = get_member_level_and_progress(user_total_xp)
        # Check promotion if in a sect
        new_rank = maybe_promote_member(ctx.author.id)
    else:
        # Rogue cultivator - just deduct money and give XP
        stones_used = xp_gained * 100
        set_cash(ctx.author.id, cash - stones_used)
        # Member leveling progress shown instead of realms
        user_total_xp = add_sect_xp(ctx.author.id, xp_gained)
        level, cur_xp, needed, req = get_member_level_and_progress(user_total_xp)
        # No promotion for rogue cultivators
        new_rank = None
    
    # Create embed
    if sect_name:
        embed = discord.Embed(title="Sect XP Conversion", color=0x2ecc71)
        embed.description = f"Converted {MONEY_ICON} {stones_used:,} → {xp_gained:,} XP."
        if sect_bonus_xp > 0:
            embed.description += f"\n**Sect Bonus:** +{sect_bonus_xp} XP (+{sect_bonus}%)"
        embed.description += f"\n⏰ **Cooldown:** 1 hour between conversions"
    else:
        embed = discord.Embed(title="Rogue Cultivator XP Conversion", color=0x2ecc71)
        embed.description = f"Converted {MONEY_ICON} {stones_used:,} → {xp_gained:,} XP."
        embed.description += f"\n💡 **Tip:** Join a sect to get +5% bonus XP on conversions!"
        embed.description += f"\n📊 **Limit:** Maximum 5,000 XP per conversion ({MONEY_ICON} 500,000 stones)"
        embed.description += f"\n⏰ **Cooldown:** 1 hour between conversions"
    embed.add_field(name="Your Level Progress", value=f"Level: {level}\nProgress: {cur_xp:,}/{req:,} (Need {needed:,} XP)", inline=False)
    
    # Show current title
    current_title = get_decorative_title(level, sect_name)
    embed.add_field(name="Current Title", value=f"**{current_title}**", inline=False)
    
    if new_rank:
        embed.add_field(name="Promotion", value=f"🎉 You have been promoted to **{new_rank}**!", inline=False)
    
    # Update cooldown timestamp
    meta["last_sect_xp_convert"] = current_time
    set_user_meta(ctx.author.id, meta)
    
    await ctx.send(embed=embed)


# Bank action autocomplete
async def bank_action_autocomplete(interaction: discord.Interaction, current: str):
    actions = ["view", "withdraw", "deposit", "pay"]
    return [app_commands.Choice(name=action.title(), value=action) for action in actions if current.lower() in action.lower()]


def _record_bank_transaction(sect, tx_type, amount, user):
    """Helper function to record bank transactions"""
    transactions = sect.get("bank_transactions", [])
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M")
    transactions.append({
        "type": tx_type,
        "amount": amount,
        "user": user,
        "time": timestamp
    })
    # Keep only last 20 transactions
    if len(transactions) > 20:
        transactions = transactions[-20:]
    sect["bank_transactions"] = transactions


# -----------------------
# Sect Bank Management (Leader only)
# -----------------------
@bot.hybrid_command(name="sect_bank", description="Sect leader and ancestors: manage sect bank funds")
@app_commands.autocomplete(action=bank_action_autocomplete)
async def sect_bank(ctx, action: str, amount: str = None, member: discord.Member = None):
    """Sect leader and ancestors: manage sect bank funds
    Actions: view, withdraw, deposit, pay
    - view: Show current bank balance
    - withdraw <amount>: Withdraw money from sect bank to your wallet
    - deposit <amount>: Deposit money from your wallet to sect bank  
    - pay <amount> <member>: Pay a sect member from sect bank
    """
    data = load_json(SECTS_FILE)
    user_meta = get_user_meta(ctx.author.id)
    sect_name = user_meta.get("sect")
    
    if not sect_name or sect_name not in data:
        return await send_embed(ctx, "Sect Bank", "You are not in a sect.", 0xe74c3c)
    
    sect = data[sect_name]
    user_rank = user_meta.get("sect_rank", "outer disciple")
    if ctx.author.id != sect.get("leader") and user_rank != "ancestor":
        return await send_embed(ctx, "Sect Bank", "Only the sect leader and ancestors can manage the sect bank.", 0xe74c3c)
    
    bank_amount = int(sect.get("bank", 0))
    
    if action.lower() == "view":
        embed = discord.Embed(title=f"🏦 {sect_name} Sect Bank", color=0x2ecc71)
        embed.description = f"**Current Balance:** {MONEY_ICON} {bank_amount:,}"
        
        # Show recent transactions if available
        transactions = sect.get("bank_transactions", [])
        if transactions:
            recent_tx = transactions[-5:]  # Last 5 transactions
            tx_text = []
            for tx in recent_tx:
                tx_type = tx.get("type", "unknown")
                tx_amount = tx.get("amount", 0)
                tx_user = tx.get("user", "Unknown")
                tx_time = tx.get("time", "")
                tx_text.append(f"• {tx_type.title()}: {MONEY_ICON} {tx_amount:,} by {tx_user} {tx_time}")
            
            if tx_text:
                embed.add_field(name="Recent Transactions", value="\n".join(tx_text), inline=False)
        
        await ctx.send(embed=embed)
        return
    
    if not amount:
        return await send_embed(ctx, "Sect Bank", f"Please specify an amount for the {action} action.", 0xe74c3c)
    
    # Parse amount
    if action.lower() in ["withdraw", "deposit"]:
        cash, _ = get_balances(ctx.author.id)
        parsed_amount = parse_amount_arg(amount, cash if action.lower() == "deposit" else bank_amount)
    else:  # pay action
        parsed_amount = parse_amount_arg(amount, bank_amount)
    
    if parsed_amount is None or parsed_amount <= 0:
        return await send_embed(ctx, "Sect Bank", "Please provide a valid amount (number, `all`, `half`, `1k`, `1m`, `1b`, etc.).", 0xe74c3c)
    
    if action.lower() == "withdraw":
        if parsed_amount > bank_amount:
            return await send_embed(ctx, "Sect Bank", "The sect bank doesn't have enough funds.", 0xe74c3c)
        
        # Withdraw from sect bank to leader's wallet
        sect["bank"] = bank_amount - parsed_amount
        add_cash(ctx.author.id, parsed_amount)
        
        # Record transaction
        _record_bank_transaction(sect, "withdraw", parsed_amount, ctx.author.display_name)
        
        embed = discord.Embed(title="🏦 Sect Bank Withdrawal", color=0x2ecc71)
        embed.description = f"Withdrew {MONEY_ICON} {parsed_amount:,} from sect bank to your wallet."
        embed.add_field(name="New Bank Balance", value=f"{MONEY_ICON} {sect['bank']:,}", inline=True)
        
    elif action.lower() == "deposit":
        cash, _ = get_balances(ctx.author.id)
        if parsed_amount > cash:
            return await send_embed(ctx, "Sect Bank", "You don't have enough Spirit Stones.", 0xe74c3c)
        
        # Deposit from leader's wallet to sect bank
        sect["bank"] = bank_amount + parsed_amount
        add_cash(ctx.author.id, -parsed_amount)
        
        # Record transaction
        _record_bank_transaction(sect, "deposit", parsed_amount, ctx.author.display_name)
        
        embed = discord.Embed(title="🏦 Sect Bank Deposit", color=0x2ecc71)
        embed.description = f"Deposited {MONEY_ICON} {parsed_amount:,} from your wallet to sect bank."
        embed.add_field(name="New Bank Balance", value=f"{MONEY_ICON} {sect['bank']:,}", inline=True)
        
    elif action.lower() == "pay":
        if not member:
            return await send_embed(ctx, "Sect Bank", "Please specify a member to pay.", 0xe74c3c)
        
        if member.id not in sect.get("members", []):
            return await send_embed(ctx, "Sect Bank", "That user is not a member of your sect.", 0xe74c3c)
        
        if parsed_amount > bank_amount:
            return await send_embed(ctx, "Sect Bank", "The sect bank doesn't have enough funds.", 0xe74c3c)
        
        # Pay member from sect bank
        sect["bank"] = bank_amount - parsed_amount
        add_cash(member.id, parsed_amount)
        
        # Record transaction
        _record_bank_transaction(sect, "pay", parsed_amount, f"{ctx.author.display_name} → {member.display_name}")
        
        embed = discord.Embed(title="🏦 Sect Bank Payment", color=0x2ecc71)
        embed.description = f"Paid {member.mention} {MONEY_ICON} {parsed_amount:,} from sect bank."
        embed.add_field(name="New Bank Balance", value=f"{MONEY_ICON} {sect['bank']:,}", inline=True)
        
    else:
        return await send_embed(ctx, "Sect Bank", "Invalid action. Use: view, withdraw, deposit, or pay.", 0xe74c3c)
    
    save_json(SECTS_FILE, data)
    await ctx.send(embed=embed)





# -----------------------
# Admin Inventory Commands
# -----------------------



@bot.command(name="inv_remove")
@commands.has_permissions(administrator=True)
@app_commands.autocomplete(item_name=inventory_item_autocomplete)
async def inv_remove(ctx, member: discord.Member, *, item_name: str):
    """Remove an item from a user's inventory. Admin only."""
    meta = get_user_meta(member.id)
    inv = meta.get("inventory", [])
    
    # Find the item in inventory
    found_item = None
    item_index = -1
    for i, item in enumerate(inv):
        if isinstance(item, dict) and item.get("name", "").lower() == item_name.lower():
            found_item = item
            item_index = i
            break
        elif isinstance(item, str) and item.lower() == item_name.lower():
            found_item = item
            item_index = i
            break
    
    if found_item is None:
        await ctx.send(f"❌ {member.mention} does not have '{item_name}' in their inventory.")
        return
    
    # Remove the item
    if item_index >= 0:
        removed_item = inv.pop(item_index)
        meta["inventory"] = inv
        set_user_meta(member.id, meta)
        
        if isinstance(removed_item, dict):
            amount = removed_item.get("amount", 1)
            if amount > 1:
                await ctx.send(f"✅ Removed {amount}x '{item_name}' from {member.mention}'s inventory.")
            else:
                await ctx.send(f"✅ Removed '{item_name}' from {member.mention}'s inventory.")
        else:
            await ctx.send(f"✅ Removed '{item_name}' from {member.mention}'s inventory.")
    else:
        await ctx.send(f"❌ Failed to remove '{item_name}' from {member.mention}'s inventory.")


@bot.command(name="add_loot")
@commands.has_permissions(administrator=True)
async def add_loot(ctx, item_name: str, base_price: int, rarity: str = "common", drop_chance: float = 0.1, auto_finish: bool = False):
    """Add a new item to the loot table that can be found when cultivating or working
    
    Parameters
    ----------
    item_name: str
        The name of the item to add
    base_price: int
        The base price of the item
    rarity: str
        The rarity of the item (common, uncommon, rare, epic, legendary, mythic)
    drop_chance: float
        The chance of the item dropping (0.1 = 10%)
    auto_finish: bool
        If True, automatically adds the item to your inventory
    """
    await ctx.defer()
    
    # Validate rarity
    rarity = rarity.lower()
    if rarity not in RARITY_LIST:
        rarity = "common"
    
    # Ensure the loot table exists for this rarity
    if rarity not in CULTIVATION_LOOT_ITEMS:
        CULTIVATION_LOOT_ITEMS[rarity] = {}
    
    # Add the item to the loot table
    CULTIVATION_LOOT_ITEMS[rarity][item_name] = {
        "base_price": int(base_price),
        "drop_chance": float(drop_chance)
    }
    
    # Save to store as well so it can be used/sold
    store = load_json(STORE_FILE)
    if item_name not in store:
        store[item_name] = {
            "price": int(base_price),
            "description": f"A {rarity} item that can be found as loot",
            "stock": 5,
            "min_rank": 0,
            "rarity": rarity
        }
        save_json(STORE_FILE, store)
    
    embed = discord.Embed(title="Loot Item Added", color=RARITY_COLOR.get(rarity, 0x2ecc71))
    embed.description = f"{RARITY_EMOJI.get(rarity, '')} Added **{item_name}** ({rarity.title()}) to the loot table.\n**Base Price:** {MONEY_ICON} {base_price}\n**Drop Chance:** {drop_chance * 100:.1f}%"
    await ctx.send(embed=embed)
    
    # If auto_finish is enabled, add the item to the admin's inventory
    if auto_finish:
        # Add to user's inventory
        admin_meta = get_user_meta(ctx.author.id)
        inv = admin_meta.get("inventory", [])
        
        # Create proper inventory item format
        inventory_item = {
            "name": item_name,
            "rarity": rarity,
            "type": "artifact",  # Loot items are artifacts
            "description": f"A {rarity} quality {item_name}",
            "value": base_price,
            "added_by": ctx.author.id,
            "added_at": int(time.time()),
            "source": "loot_creation"
        }
        
        inv.append(inventory_item)
        admin_meta["inventory"] = inv
        set_user_meta(ctx.author.id, admin_meta)
        
        # Send result embed similar to cultivation loot
        rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
        rarity_color = RARITY_COLOR.get(rarity, 0x2ecc71)
        
        result_embed = discord.Embed(title="🎁 Item Created and Added to Inventory", color=rarity_color)
        result_embed.description = f"{rarity_emoji} **{item_name}** ({rarity.title()})\nBase Value: {MONEY_ICON} {base_price:,}"
        result_embed.set_footer(text="Item added to your inventory")
        await ctx.send(embed=result_embed)


@bot.command(name="add_case")
@commands.has_permissions(administrator=True)
async def add_case(ctx, case_name: str, price: int, rarity: str = "common", description: str = None, auto_finish: bool = False):
    """Add a new case to the store that can be opened for random items
    
    Parameters
    ----------
    case_name: str
        The name of the case to add
    price: int
        The price of the case
    rarity: str
        The rarity of the case (common, uncommon, rare, epic, legendary, mythic)
    description: str
        Custom description for the case
    auto_finish: bool
        If True, automatically adds the case to your inventory
    """
    await ctx.defer()
    
    # Validate rarity
    rarity = rarity.lower()
    if rarity not in RARITY_LIST:
        rarity = "common"
    
    # Create default description if none provided
    if not description:
        description = f"A {rarity} case that contains random items."
    
    # Add to store
    store = load_json(STORE_FILE)
    case_key = case_name.lower()
    
    # Add case prefix if not already there
    if not case_key.startswith("case:"):
        case_key = f"case:{case_key}"
    
    store[case_key] = {
        "price": int(price),
        "description": description,
        "stock": 999,
        "min_rank": 0,
        "rarity": rarity,
        "is_case": True
    }
    save_json(STORE_FILE, store)
    
    # Add to cases file
    cases = load_json(CASES_FILE)
    cases[case_key] = {
        "name": case_name,
        "price": int(price),
        "rarity": rarity,
        "items": []
    }
    save_json(CASES_FILE, cases)
    
    # Create response embed
    embed = discord.Embed(title="Case Added", color=CASE_COLOR)
    embed.description = f"{CASE_EMOJI} Added **{case_name}** ({rarity.title()}) to the store.\n**Price:** {MONEY_ICON} {price:,}"
    await ctx.send(embed=embed)
    
    # If auto_finish is enabled, add the case to the admin's inventory
    if auto_finish:
        # Add to user's inventory
        admin_meta = get_user_meta(ctx.author.id)
        inv = admin_meta.get("inventory", [])
        
        # Create proper inventory item format for case
        inventory_item = {
            "name": case_name,
            "rarity": rarity,
            "type": "case",  # Cases are a special type
            "description": f"A {rarity} case that contains random items",
            "value": int(price),
            "added_by": ctx.author.id,
            "added_at": int(time.time()),
            "source": "case_creation",
            "case_key": case_key
        }
        
        inv.append(inventory_item)
        admin_meta["inventory"] = inv
        set_user_meta(ctx.author.id, admin_meta)
        
        # Send result embed
        result_embed = discord.Embed(title=f"{CASE_EMOJI} Case Created and Added to Inventory", color=CASE_COLOR)
        result_embed.description = f"**{case_name}** ({rarity.title()})\nPrice: {MONEY_ICON} {price:,}"
        result_embed.set_footer(text="Case added to your inventory")
        await ctx.send(embed=result_embed)


@bot.group(name="case-rarity")
@commands.has_permissions(administrator=True)
async def case_rarity(ctx):
    """Manage case rarities and drop items"""
    if ctx.invoked_subcommand is None:
        embed = discord.Embed(title="Case Rarity Management", color=CASE_COLOR)
        embed.description = f"Use the following subcommands to manage case rarities:\n\n"
        embed.description += f"• `/case-rarity add <case_name> <item_name> <drop_chance>` - Add an item to a case\n"
        embed.description += f"• `/case-rarity list <case_name>` - List all items in a case\n"
        embed.description += f"• `/case-rarity remove <case_name> <item_name>` - Remove an item from a case"
        await ctx.send(embed=embed)


@case_rarity.command(name="add", description="Add an item to a case with a drop chance")
@app_commands.autocomplete(rarity=rarity_autocomplete)
async def case_rarity_add(ctx, case_name: str, item_name: str, drop_chance: float = 0.1, rarity: str = None):
    """Add an item to a case with a specified drop chance
    
    Parameters
    ----------
    case_name: str
        The name of the case to add the item to
    item_name: str
        The name of the item to add to the case
    drop_chance: float
        The chance of the item dropping (0.1 = 10%)
    rarity: str
        Optional: Override the rarity of the item
    """
    await ctx.defer()
    
    # Load cases and store data
    cases = load_json(CASES_FILE)
    store = load_json(STORE_FILE)
    
    # Format case key
    case_key = case_name.lower()
    if not case_key.startswith("case:"):
        case_key = f"case:{case_key}"
    
    # Check if case exists
    if case_key not in cases:
        embed = discord.Embed(title="Error", color=0xe74c3c)
        embed.description = f"Case **{case_name}** not found. Please add it first with `/add_case`."
        await ctx.send(embed=embed)
        return
    
    # Auto-fill item details from store if it exists
    item_key = item_name.lower()
    item_data = {}
    
    if item_key in store:
        item_data = {
            "name": item_name,
            "drop_chance": float(drop_chance),
            "rarity": rarity.lower() if rarity else store[item_key].get("rarity", "common"),
            "price": store[item_key].get("price", 100)
        }
    else:
        # Check if it's in loot tables
        found = False
        for r in CULTIVATION_LOOT_ITEMS:
            if item_key in CULTIVATION_LOOT_ITEMS[r]:
                item_data = {
                    "name": item_name,
                    "drop_chance": float(drop_chance),
                    "rarity": rarity.lower() if rarity else r,
                    "price": CULTIVATION_LOOT_ITEMS[r][item_key].get("base_price", 100)
                }
                found = True
                break
        
        if not found:
            # Create new item if not found
            item_data = {
                "name": item_name,
                "drop_chance": float(drop_chance),
                "rarity": rarity.lower() if rarity else "common",
                "price": 100
            }
    
    # Add item to case
    cases[case_key]["items"].append(item_data)
    save_json(CASES_FILE, cases)
    
    # Create response embed
    rarity_str = item_data["rarity"]
    rarity_emoji = RARITY_EMOJI.get(rarity_str, "⚪")
    
    embed = discord.Embed(title="Item Added to Case", color=CASE_COLOR)
    embed.description = f"{CASE_EMOJI} Added {rarity_emoji} **{item_name}** to case **{cases[case_key]['name']}**\n"
    embed.description += f"**Drop Chance:** {drop_chance * 100:.1f}%\n"
    embed.description += f"**Rarity:** {rarity_str.title()}\n"
    embed.description += f"**Price:** {MONEY_ICON} {item_data['price']:,}"
    
    await ctx.send(embed=embed)


@case_rarity.command(name="list", description="List all items in a case")
async def case_rarity_list(ctx, case_name: str):
    """List all items in a case with their drop chances
    
    Parameters
    ----------
    case_name: str
        The name of the case to list items for
    """
    await ctx.defer()
    
    # Load cases data
    cases = load_json(CASES_FILE)
    
    # Format case key
    case_key = case_name.lower()
    if not case_key.startswith("case:"):
        case_key = f"case:{case_key}"
    
    # Check if case exists
    if case_key not in cases:
        embed = discord.Embed(title="Error", color=0xe74c3c)
        embed.description = f"Case **{case_name}** not found. Please add it first with `/add_case`."
        await ctx.send(embed=embed)
        return
    
    # Get case data
    case_data = cases[case_key]
    items = case_data.get("items", [])
    
    # Create response embed
    embed = discord.Embed(title=f"{CASE_EMOJI} Case Contents: {case_data['name']}", color=CASE_COLOR)
    
    if not items:
        embed.description = "This case doesn't have any items yet. Add some with `/case-rarity add`."
    else:
        # Sort items by drop chance (highest first)
        items.sort(key=lambda x: x.get("drop_chance", 0), reverse=True)
        
        # Calculate total drop chance
        total_chance = sum(item.get("drop_chance", 0) for item in items)
        
        embed.description = f"**Total Items:** {len(items)}\n**Total Drop Chance:** {total_chance * 100:.1f}%\n\n"
        
        for i, item in enumerate(items, 1):
            name = item.get("name", "Unknown Item")
            chance = item.get("drop_chance", 0) * 100
            rarity = item.get("rarity", "common")
            price = item.get("price", 0)
            
            rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
            
            embed.description += f"**{i}.** {rarity_emoji} **{name}** ({rarity.title()})\n"
            embed.description += f"   • Drop Chance: {chance:.1f}%\n"
            embed.description += f"   • Value: {MONEY_ICON} {price:,}\n\n"
    
    await ctx.send(embed=embed)


@case_rarity.command(name="remove", description="Remove an item from a case")
async def case_rarity_remove(ctx, case_name: str, item_name: str):
    """Remove an item from a case
    
    Parameters
    ----------
    case_name: str
        The name of the case to remove the item from
    item_name: str
        The name of the item to remove
    """
    await ctx.defer()
    
    # Load cases data
    cases = load_json(CASES_FILE)
    
    # Format case key
    case_key = case_name.lower()
    if not case_key.startswith("case:"):
        case_key = f"case:{case_key}"
    
    # Check if case exists
    if case_key not in cases:
        embed = discord.Embed(title="Error", color=0xe74c3c)
        embed.description = f"Case **{case_name}** not found. Please add it first with `/add_case`."
        await ctx.send(embed=embed)
        return
    
    # Get case data
    case_data = cases[case_key]
    items = case_data.get("items", [])
    
    # Find item by name (case insensitive)
    item_key = item_name.lower()
    found = False
    
    for i, item in enumerate(items):
        if item.get("name", "").lower() == item_key:
            removed_item = items.pop(i)
            found = True
            break
    
    if not found:
        embed = discord.Embed(title="Error", color=0xe74c3c)
        embed.description = f"Item **{item_name}** not found in case **{case_data['name']}**."
        await ctx.send(embed=embed)
        return
    
    # Save updated cases data
    save_json(CASES_FILE, cases)
    
    # Create response embed
    rarity = removed_item.get("rarity", "common")
    rarity_emoji = RARITY_EMOJI.get(rarity, "⚪")
    
    embed = discord.Embed(title="Item Removed from Case", color=CASE_COLOR)
    embed.description = f"{CASE_EMOJI} Removed {rarity_emoji} **{removed_item['name']}** from case **{case_data['name']}**."
    
    await ctx.send(embed=embed)


# -----------------------
# Sect Positions and Boosts
# -----------------------
@bot.hybrid_command(name="set_sect_position", description="Set a member's position in your sect (Sect Leader or Admin only)")
@app_commands.describe(
    member="The member to set position for",
    position="The position to set (outer disciple, inner disciple, core disciple, elder, grand elder, ancestor)"
)
@app_commands.autocomplete(position=sect_position_autocomplete)
async def set_sect_position_hybrid(ctx, member: discord.Member, *, position: str):
    """Set a member's position in your sect"""
    try:
        # Check if user is admin or sect leader
        if not ctx.author.guild_permissions.administrator:
            # Check if user is a sect leader
            user_sect = get_user_sect_and_boost(ctx.author.id)
            if not user_sect or user_sect[0] not in load_json(SECTS_FILE):
                await send_embed(ctx, "Access Denied", "You must be a sect leader or administrator to use this command.", 0xe74c3c)
                return
            
            sects = load_json(SECTS_FILE)
            sect_name = user_sect[0]
            sect_data = sects[sect_name]
            
            # Check if user is the leader of this sect
            if sect_data.get("leader") != ctx.author.id:
                await send_embed(ctx, "Access Denied", "Only the sect leader can set positions.", 0xe74c3c)
                return
        else:
            # Admin can set positions in any sect
            user_sect = get_user_sect_and_boost(member.id)
            if not user_sect:
                await send_embed(ctx, "Error", "That user is not in any sect.", 0xe74c3c)
                return
            sect_name = user_sect[0]
        
        # Check if target user is in the same sect
        target_user_sect = get_user_sect_and_boost(member.id)
        if not target_user_sect or target_user_sect[0] != sect_name:
            await send_embed(ctx, "Error", "That user is not in your sect.", 0xe74c3c)
            return
        
        # Load sects data
        sects = load_json(SECTS_FILE)
        sect_data = sects[sect_name]
        
        # Initialize positions if it doesn't exist
        if "positions" not in sect_data:
            sect_data["positions"] = {}
        
        # Normalize position name
        normalized = position.lower()
        if normalized not in SECT_RANKS and normalized not in ("sect leader", "ancestor"):
            await send_embed(ctx, "Invalid Position", f"Invalid position: {position}. Valid positions: {', '.join(SECT_RANKS)}", 0xe74c3c)
            return
        
        # Set the position
        sect_data["positions"][str(member.id)] = normalized
        
        # Save the updated sect data
        save_json(SECTS_FILE, sects)
        
        # Update user's meta for consistency
        user_meta = get_user_meta(member.id)
        user_meta["sect_rank"] = normalized
        set_user_meta(member.id, user_meta)
        
        embed = discord.Embed(title="🏛️ Sect Position Set!", color=0x2ecc71)
        embed.description = f"**{member.display_name}**'s position has been set to **{normalized.title()}** in **{sect_name}**"
        embed.add_field(name="Position", value=normalized.title(), inline=True)
        embed.add_field(name="Sect", value=sect_name, inline=True)
        embed.add_field(name="Set By", value=ctx.author.mention, inline=True)
        embed.set_footer(text=f"Use /sect_info to view all sect positions")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Set Position Error", f"Error setting sect position: {str(e)}", 0xe74c3c)


 


@bot.command(name="sect_set_level")
@commands.has_permissions(administrator=True)
async def sect_set_level(ctx, member: discord.Member, level: int):
    if level < 1:
        return await send_embed(ctx, "Sect", "Level must be at least 1.", 0xe74c3c)
    data = load_json(SECTS_FILE)
    user_meta = get_user_meta(ctx.author.id)
    sect_name = user_meta.get("sect")
    if not sect_name or sect_name not in data:
        await ctx.send("❌ You are not in a sect.")
        return
    sect = data[sect_name]
    if ctx.author.id != sect.get("leader") and not ctx.author.guild_permissions.administrator:
        await ctx.send("❌ Only the sect leader or a server admin can set levels.")
        return
    if member.id not in sect.get("members", []):
        await ctx.send("❌ That user is not in your sect.")
        return

    # Convert target level to cumulative XP and store in member meta
    # Use progressive XP system
    target_xp = get_xp_for_level(int(level))
    m_meta = get_user_meta(member.id)
    m_meta["sect_xp"] = target_xp
    set_user_meta(member.id, m_meta)

    # Try promotion based on new XP
    promoted = maybe_promote_member(member.id)
    note = f" Promoted to **{promoted}**!" if promoted else ""
    await send_embed(ctx, "Sect Level Set", f"Set {member.mention}'s level to {level}.{note}", 0x2ecc71)


@bot.command(name="stat_reset")
@commands.has_permissions(administrator=True)
async def stat_reset(ctx, member: discord.Member):
    """Reset all stat points for a user and give them the correct amount for their level"""
    # Get user's current level
    user_meta = get_user_meta(member.id)
    user_xp = int(user_meta.get("sect_xp", 0))
    level, cur_xp, needed, req = get_member_level_and_progress(user_xp)
    
    # Calculate how many attribute points they should have (1 per level)
    expected_points = calculate_attribute_points_from_level(level)
    
    # Reset all attributes to 0
    user_meta["attributes"] = {
        "strength": 0,
        "defence": 0,
        "longevity": 0,
        "luck": 0
    }
    
    # Give them the correct amount of available points for their level
    user_meta["available_attribute_points"] = expected_points
    
    # Save the changes
    set_user_meta(member.id, user_meta)
    
    # Create embed showing the reset
    embed = discord.Embed(
        title="🔄 Stat Points Reset", 
        description=f"Reset all stat points for {member.mention}",
        color=0x2ecc71
    )
    
    embed.add_field(
        name="Current Level", 
        value=f"**Level {level}** ({cur_xp:,}/{req:,} XP)", 
        inline=True
    )
    
    embed.add_field(
        name="Available Points", 
        value=f"**{expected_points}** attribute points", 
        inline=True
    )
    
    embed.add_field(
        name="Reset Stats", 
        value="Strength: 0\nDefence: 0\nLongevity: 0\nLuck: 0", 
        inline=False
    )
    
    embed.set_footer(text=f"User can now allocate {expected_points} points using ?status")
    
    await ctx.send(embed=embed)


@bot.command(name="clean_quests")
@commands.has_permissions(administrator=True)
async def clean_quests(ctx):
    """Clean corrupted quest data for all users"""
    try:
        # Load all quest data
        with open("data/user_quests.json", "r") as f:
            all_quests = json.load(f)
        
        total_cleaned = 0
        users_affected = 0
        
        for user_id_str, user_quests in all_quests.items():
            if isinstance(user_quests, dict):
                user_id = int(user_id_str)
                if clean_corrupted_quests(user_id):
                    users_affected += 1
                    total_cleaned += 1
        
        embed = discord.Embed(
            title="🧹 Quest Data Cleanup Complete", 
            description="Cleaned corrupted quest data for all users",
            color=0x2ecc71
        )
        
        embed.add_field(
            name="Results", 
            value=f"**Users affected:** {users_affected}\n**Total quests cleaned:** {total_cleaned}", 
            inline=False
        )
        
        embed.set_footer(text="Quest system should now work without errors")
        
        await ctx.send(embed=embed)
        
    except FileNotFoundError:
        await send_embed(ctx, "No Quest Data", "No quest data file found to clean.", 0xe74c3c)
    except Exception as e:
        await send_embed(ctx, "Error", f"An error occurred: {str(e)}", 0xe74c3c)


@bot.command(name="quest_clear")
@commands.has_permissions(administrator=True)
async def quest_clear(ctx, member: discord.Member):
    """Clear all quests for a user (Admin only)"""
    user_id = member.id
    
    try:
        # Load current quest data
        with open("data/user_quests.json", "r") as f:
            all_quests = json.load(f)
        
        # Clear quests for the specified user
        if str(user_id) in all_quests:
            old_quests = all_quests[str(user_id)]
            all_quests[str(user_id)] = {"daily": [], "weekly": []}
            
            # Save the cleared quests
            with open("data/user_quests.json", "w") as f:
                json.dump(all_quests, f, indent=2)
            
            embed = discord.Embed(
                title="🧹 Quest Data Cleared", 
                description=f"All quests cleared for {member.mention}",
                color=0x2ecc71
            )
            
            # Show what was cleared
            daily_count = len(old_quests.get("daily", []))
            weekly_count = len(old_quests.get("weekly", []))
            total_cleared = daily_count + weekly_count
            
            embed.add_field(
                name="Quests Cleared", 
                value=f"**Daily:** {daily_count}\n**Weekly:** {weekly_count}\n**Total:** {total_cleared}", 
                inline=True
            )
            
            embed.add_field(
                name="Next Steps", 
                value=f"User can now use:\n• `?quest daily` for new daily quests\n• `?quest weekly` for new weekly quests", 
                inline=True
            )
            
            embed.set_footer(text="Old corrupted quest data has been removed")
            
            await ctx.send(embed=embed)
            
        else:
            await send_embed(ctx, "No Quests Found", f"{member.mention} doesn't have any quests to clear.", 0xe74c3c)
            
    except FileNotFoundError:
        await send_embed(ctx, "No Quest Data", "No quest data file found.", 0xe74c3c)
    except Exception as e:
        await send_embed(ctx, "Error", f"An error occurred: {str(e)}", 0xe74c3c)


@bot.command(name="xp_convert")
async def xp_convert(ctx, amount: str):
    """Convert money to XP (1 XP = 1000 money, max 1000 XP per conversion)"""
    user_id = ctx.author.id
    
    # Parse amount
    if amount.lower() == "all":
        # Get user's cash balance
        meta = get_user_meta(user_id)
        user_cash = meta.get("cash", 0)
        money_to_convert = user_cash
    else:
        try:
            money_to_convert = int(amount)
            if money_to_convert <= 0:
                return await send_embed(ctx, "Invalid Amount", "Please specify a positive amount or 'all'.", 0xe74c3c)
        except ValueError:
            return await send_embed(ctx, "Invalid Amount", "Please specify a valid number or 'all'.", 0xe74c3c)
    
    # Check if user has enough money
    meta = get_user_meta(user_id)
    user_cash = meta.get("cash", 0)
    
    if money_to_convert > user_cash:
        return await send_embed(ctx, "Insufficient Funds", f"You only have {MONEY_ICON} {user_cash:,} cash.", 0xe74c3c)
    
    # Calculate XP (1 XP = 1000 money)
    xp_gained = money_to_convert // 1000
    
    # Apply 1000 XP limit
    if xp_gained > 1000:
        xp_gained = 1000
        money_to_convert = 1000 * 1000  # 1 million stones
    
    if xp_gained <= 0:
        return await send_embed(ctx, "Too Little Money", "You need at least 1,000 money to get 1 XP.", 0xe74c3c)
    
    # Get current level and XP
    current_xp = int(meta.get("sect_xp", 0))
    old_level, _, _, _ = get_member_level_and_progress(current_xp)
    
    # Add XP
    new_xp = current_xp + xp_gained
    meta["sect_xp"] = new_xp
    
    # Remove money
    meta["cash"] = user_cash - money_to_convert
    
    # Check for level up
    new_level, _, _, _ = get_member_level_and_progress(new_xp)
    levels_gained = new_level - old_level
    
    # Give attribute points for levels gained
    if levels_gained > 0:
        current_available = meta.get("available_attribute_points", 0)
        meta["available_attribute_points"] = current_available + levels_gained
    
    # Save changes
    set_user_meta(user_id, meta)
    
    # Create embed
    embed = discord.Embed(
        title="💰 XP Conversion Complete", 
        description=f"Successfully converted money to XP!",
        color=0x2ecc71
    )
    
    embed.add_field(
        name="Conversion Details", 
        value=f"**Money spent:** {MONEY_ICON} {money_to_convert:,}\n**XP gained:** {xp_gained:,}", 
        inline=True
    )
    
    embed.add_field(
        name="New Status", 
        value=f"**Level:** {old_level} → {new_level}\n**Total XP:** {new_xp:,}", 
        inline=True
    )
    
    if levels_gained > 0:
        embed.add_field(
            name="🎉 Level Up!", 
            value=f"You gained **{levels_gained}** level(s) and **{levels_gained}** attribute point(s)!", 
            inline=False
        )
    
    embed.add_field(
        name="💡 Info", 
        value="• 1 XP = 1,000 money\n• Maximum 1,000 XP per conversion\n• Use `?xp_convert all` to convert all your money", 
        inline=False
    )
    
    embed.set_footer(text="Use ?status to allocate your new attribute points")
    
    await ctx.send(embed=embed)


@bot.hybrid_command(name="position", description="View your or another member's sect position")
async def position(ctx, user: discord.Member = None):
    data = load_json(SECTS_FILE)
    # resolve target member
    member = user if user else ctx.author

    # find sect of target member (support rogue cultivators)
    meta = get_user_meta(member.id)
    sect_name = meta.get("sect")
    
    # Clean up corrupted sect data
    if sect_name and sect_name not in data:
        meta["sect"] = None
        meta["sect_rank"] = None
        set_user_meta(member.id, meta)
        sect_name = None
    elif sect_name and sect_name in data:
        # Check if user is actually a member of the sect
        if member.id not in data[sect_name].get("members", []):
            meta["sect"] = None
            meta["sect_rank"] = None
            set_user_meta(member.id, meta)
            sect_name = None
    
    sect = data.get(sect_name) if sect_name and sect_name in data else None
    is_rogue = sect is None
    pos = "rogue cultivator" if is_rogue else ("sect leader" if member.id == sect.get("leader") else sect.get("positions", {}).get(str(member.id), "outer disciple"))
    # Include calculated booster per new rules and sect level progress
    base_boost = 0 if is_rogue else int(sect.get("boost_percent", 0))
    
    # Compute personal booster based on position
    personal_boost = 0
    if not is_rogue:
        pos_l = pos.lower()
        try:
            idx = SECT_RANKS.index(pos_l)
        except ValueError:
            idx = 0
        
        # Calculate share based on position
        if idx >= len(SECT_RANKS) - 2:
            share = 1.0  # Sect leader and ancestor get full boost
        else:
            share = min(1.0, 0.1 + idx * 0.125)  # Base 10% + 12.5% per rank
        
        personal_boost = int(round(base_boost * share))

    # Member-centric progress display
    user_total_xp = int(meta.get("sect_xp", 0))
    lvl, cur_xp, needed, req = get_member_level_and_progress(user_total_xp)
    # ensure Immortal Art assignment on first use
    art, is_new = ensure_immortal_art_assigned(member.id, ctx.guild)
    
    # Get Immortal Arts data
    arts_data = get_user_immortal_art(member.id, ctx.guild)
    slots = arts_data.get("slots", [])
    rerolls = arts_data.get("rerolls", 3)
    unlocked_slots = arts_data.get("unlocked_slots", 1)
    
    # Format Immortal Arts display
    art_display = []
    for i in range(3):
        if i < unlocked_slots:
            if slots[i]:
                art = slots[i]
                name = art.get("name", "Unknown")
                rarity = art.get("rarity", "Unknown").title()
                art_display.append(f"**Slot {i+1}:** {name} ({rarity})")
            else:
                art_display.append(f"**Slot {i+1}:** Empty")
        else:
            art_display.append(f"**Slot {i+1}:** 🔒 Locked")
    
    embed = discord.Embed(title="Cultivator Status", color=0x3498db)
    embed.description = (
        f"Sect: **{(sect_name or 'Rogue Cultivator')}**\n"
        f"Member: {member.mention}\n"
        f"Position: **{pos.title()}**\n"
        f"**Sect Boost:** {MONEY_ICON} **{base_boost}%** (Base)\n"
        f"**Your Boost:** {MONEY_ICON} **{personal_boost}%** (Personal)\n\n"
        f"**Immortal Arts:**\n" + "\n".join(art_display) + f"\n\n"
        f"**Rerolls:** 🎲 {rerolls} | **Slots:** 🔓 {unlocked_slots}/3\n\n"
        f"Level: **{lvl}**\nProgress: {cur_xp:,}/{req:,} — Need {needed:,} XP\n\n"
        f"**Title:** {get_decorative_title(lvl, sect_name)}"
    )
    
    # Add booster explanation for sect members
    if not is_rogue and base_boost > 0:
        embed.add_field(
            name="📊 Boost System", 
            value=f"**Sect Base:** {base_boost}% total boost\n"
                  f"**Your Share:** {personal_boost}% based on position\n"
                  f"**How it works:** Higher ranks get larger shares of the sect's total boost",
            inline=False
        )
    
    # Add title progression info
    next_title_level = 0
    if lvl < 10:
        next_title_level = 10
        next_title = "Cultivator"
    elif lvl < 15:
        next_title_level = 15
        next_title = "Esteemed One"
    elif lvl < 20:
        next_title_level = 20
        next_title = "True Person"
    elif lvl < 25:
        next_title_level = 25
        next_title = "True Immortal"
    else:
        next_title_level = None
    
    if next_title_level:
        levels_needed = next_title_level - lvl
        embed.add_field(
            name="🏆 Title Progress", 
            value=f"**Current:** {get_decorative_title(lvl, sect_name).split(' (')[0]}\n"
                  f"**Next:** {sect_name + ' ' if sect_name else 'Rogue '}{next_title}\n"
                  f"**Progress:** {levels_needed} levels to go",
            inline=True
        )
    if member.display_avatar:
        embed.set_thumbnail(url=member.display_avatar.url)
    await ctx.send(embed=embed)
    if is_new:
        reveal = discord.Embed(title="Immortal Art Awakened!", color=0x9b59b6)
        reveal.description = f"{member.mention}, you awakened **{art['name']} ({art['rarity'].title()})** in Slot 1!"
        await ctx.send(embed=reveal)

# Backwards compatibility alias
@bot.hybrid_command(name="my_position", description="View your sect position (alias)")
async def my_position(ctx):
    await position(ctx)

@bot.hybrid_command(name="titles", description="View title progression and requirements")
async def titles_cmd(ctx):
    """Show title progression system and current progress"""
    meta = get_user_meta(ctx.author.id)
    sect_name = meta.get("sect")
    user_total_xp = int(meta.get("sect_xp", 0))
    lvl, cur_xp, needed, req = get_member_level_and_progress(user_total_xp)
    
    embed = discord.Embed(title="🏆 Title Progression System", color=0x9b59b6)
    embed.description = f"**Your Current Level:** {lvl}\n**Your Current Title:** {get_decorative_title(lvl, sect_name)}"
    
    # Title progression table
    title_progression = [
        (0, "Martial Artist", "Starting title for all cultivators"),
        (10, "Cultivator", "Basic cultivation achieved"),
        (15, "Esteemed One", "Respected in the cultivation world"),
        (20, "True Person", "True understanding of the Dao"),
        (25, "True Immortal", "Transcended mortal limitations")
    ]
    
    progression_text = ""
    for req_level, title, description in title_progression:
        if lvl >= req_level:
            status = "✅"
            title_display = f"**{title}**"
        else:
            status = "🔒"
            title_display = title
        
        if sect_name:
            full_title = f"{sect_name} {title}"
        else:
            full_title = f"Rogue {title}"
        
        if lvl >= req_level:
            progression_text += f"{status} **Level {req_level}:** {full_title}\n"
        else:
            levels_needed = req_level - lvl
            progression_text += f"{status} **Level {req_level}:** {full_title} ({levels_needed} levels to go)\n"
        progression_text += f"   *{description}*\n\n"
    
    embed.add_field(name="📚 Title Progression", value=progression_text, inline=False)
    
    # Next milestone
    if lvl < 25:
        next_milestone = 0
        for req_level, title, _ in title_progression:
            if lvl < req_level:
                next_milestone = req_level
                break
        
        if next_milestone > 0:
            levels_needed = next_milestone - lvl
            xp_needed = get_xp_for_level(lvl + levels_needed) - get_xp_for_level(lvl)
            embed.add_field(
                name="🎯 Next Milestone", 
                value=f"**Target:** Level {next_milestone}\n"
                      f"**Title:** {sect_name + ' ' if sect_name else 'Rogue '}{title}\n"
                      f"**Progress:** {levels_needed} levels ({xp_needed:,} XP needed)",
                inline=False
            )
    else:
        embed.add_field(
            name="🎉 Achievement Unlocked", 
            value="**Congratulations!** You have reached the highest title: **True Immortal**!",
            inline=False
        )
    
    embed.set_footer(text="Titles advance every 5 levels • Use /position for detailed status")
    await ctx.send(embed=embed)


# -----------------------
# Admin Commands for Sect Management
# -----------------------













# -----------------------
# Simple Sect Position Management
# -----------------------

# -----------------------
# Admin Sect Management (Delete Other People's Sects)
# -----------------------

@bot.command(name="admin_sect_delete")
@commands.has_permissions(administrator=True)
async def admin_sect_delete_any(ctx, sect_name: str):
    """Delete ANY sect completely (Admin only)"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        sects = load_json(SECTS_FILE)
        if sect_name not in sects:
            await send_embed(ctx, "Sect Not Found", f"Sect '{sect_name}' not found.", 0xe74c3c)
            return
        
        sect_data = sects[sect_name]
        
        # Get all members to clear their data
        all_members = [sect_data.get("leader")] + sect_data.get("members", [])
        
        # Clear sect data for all members
        for member_id in all_members:
            if member_id:
                user_meta = get_user_meta(member_id)
                user_meta["sect"] = None
                user_meta["sect_rank"] = None
                user_meta["sect_xp"] = 0
                set_user_meta(member_id, user_meta)
        
        # Remove the sect
        del sects[sect_name]
        save_json(SECTS_FILE, sects)
        
        embed = discord.Embed(title="🗑️ Admin Sect Deletion!", color=0xe74c3c)
        embed.description = f"**{sect_name}** has been completely deleted by an administrator"
        embed.add_field(name="Sect Name", value=sect_name, inline=True)
        embed.add_field(name="Members Affected", value=len(all_members), inline=True)
        embed.add_field(name="Deleted By", value=ctx.author.mention, inline=True)
        embed.set_footer(text="All members have been removed from the sect")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Admin Delete Error", f"Error deleting sect: {str(e)}", 0xe74c3c)

@bot.command(name="admin_sect_kick")
@commands.has_permissions(administrator=True)
async def admin_sect_kick_any(ctx, user: discord.Member, sect_name: str):
    """Kick a user from ANY sect (Admin only)"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        sects = load_json(SECTS_FILE)
        if sect_name not in sects:
            await send_embed(ctx, "Sect Not Found", f"Sect '{sect_name}' not found.", 0xe74c3c)
            return
        
        sect_data = sects[sect_name]
        
        # Check if user is in this sect
        if sect_data.get("leader") != user.id and user.id not in sect_data.get("members", []):
            await send_embed(ctx, "Error", f"{user.display_name} is not a member of {sect_name}.", 0xe74c3c)
            return
        
        # Remove user from sect
        if sect_data.get("leader") == user.id:
            await send_embed(ctx, "Error", "You cannot kick the sect leader. Use /admin_sect_delete to delete the entire sect.", 0xe74c3c)
            return
        
        if "members" in sect_data and user.id in sect_data["members"]:
            sect_data["members"].remove(user.id)
        
        # Remove user's position
        if "positions" in sect_data and str(user.id) in sect_data["positions"]:
            del sect_data["positions"][str(user.id)]
        
        # Save the updated sect data
        save_json(SECTS_FILE, sects)
        
        # Clear user's sect data
        user_meta = get_user_meta(user.id)
        user_meta["sect_rank"] = None
        user_meta["sect_xp"] = 0
        set_user_meta(user.id, user_meta)
        
        embed = discord.Embed(title="🚪 Admin Kick!", color=0xe74c3c)
        embed.description = f"**{user.display_name}** has been kicked from **{sect_name}** by an administrator"
        embed.add_field(name="Kicked User", value=user.mention, inline=True)
        embed.add_field(name="Sect", value=sect_name, inline=True)
        embed.add_field(name="Kicked By", value=ctx.author.mention, inline=True)
        embed.set_footer(text=f"Use /admin_sect_info to view remaining members")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Admin Kick Error", f"Error kicking user: {str(e)}", 0xe74c3c)

@bot.command(name="admin_sect_info")
@commands.has_permissions(administrator=True)
async def admin_sect_info_any(ctx, sect_name: str):
    """View detailed information about ANY sect (Admin only)"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        sects = load_json(SECTS_FILE)
        if sect_name not in sects:
            await send_embed(ctx, "Sect Not Found", f"Sect '{sect_name}' not found.", 0xe74c3c)
            return
        
        sect_data = sects[sect_name]
        
        # Get leader info
        leader_id = sect_data.get("leader")
        leader_mention = f"<@{leader_id}>" if leader_id else "None"
        
        # Get member info
        members = sect_data.get("members", [])
        member_mentions = [f"<@{mid}>" if mid else "None" for mid in members] if members else []
        
        # Get positions
        positions = sect_data.get("positions", {})
        position_text = "\n".join([f"<@{uid}>: {pos.title()}" for uid, pos in positions.items()]) if positions else "None set"
        
        embed = discord.Embed(title=f"🏛️ {sect_name} - Admin View", color=0x9b59b6)
        embed.description = f"Detailed information about sect **{sect_name}**"
        
        embed.add_field(name="Leader", value=leader_mention, inline=True)
        embed.add_field(name="Member Count", value=len(members) + 1, inline=True)
        embed.add_field(name="Level", value=sect_data.get("level", 1), inline=True)
        
        embed.add_field(name="Members", value="\n".join(member_mentions) if member_mentions else "None", inline=False)
        embed.add_field(name="Positions", value=position_text, inline=False)
        
        embed.add_field(name="Created", value=sect_data.get("created", "Unknown"), inline=True)
        embed.add_field(name="Privacy", value=sect_data.get("privacy", "private").title(), inline=True)
        
        embed.set_footer(text="Admin view - Use /admin_sect_kick or /admin_sect_delete for management")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Admin Sect Info Error", f"Error getting sect info: {str(e)}", 0xe74c3c)


@bot.command(name="kick_sect_member")
async def kick_sect_member(ctx, user: discord.Member):
    """Kick a member from your sect (Sect Leader or Admin only)"""
    try:
        # Check if user is admin or sect leader
        if not ctx.author.guild_permissions.administrator:
            # Check if user is a sect leader
            user_sect = get_user_sect_and_boost(ctx.author.id)
            if not user_sect or user_sect[0] not in load_json(SECTS_FILE):
                await send_embed(ctx, "Access Denied", "You must be a sect leader or administrator to use this command.", 0xe74c3c)
                return
            
            sects = load_json(SECTS_FILE)
            sect_name = user_sect[0]
            sect_data = sects[sect_name]
            
            # Check if user is the leader of this sect
            if sect_data.get("leader") != ctx.author.id:
                await send_embed(ctx, "Access Denied", "Only the sect leader can kick members.", 0xe74c3c)
                return
        else:
            # Admin can kick from any sect
            user_sect = get_user_sect_and_boost(user.id)
            if not user_sect:
                await send_embed(ctx, "Error", "That user is not in any sect.", 0xe74c3c)
                return
            sect_name = user_sect[0]
        
        # Check if target user is in the same sect
        target_user_sect = get_user_sect_and_boost(user.id)
        if not target_user_sect or target_user_sect[0] != sect_name:
            await send_embed(ctx, "Error", "That user is not in your sect.", 0xe74c3c)
            return
        
        # Load sects data
        sects = load_json(SECTS_FILE)
        sect_data = sects[sect_name]
        
        # Prevent kicking the leader
        if sect_data.get("leader") == user.id:
            await send_embed(ctx, "Error", "You cannot kick the sect leader.", 0xe74c3c)
            return
        
        # Remove user from sect
        if "members" in sect_data and user.id in sect_data["members"]:
            sect_data["members"].remove(user.id)
        
        # Remove user's position
        if "positions" in sect_data and str(user.id) in sect_data["positions"]:
            del sect_data["positions"][str(user.id)]
        
        # Save the updated sect data
        save_json(SECTS_FILE, sects)
        
        # Clear user's sect data
        user_meta = get_user_meta(user.id)
        user_meta["sect"] = None
        user_meta["sect_rank"] = None
        user_meta["sect_xp"] = 0
        set_user_meta(user.id, user_meta)
        
        embed = discord.Embed(title="🚪 Member Kicked!", color=0xe74c3c)
        embed.description = f"**{user.display_name}** has been kicked from **{sect_name}**"
        embed.add_field(name="Kicked User", value=user.mention, inline=True)
        embed.add_field(name="Sect", value=sect_name, inline=True)
        embed.add_field(name="Kicked By", value=ctx.author.mention, inline=True)
        embed.set_footer(text=f"Use /sect_info to view remaining members")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Kick Member Error", f"Error kicking sect member: {str(e)}", 0xe74c3c)





# Autocomplete for immortal arts rarity
async def immortal_arts_rarity_autocomplete(interaction: discord.Interaction, current: str):
    rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]
    return [app_commands.Choice(name=rarity.title(), value=rarity) for rarity in rarities if current.lower() in rarity.lower()]

@bot.hybrid_command(name="immortal_arts", description="View Immortal Arts by rarity type")
@app_commands.describe(rarity="Which rarity to view (common, uncommon, rare, epic, legendary, mythic, divine)")
@app_commands.autocomplete(rarity=immortal_arts_rarity_autocomplete)
async def immortal_arts(ctx, rarity: str = None):
    if rarity:
        rarity = rarity.lower()
        if rarity not in ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]:
            return await send_embed(ctx, "Invalid Rarity", "Please choose from: common, uncommon, rare, epic, legendary, mythic, divine", 0xe74c3c)
        
        # Show only the specified rarity
        embed = discord.Embed(title=f"{rarity.title()} Immortal Arts", color=0xF1C40F)
        arts = IMMORTAL_ARTS.get(rarity, {})
        if not arts:
            return await send_embed(ctx, f"No {rarity.title()} Arts", f"There are no {rarity} Immortal Arts available.", 0xe74c3c)
        
        # Calculate chance for this rarity
        total_weight = sum(w for _, w in IMMORTAL_RARITY_WEIGHTS)
        weight_map = {r: w for r, w in IMMORTAL_RARITY_WEIGHTS}
        rarity_chance = (weight_map.get(rarity, 0) / total_weight) * 100 if total_weight else 0
        
        lines = []
        for name, effects in arts.items():
            # Get description and truncate if too long
            desc = str(effects.get("desc", "")).strip()
            if not desc:
                effect_parts = []
                for k, v in effects.items():
                    if k == "desc":
                        continue
                    label = k.replace("_", " ").replace("pct", "%")
                    effect_parts.append(f"{label}: {v}")
                desc = ", ".join(effect_parts)
            
            # Truncate description to fit Discord's 1024 character limit
            max_desc_length = 900  # Leave some buffer
            if len(desc) > max_desc_length:
                desc = desc[:max_desc_length-3] + "..."
            
            lines.append(f"- **{name}**: {desc}")
        
        # Split into multiple fields if content is too long
        content = "\n".join(lines) or "-"
        if len(content) > 1024:
            # Split into chunks
            chunks = []
            current_chunk = ""
            for line in lines:
                if len(current_chunk + "\n" + line) > 1024:
                    if current_chunk:
                        chunks.append(current_chunk.strip())
                    current_chunk = line
                else:
                    if current_chunk:
                        current_chunk += "\n" + line
                    else:
                        current_chunk = line
            
            if current_chunk:
                chunks.append(current_chunk.strip())
            
            # Add multiple fields for this rarity
            for i, chunk in enumerate(chunks):
                field_name = f"{rarity.title()} — {rarity_chance:.2f}% (Part {i+1})" if len(chunks) > 1 else f"{rarity.title()} — {rarity_chance:.2f}%"
                embed.add_field(name=field_name, value=chunk, inline=False)
        else:
            header_name = f"{rarity.title()} — {rarity_chance:.2f}%"
            embed.add_field(name=header_name, value=content, inline=False)
        
        embed.set_footer(text=f"Use /immortal_arts without a rarity to see all types")
        
    else:
        # Show all rarities (original behavior)
        embed = discord.Embed(title="All Immortal Arts", color=0xF1C40F)
        embed.description = "Use `/immortal_arts <rarity>` to view a specific rarity type.\n\n**Available rarities:** common, uncommon, rare, epic, legendary, mythic, divine"
        
        # Show weights as chances
        total_weight = sum(w for _, w in IMMORTAL_RARITY_WEIGHTS)
        weight_map = {r: w for r, w in IMMORTAL_RARITY_WEIGHTS}
        
        for rarity in ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]:
            arts = IMMORTAL_ARTS.get(rarity, {})
            if not arts:
                continue
                
            rarity_chance = (weight_map.get(rarity, 0) / total_weight) * 100 if total_weight else 0
            count = len(arts)
            embed.add_field(name=f"{rarity.title()} ({count} arts)", value=f"Chance: {rarity_chance:.2f}%", inline=True)
    
    await ctx.send(embed=embed)


@bot.hybrid_command(name="immortal_art", description="View your Immortal Arts and slots")
async def immortal_art_cmd(ctx):
    arts_data = get_user_immortal_art(ctx.author.id, ctx.guild)
    slots = arts_data.get("slots", [])
    rerolls = arts_data.get("rerolls", 3)
    unlocked_slots = arts_data.get("unlocked_slots", 1)
    
    embed = discord.Embed(title="Your Immortal Arts", color=0x9b59b6)
    
    # Show slots
    slot_info = []
    for i in range(3):
        if i < unlocked_slots:
            if slots[i]:
                art = slots[i]
                name = art.get("name", "Unknown")
                rarity = art.get("rarity", "Unknown").title()
                desc = IMMORTAL_ARTS.get(art.get("rarity",""), {}).get(art.get("name",""), {}).get("desc", "")
                slot_info.append(f"**Slot {i+1}:** {name} ({rarity})\n_Effect_: {desc}")
            else:
                slot_info.append(f"**Slot {i+1}:** Empty")
        else:
            slot_info.append(f"**Slot {i+1}:** 🔒 Locked")
    
    embed.description = "\n\n".join(slot_info)
    embed.add_field(name="Rerolls Remaining", value=f"🎲 {rerolls}", inline=True)
    embed.add_field(name="Unlocked Slots", value=f"🔓 {unlocked_slots}/3", inline=True)
    
    if ctx.author.display_avatar:
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
    
    await ctx.send(embed=embed)


class RerollButtonView(discord.ui.View):
    def __init__(self, ctx, slot: int):
        super().__init__(timeout=300)  # 5 minute timeout
        self.ctx = ctx
        self.slot = slot
        self.user_id = ctx.author.id
        self.message = None
    
    @discord.ui.button(label="🎲 Reroll Again", style=discord.ButtonStyle.primary, custom_id="reroll_again", row=0)
    async def reroll_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        """Reroll button that stays visible and keeps rerolling"""
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("This button is not for you!", ephemeral=True)
            return
        
        arts_data = get_user_immortal_art(self.user_id, self.ctx.guild)
        slots = arts_data.get("slots", [])
        rerolls = arts_data.get("rerolls", 3)
        unlocked_slots = arts_data.get("unlocked_slots", 1)
        
        # Check if slot is unlocked
        if self.slot > unlocked_slots:
            await interaction.response.send_message(f"Slot {self.slot} is locked. Unlock it first.", ephemeral=True)
            return
        
        # Check if user has rerolls
        if rerolls <= 0:
            await interaction.response.send_message("You have no rerolls remaining.", ephemeral=True)
            return
        
        # Get current art in slot
        slot_index = self.slot - 1
        current_art = slots[slot_index] if slot_index < len(slots) else None
        
        # Check for rigged reroll (admin override)
        meta = get_user_meta(self.user_id)
        rigged_reroll = meta.get("rigged_reroll", {})
        
        if rigged_reroll and "expires" in rigged_reroll:
            try:
                expires_time = datetime.fromisoformat(rigged_reroll["expires"])
                # Check if rigged reroll is still active
                if datetime.now(timezone.utc) < expires_time:
                    # Use rigged rarity
                    rarity = rigged_reroll["rarity"]
                else:
                    # Expired, remove it
                    del meta["rigged_reroll"]
                    set_user_meta(self.user_id, meta)
                    rarity = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
            except (ValueError, TypeError):
                # Invalid date format, remove invalid rig and use normal
                del meta["rigged_reroll"]
                set_user_meta(self.user_id, meta)
                rarity = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
        else:
            # Normal reroll
            rarity = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
        
        name = random.choice(list(IMMORTAL_ARTS[rarity].keys()))
        new_art = {"name": name, "rarity": rarity}
        
        # Update slot and reduce rerolls
        meta = get_user_meta(self.user_id)
        meta["immortal_arts"]["slots"][slot_index] = new_art
        meta["immortal_arts"]["rerolls"] = rerolls - 1
        set_user_meta(self.user_id, meta)
        
        # Update the embed with new art info
        embed = interaction.message.embeds[0]
        embed.title = "🎲 Immortal Art Rerolled!"
        
        # Clear existing fields and rebuild the embed
        embed.clear_fields()
        
        # Show what you had before
        if current_art:
            old_name = current_art.get("name", "Unknown")
            old_rarity = current_art.get("rarity", "Unknown").title()
            old_desc = IMMORTAL_ARTS.get(old_rarity.lower(), {}).get(old_name, {}).get("desc", "No description available")
            
            embed.add_field(
                name="🔄 What You Had Before", 
                value=f"**{old_name}** ({old_rarity})\n{old_desc}", 
                inline=False
            )
        
        # Show what you got now
        desc = IMMORTAL_ARTS.get(rarity, {}).get(name, {}).get("desc", "No description available")
        embed.add_field(
            name="✨ What You Got Now", 
            value=f"**{name}** ({rarity.title()})\n{desc}", 
            inline=False
        )
        
        # Add rerolls remaining
        embed.add_field(name="🎲 Rerolls Remaining", value=f"{rerolls - 1}", inline=True)
        
        # Check if new art is legendary, mythic, or divine and show warning
        if rarity in ["legendary", "mythic", "divine"]:
            if rarity == "divine":
                embed.color = 0xff0000
                embed.title = f"🚨 DIVINE ART OBTAINED! 🚨"
                warning_text = f"This is a DIVINE **{rarity.title()}** art beyond mortal comprehension!\nNEVER reroll this!"
            elif rarity == "mythic":
                embed.color = 0xe74c3c
                embed.title = f"⚠️ MYTHIC ART OBTAINED!"
                warning_text = f"This is an extremely rare **{rarity.title()}** art!\nConsider keeping it instead of rerolling!"
            else:  # legendary
                embed.color = 0xf39c12
                embed.title = f"⚠️ LEGENDARY ART OBTAINED!"
                warning_text = f"This is a very rare **{rarity.title()}** art!\nConsider keeping it instead of rerolling!"
            
            # Add warning field
                embed.add_field(name="⚠️ WARNING", value=warning_text, inline=False)
        
        # Disable button if no rerolls left
        if rerolls - 1 <= 0:
            button.disabled = True
            button.label = "🎲 No Rerolls Left"
        
        await interaction.response.edit_message(embed=embed, view=self)


@bot.hybrid_command(name="reroll", description="Reroll an Immortal Art slot")
async def reroll_cmd(ctx, slot: int = 1):
    """Reroll an Immortal Art slot. Use the button to keep rerolling."""
    if slot < 1 or slot > 3:
        await send_embed(ctx, "Reroll", "Slot must be 1, 2, or 3.", 0xe74c3c)
        return
    
    arts_data = get_user_immortal_art(ctx.author.id, ctx.guild)
    slots = arts_data.get("slots", [])
    rerolls = arts_data.get("rerolls", 3)
    unlocked_slots = arts_data.get("unlocked_slots", 1)
    
    # Check if slot is unlocked
    if slot > unlocked_slots:
        await send_embed(ctx, "Reroll", f"Slot {slot} is locked. Unlock it first.", 0xe74c3c)
        return
    
    # Check if user has rerolls
    if rerolls <= 0:
        await send_embed(ctx, "Reroll", "You have no rerolls remaining.", 0xe74c3c)
        return
    
    # Get current art in slot
    slot_index = slot - 1
    current_art = slots[slot_index] if slot_index < len(slots) else None
    
    # Generate new art
    rarity = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
    name = random.choice(list(IMMORTAL_ARTS[rarity].keys()))
    new_art = {"name": name, "rarity": rarity}
    
    # Update slot and reduce rerolls
    meta = get_user_meta(ctx.author.id)
    meta["immortal_arts"]["slots"][slot_index] = new_art
    meta["immortal_arts"]["rerolls"] = rerolls - 1
    set_user_meta(ctx.author.id, meta)
    
    # Create comprehensive response embed
    embed = discord.Embed(title="🎲 Immortal Art Rerolled!", color=0x9b59b6)
    
    # Show what you had before
    if current_art:
        old_name = current_art.get("name", "Unknown")
        old_rarity = current_art.get("rarity", "Unknown").title()
        old_desc = IMMORTAL_ARTS.get(old_rarity.lower(), {}).get(old_name, {}).get("desc", "No description available")
        
        embed.add_field(
            name="🔄 What You Had Before", 
            value=f"**{old_name}** ({old_rarity})\n{old_desc}", 
            inline=False
        )
    
    # Show what you got now
    desc = IMMORTAL_ARTS.get(rarity, {}).get(name, {}).get("desc", "No description available")
    embed.add_field(
        name="✨ What You Got Now", 
        value=f"**{name}** ({rarity.title()})\n{desc}", 
        inline=False
    )
    
    # Add rerolls remaining
    embed.add_field(name="🎲 Rerolls Remaining", value=f"{rerolls - 1}", inline=True)
    
    # Check if new art is legendary, mythic, or divine and show warning
    if rarity in ["legendary", "mythic", "divine"]:
        if rarity == "divine":
            embed.color = 0xff0000
            embed.title = "🚨 DIVINE ART OBTAINED! 🚨"
            warning_text = "This is a DIVINE art beyond mortal comprehension! NEVER reroll this!"
        elif rarity == "mythic":
            embed.color = 0xe74c3c
            embed.title = "⚠️ MYTHIC ART OBTAINED!"
            warning_text = "This is an extremely rare and powerful art. Consider keeping it instead of rerolling!"
        else:  # legendary
            embed.color = 0xf39c12
            embed.title = "⚠️ LEGENDARY ART OBTAINED!"
            warning_text = "This is a very rare and powerful art. Consider keeping it instead of rerolling!"
            
        embed.add_field(name="⚠️ WARNING", value=warning_text, inline=False)
    
    # Always create view with reroll button (unless no rerolls left)
    view = None
    if rerolls - 1 > 0:  # Only show button if user has rerolls left
        view = RerollButtonView(ctx, slot)
    
    # Send the full embed with button
    await ctx.send(embed=embed, view=view)


@bot.hybrid_command(name="unlock_slot", description="Unlock an Immortal Art slot")
async def unlock_slot_cmd(ctx, slot: int):
    """Unlock an Immortal Art slot. Slot 2 costs 1M, Slot 3 costs 10M."""
    if slot < 2 or slot > 3:
        await send_embed(ctx, "Unlock Slot", "You can only unlock slots 2 or 3.", 0xe74c3c)
        return
    
    arts_data = get_user_immortal_art(ctx.author.id, ctx.guild)
    unlocked_slots = arts_data.get("unlocked_slots", 1)
    
    # Check if slot is already unlocked
    if slot <= unlocked_slots:
        await send_embed(ctx, "Unlock Slot", f"Slot {slot} is already unlocked.", 0xe74c3c)
        return
    
    # Check if trying to unlock slot 3 before slot 2
    if slot == 3 and unlocked_slots < 2:
        await send_embed(ctx, "Unlock Slot", "You must unlock slot 2 before slot 3.", 0xe74c3c)
        return
    
    # Determine cost
    cost = 1000000 if slot == 2 else 10000000  # 1M for slot 2, 10M for slot 3
    
    # Check if user has enough money
    cash, _ = get_balances(ctx.author.id)
    if cash < cost:
        await send_embed(ctx, "Unlock Slot", f"You need {MONEY_ICON} {cost:,} to unlock slot {slot}. You have {MONEY_ICON} {cash:,}.", 0xe74c3c)
        return
    
    # Deduct money and unlock slot
    add_cash(ctx.author.id, -cost)
    meta = get_user_meta(ctx.author.id)
    meta["immortal_arts"]["unlocked_slots"] = slot
    set_user_meta(ctx.author.id, meta)
    
    # Create response embed
    embed = discord.Embed(title="🔓 Slot Unlocked!", color=0x2ecc71)
    embed.description = f"Unlocked **Slot {slot}** for {MONEY_ICON} {cost:,}!"
    embed.add_field(name="Unlocked Slots", value=f"🔓 {slot}/3", inline=True)
    
    await send_embed(ctx, "🔓 Slot Unlocked!", f"Unlocked **Slot {slot}** for {MONEY_ICON} {cost:,}!", 0x2ecc71)


@bot.hybrid_command(name="immortal_art_admin", description="Admin immortal arts system management")
@app_commands.describe(
    member="User to manage immortal arts for",
    action="Action to perform (view, reroll, set, unlock, reroll_slot)",
    slot="Slot number (1-3)",
    name="Art name (for set action)",
    rarity="Art rarity (for set action)"
)
@app_commands.autocomplete(action=ia_action_autocomplete, slot=ia_slot_autocomplete, rarity=ia_rarity_autocomplete, name=ia_name_autocomplete)
@app_commands.checks.has_permissions(administrator=True)
async def immortal_art_admin(ctx, member: discord.Member, action: str, slot: int = 1, name: str = None, rarity: str = None):
    """Admin immortal arts system management with autocomplete support"""
    try:
        # Check if this is a slash command or prefix command
        is_slash = ctx.interaction is not None if hasattr(ctx, 'interaction') else False
        
        if is_slash:
            await ctx.defer()
        
        action = (action or "view").lower()
        
        if action == "view":
            arts_data = get_user_immortal_art(member.id, ctx.guild)
            if not arts_data:
                error_msg = "❌ Failed to load immortal arts data. Please try again."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                return
                
            slots = arts_data.get("slots", [])
            rerolls = arts_data.get("rerolls", 3)
            unlocked_slots = arts_data.get("unlocked_slots", 1)
            
            embed = discord.Embed(title=f"Immortal Arts - {member.display_name}", color=0x9b59b6)
            
            # Show all slots
            slot_info = []
            for i in range(3):
                if i < unlocked_slots:
                    if slots[i]:
                        art = slots[i]
                        art_name = art.get("name", "Unknown")
                        art_rarity = art.get("rarity", "Unknown").title()
                        slot_info.append(f"**Slot {i+1}:** {art_name} ({art_rarity})")
                    else:
                        slot_info.append(f"**Slot {i+1}:** Empty")
                else:
                    slot_info.append(f"**Slot {i+1}:** 🔒 Locked")
            
            embed.description = "\n".join(slot_info)
            embed.add_field(name="Rerolls", value=f"🎲 {rerolls}", inline=True)
            embed.add_field(name="Unlocked Slots", value=f"🔓 {unlocked_slots}/3", inline=True)
            
            if is_slash:
                await ctx.followup.send(embed=embed)
            else:
                await ctx.send(embed=embed)
            return
        
        elif action == "reroll":
            if slot < 1 or slot > 3:
                error_msg = "Slot must be 1, 2, or 3."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                return
                
            arts_data = get_user_immortal_art(member.id, ctx.guild)
            if not arts_data:
                error_msg = "❌ Failed to load immortal arts data. Please try again."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                return
                
            unlocked_slots = arts_data.get("unlocked_slots", 1)
            
            if slot > unlocked_slots:
                error_msg = f"Slot {slot} is locked for {member.mention}."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                return
                
            # Generate new art
            rarity_choice = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
            name_choice = random.choice(list(IMMORTAL_ARTS[rarity_choice].keys()))
            new_art = {"name": name_choice, "rarity": rarity_choice}
            
            # Update slot
            meta = get_user_meta(member.id)
            if not meta:
                error_msg = "❌ Failed to load user data. Please try again."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                return
                
            meta["immortal_arts"]["slots"][slot - 1] = new_art
            set_user_meta(member.id, meta)
            
            success_msg = f"Rerolled {member.mention}'s Slot {slot} to **{name_choice} ({rarity_choice.title()})**"
            if is_slash:
                await ctx.followup.send(embed=discord.Embed(title="✅ Success", description=success_msg, color=0x2ecc71))
            else:
                await ctx.send(embed=discord.Embed(title="✅ Success", description=success_msg, color=0x2ecc71))
            return
        
        elif action == "set":
            if not name or not rarity:
                error_msg = "Provide both name and rarity for set action."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                return
            if slot < 1 or slot > 3:
                error_msg = "Slot must be 1, 2, or 3."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                return
                
            rarity = rarity.lower()
            if rarity not in IMMORTAL_ARTS or name not in IMMORTAL_ARTS[rarity]:
                error_msg = "Invalid rarity or art name."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                return
                
            # Set the art in the specified slot
            meta = get_user_meta(member.id)
            if not meta:
                error_msg = "❌ Failed to load user data. Please try again."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                return
                
            if "immortal_arts" not in meta:
                meta["immortal_arts"] = {
                    "slots": [None, None, None],
                    "rerolls": 3,
                    "unlocked_slots": max(1, slot)
                }
            
            meta["immortal_arts"]["slots"][slot - 1] = {"name": name, "rarity": rarity}
            meta["immortal_arts"]["unlocked_slots"] = max(meta["immortal_arts"]["unlocked_slots"], slot)
            set_user_meta(member.id, meta)
            
            success_msg = f"Set {member.mention}'s Slot {slot} to **{name} ({rarity.title()})**"
            if is_slash:
                await ctx.followup.send(embed=discord.Embed(title="✅ Success", description=success_msg, color=0x2ecc71))
            else:
                await ctx.send(embed=discord.Embed(title="✅ Success", description=success_msg, color=0x2ecc71))
            return
        
        elif action == "unlock":
            if slot < 2 or slot > 3:
                error_msg = "You can only unlock slots 2 or 3."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                return
                
            meta = get_user_meta(member.id)
            if not meta:
                error_msg = "❌ Failed to load user data. Please try again."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                return
                
            if "immortal_arts" not in meta:
                meta["immortal_arts"] = {
                    "slots": [None, None, None],
                    "rerolls": 3,
                    "unlocked_slots": 1
                }
            
            meta["immortal_arts"]["unlocked_slots"] = max(meta["immortal_arts"]["unlocked_slots"], slot)
            set_user_meta(member.id, meta)
            
            success_msg = f"Unlocked slot {slot} for {member.mention}."
            if is_slash:
                await ctx.followup.send(embed=discord.Embed(title="✅ Success", description=success_msg, color=0x2ecc71))
            else:
                await ctx.send(embed=discord.Embed(title="✅ Success", description=success_msg, color=0x2ecc71))
            return
        
        elif action == "reroll_slot":
            if slot < 1 or slot > 3:
                error_msg = "Slot must be 1, 2, or 3."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                return
                
            arts_data = get_user_immortal_art(member.id, ctx.guild)
            unlocked_slots = arts_data.get("unlocked_slots", 1)
            
            if slot > unlocked_slots:
                error_msg = f"Slot {slot} is locked for {member.mention}."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
                return
                
            # Generate new art with weighted rarity
            rarity_choice = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
            name_choice = random.choice(list(IMMORTAL_ARTS[rarity_choice].keys()))
            new_art = {"name": name_choice, "rarity": rarity_choice}
            
            # Update slot
            meta = get_user_meta(member.id)
            if not meta:
                error_msg = "❌ Failed to load user data. Please try again."
                if is_slash:
                    await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                else:
                    await ctx.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
                return
                
            if "immortal_arts" not in meta:
                meta["immortal_arts"] = {
                    "slots": [None, None, None],
                    "rerolls": 3,
                    "unlocked_slots": max(1, slot)
                }
            
            meta["immortal_arts"]["slots"][slot - 1] = new_art
            meta["immortal_arts"]["unlocked_slots"] = max(meta["immortal_arts"]["unlocked_slots"], slot)
            set_user_meta(member.id, meta)
            
            embed = discord.Embed(title="🔄 Immortal Art Rerolled!", color=0x9b59b6)
            embed.description = f"Admin rerolled {member.mention}'s Slot {slot}"
            embed.add_field(name="New Art", value=f"**{name_choice}** ({rarity_choice.title()})", inline=True)
            embed.add_field(name="Slot", value=f"Slot {slot}", inline=True)
            embed.set_footer(text=f"Rerolled by {ctx.author.display_name}")
            
            if is_slash:
                await ctx.followup.send(embed=embed)
            else:
                await ctx.send(embed=embed)
            return
        
        error_msg = "Unknown action. Use: view, reroll, set, unlock, reroll_slot"
        if is_slash:
            await ctx.followup.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
        else:
            await ctx.send(embed=discord.Embed(title="❌ Error", description=error_msg, color=0xe74c3c))
        
    except Exception as e:
        print(f"Error in immortal_art_admin command: {e}")
        logging.error(f"Error in immortal_art_admin command: {e}", exc_info=True)
        
        error_msg = "❌ An error occurred while managing immortal arts. Please try again."
        try:
            if is_slash:
                await ctx.followup.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
            else:
                await ctx.send(embed=discord.Embed(title="Error", description=error_msg, color=0xe74c3c))
        except:
            # If all else fails, try to send a simple message
            try:
                await ctx.send(error_msg)
            except:
                pass





# Removed duplicate immortal_art_manage command - keeping the better immortal_art_admin command above
    """Comprehensive immortal art management command. Admin only.
    
    Actions:
    - view: View user's immortal arts
    - set: Set specific art in slot (requires name and rarity)
    - reroll: Reroll specific slot
    - unlock: Unlock a slot
    - set_rerolls: Set number of rerolls
    - reset: Reset all immortal arts
    """
    action = action.lower()
    
    if action == "view":
        arts_data = get_user_immortal_art(member.id, ctx.guild)
        slots = arts_data.get("slots", [])
        rerolls = arts_data.get("rerolls", 3)
        unlocked_slots = arts_data.get("unlocked_slots", 1)
        
        embed = discord.Embed(title=f"Immortal Arts - {member.display_name}", color=0x9b59b6)
        
        # Show all slots
        slot_info = []
        for i in range(3):
            if i < unlocked_slots:
                if slots[i]:
                    art = slots[i]
                    name = art.get("name", "Unknown")
                    rarity = art.get("rarity", "Unknown").title()
                    slot_info.append(f"**Slot {i+1}:** {name} ({rarity})")
                else:
                    slot_info.append(f"**Slot {i+1}:** Empty")
            else:
                slot_info.append(f"**Slot {i+1}:** 🔒 Locked")
        
        embed.description = "\n".join(slot_info)
        embed.add_field(name="Rerolls", value=f"🎲 {rerolls}", inline=True)
        embed.add_field(name="Unlocked Slots", value=f"🔓 {unlocked_slots}/3", inline=True)
        embed.set_footer(text=f"Viewing {member.display_name}'s immortal arts")
        
        await ctx.send(embed=embed)
        return
    
    elif action == "set":
        if not name or not rarity:
            await ctx.send("Provide both name and rarity for set action.")
            return
        if slot < 1 or slot > 3:
            await ctx.send("Slot must be 1, 2, or 3.")
            return
        
        rarity = rarity.lower()
        if rarity not in IMMORTAL_ARTS or name not in IMMORTAL_ARTS[rarity]:
            await ctx.send("Invalid rarity or art name.")
            return
            
        # Set the art in the specified slot
        meta = get_user_meta(member.id)
        if "immortal_arts" not in meta:
            meta["immortal_arts"] = {
                "slots": [None, None, None],
                "rerolls": 3,
                "unlocked_slots": max(1, slot)
            }
        
        meta["immortal_arts"]["slots"][slot - 1] = {"name": name, "rarity": rarity}
        meta["immortal_arts"]["unlocked_slots"] = max(meta["immortal_arts"]["unlocked_slots"], slot)
        set_user_meta(member.id, meta)
        
        embed = discord.Embed(title="✨ Immortal Art Set", color=0x2ecc71)
        embed.description = f"Set {member.mention}'s Slot {slot} to **{name} ({rarity.title()})**"
        embed.set_footer(text=f"Set by {ctx.author.display_name}")
        await ctx.send(embed=embed)
        return
        
    elif action == "reroll":
        if slot < 1 or slot > 3:
            await ctx.send("Slot must be 1, 2, or 3.")
            return
            
        arts_data = get_user_immortal_art(member.id, ctx.guild)
        unlocked_slots = arts_data.get("unlocked_slots", 1)
        
        if slot > unlocked_slots:
            await ctx.send(f"Slot {slot} is locked for {member.mention}.")
            return
            
        # Generate new art with weighted rarity
        rarity_choice = _choose_weighted(IMMORTAL_RARITY_WEIGHTS)
        name_choice = random.choice(list(IMMORTAL_ARTS[rarity_choice].keys()))
        new_art = {"name": name_choice, "rarity": rarity_choice}
        
        # Update slot
        meta = get_user_meta(member.id)
        if "immortal_arts" not in meta:
            meta["immortal_arts"] = {
                "slots": [None, None, None],
                "rerolls": 3,
                "unlocked_slots": max(1, slot)
            }
        
        meta["immortal_arts"]["slots"][slot - 1] = new_art
        meta["immortal_arts"]["unlocked_slots"] = max(meta["immortal_arts"]["unlocked_slots"], slot)
        set_user_meta(member.id, meta)
        
        embed = discord.Embed(title="🔄 Immortal Art Rerolled!", color=0x9b59b6)
        embed.description = f"Admin rerolled {member.mention}'s Slot {slot}"
        embed.add_field(name="New Art", value=f"**{name_choice}** ({rarity_choice.title()})", inline=True)
        embed.add_field(name="Slot", value=f"Slot {slot}", inline=True)
        embed.set_footer(text=f"Rerolled by {ctx.author.display_name}")
        
        await ctx.send(embed=embed)
        return
        
    elif action == "unlock":
        if slot < 2 or slot > 3:
            await ctx.send("You can only unlock slots 2 or 3.")
            return
            
        meta = get_user_meta(member.id)
        if "immortal_arts" not in meta:
            meta["immortal_arts"] = {
                "slots": [None, None, None],
                "rerolls": 3,
                "unlocked_slots": 1
            }
        
        meta["immortal_arts"]["unlocked_slots"] = max(meta["immortal_arts"]["unlocked_slots"], slot)
        set_user_meta(member.id, meta)
        
        embed = discord.Embed(title="🔓 Slot Unlocked", color=0x2ecc71)
        embed.description = f"Unlocked slot {slot} for {member.mention}."
        embed.set_footer(text=f"Unlocked by {ctx.author.display_name}")
        await ctx.send(embed=embed)
        return
        
    elif action == "set_rerolls":
        if rerolls is None:
            await ctx.send("Provide the number of rerolls to set.")
            return
        if rerolls < 0:
            await ctx.send("Rerolls cannot be negative.")
            return
            
        meta = get_user_meta(member.id)
        if "immortal_arts" not in meta:
            meta["immortal_arts"] = {
                "slots": [None, None, None],
                "rerolls": rerolls,
                "unlocked_slots": 1
            }
        else:
            meta["immortal_arts"]["rerolls"] = rerolls
        
        set_user_meta(member.id, meta)
        
        embed = discord.Embed(title="🎲 Rerolls Set", color=0x2ecc71)
        embed.description = f"Set {member.mention}'s immortal art rerolls to **{rerolls}**"
        embed.set_footer(text=f"Set by {ctx.author.display_name}")
        await ctx.send(embed=embed)
        return
        
    elif action == "reset":
        # Reset all immortal arts for the user
        meta = get_user_meta(member.id)
        meta["immortal_arts"] = {
            "slots": [None, None, None],
            "rerolls": 3,
            "unlocked_slots": 1
        }
        set_user_meta(member.id, meta)
        
        embed = discord.Embed(title="🔄 Immortal Arts Reset", color=0xe74c3c)
        embed.description = f"Reset all immortal arts for {member.mention}"
        embed.add_field(name="Status", value="All slots cleared, rerolls reset to 3, only slot 1 unlocked", inline=False)
        embed.set_footer(text=f"Set by {ctx.author.display_name}")
        await ctx.send(embed=embed)
        return
        
    await ctx.send("Unknown action. Use: view, set, reroll, unlock, set_rerolls, reset")


@bot.tree.command(name="collect_role", description="Admin: Set role income and cooldown, then collect immediately")
@app_commands.describe(
    role="The role to configure", 
    collect_amount="Amount of money to collect from this role", 
    cooldown_hours="Cooldown in hours between collections"
)
@app_commands.checks.has_permissions(administrator=True)
async def collect_role(interaction: discord.Interaction, role: discord.Role, collect_amount: int, cooldown_hours: int):
    """Set a role's income amount and cooldown, then collect income immediately. Admin only."""
    try:
        # Validate inputs
        if collect_amount < 0:
            await interaction.response.send_message("❌ Collect amount cannot be negative!", ephemeral=True)
            return
        
        if cooldown_hours < 0:
            await interaction.response.send_message("❌ Cooldown cannot be negative!", ephemeral=True)
            return
        
        # Load current income and cooldown data
        income_map = load_json(INCOME_FILE)
        cooldown_map = load_json(os.path.join(DATA_DIR, "role_cooldowns.json"))
        
        role_id = str(role.id)
        
        # Update income and cooldown for this role
        income_map[role_id] = collect_amount
        cooldown_map[role_id] = cooldown_hours
        
        # Save the updated data
        save_json(INCOME_FILE, income_map)
        save_json(os.path.join(DATA_DIR, "role_cooldowns.json"), cooldown_map)
        
        # Create success embed
        embed = discord.Embed(title="✅ Role Income Configured", color=0x2ecc71)
        embed.description = f"Successfully configured **{role.name}** role"
        
        embed.add_field(name="💰 Income Amount", value=f"{MONEY_ICON} {collect_amount:,} per collection", inline=True)
        embed.add_field(name="⏰ Cooldown", value=f"{cooldown_hours} hours", inline=True)
        
        # Show current role holders
        role_members = [member.display_name for member in role.members]
        if role_members:
            embed.add_field(name="👥 Current Role Holders", value=", ".join(role_members[:10]) + ("..." if len(role_members) > 10 else ""), inline=False)
        else:
            embed.add_field(name="👥 Current Role Holders", value="No members have this role yet", inline=False)
        
        embed.set_footer(text=f"Role ID: {role_id}")
        
        await interaction.response.send_message(embed=embed, ephemeral=True)
        
    except Exception as e:
        await interaction.response.send_message(f"❌ An error occurred: {str(e)}", ephemeral=True)


@bot.command(name="collect_role")
@commands.has_permissions(administrator=True)
async def collect_role_prefix(ctx, role: discord.Role, collect_amount: int, cooldown_hours: int):
    """Set a role's income amount and cooldown. Admin only. Use: ?collect_role @role <amount> <cooldown_hours>"""
    try:
        # Validate inputs
        if collect_amount < 0:
            await ctx.send("❌ Collect amount cannot be negative!")
            return
        
        if cooldown_hours < 0:
            await ctx.send("❌ Cooldown cannot be negative!")
            return
        
        # Load current income and cooldown data
        income_map = load_json(INCOME_FILE)
        cooldown_map = load_json(os.path.join(DATA_DIR, "role_cooldowns.json"))
        
        role_id = str(role.id)
        
        # Update income and cooldown for this role
        income_map[role_id] = collect_amount
        cooldown_map[role_id] = cooldown_hours
        
        # Save the updated data
        save_json(INCOME_FILE, income_map)
        save_json(os.path.join(DATA_DIR, "role_cooldowns.json"), cooldown_map)
        
        # Create success embed
        embed = discord.Embed(title="✅ Role Income Configured", color=0x2ecc71)
        embed.description = f"Successfully configured **{role.name}** role"
        
        embed.add_field(name="💰 Income Amount", value=f"{MONEY_ICON} {collect_amount:,} per collection", inline=True)
        embed.add_field(name="⏰ Cooldown", value=f"{cooldown_hours} hours", inline=True)
        
        # Show current role holders
        role_members = [member.display_name for member in role.members]
        if role_members:
            embed.add_field(name="👥 Current Role Holders", value=", ".join(role_members[:10]) + ("..." if len(role_members) > 10 else ""), inline=False)
        else:
            embed.add_field(name="👥 Current Role Holders", value="No members have this role yet", inline=False)
        
        embed.set_footer(text=f"Role ID: {role_id}")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await ctx.send(f"❌ An error occurred: {str(e)}")


@bot.command(name="remove_from_inventory")
@commands.has_permissions(administrator=True)
async def remove_from_inventory(ctx, member: discord.Member, item_name: str, amount: int = 1):
    """Remove items from a user's inventory. Admin only."""
    user_id = member.id
    meta = get_user_meta(user_id)
    inventory = meta.get("inventory", [])
    
    if not inventory:
        await ctx.send(f"{member.mention} has an empty inventory.")
        return
    
    # Find items by name (case-insensitive)
    found_items = []
    for i, item in enumerate(inventory):
        if isinstance(item, dict) and item.get("name", "").lower() == item_name.lower():
            found_items.append((i, item))
    
    if not found_items:
        await ctx.send(f"Could not find '{item_name}' in {member.mention}'s inventory.")
        return
    
    # Remove the specified amount
    removed_count = 0
    removed_items = []
    
    for i, item in found_items:
        if removed_count >= amount:
            break
        
        item_amount = item.get("amount", 1)
        if item_amount <= amount - removed_count:
            # Remove entire stack
            removed_item = inventory.pop(i)
            removed_items.append(removed_item)
            removed_count += item_amount
        else:
            # Remove partial stack
            remove_from_stack = amount - removed_count
            item["amount"] = item_amount - remove_from_stack
            removed_count += remove_from_stack
            
            # Create a copy for the removed items list
            removed_copy = item.copy()
            removed_copy["amount"] = remove_from_stack
            removed_items.append(removed_copy)
            break
    
    # Update inventory
    meta["inventory"] = inventory
    set_user_meta(user_id, meta)
    
    embed = discord.Embed(title="🗑️ Items Removed from Inventory", color=0xe74c3c)
    embed.description = f"Removed **{removed_count}** item(s) from {member.mention}'s inventory"
    
    for item in removed_items:
        embed.add_field(
            name=f"Removed: {item['name']}", 
            value=f"Type: {item['type'].title()}, Rarity: {item['rarity'].title()}", 
            inline=False
        )
    
    embed.set_footer(text=f"Removed by {ctx.author.display_name}")
    await ctx.send(embed=embed)








@bot.command(name="fix_sect_job_data")
@commands.has_permissions(administrator=True)
async def fix_sect_job_data(ctx):
    """Admin command to fix sect and job data files if they're corrupted"""
    try:
        await ctx.send("🔄 Checking and fixing sect and job data files...")
        
        # Check and fix sects file
        try:
            sects = load_json(SECTS_FILE)
            if not isinstance(sects, dict):
                await ctx.send("❌ Sects file is corrupted. Creating new one...")
                sects = {}
                save_json(SECTS_FILE, sects)
            else:
                await ctx.send(f"✅ Sects file is valid. Contains {len(sects)} sects.")
        except Exception as e:
            await ctx.send(f"❌ Error with sects file: {e}. Creating new one...")
            sects = {}
            save_json(SECTS_FILE, sects)
        
        # Check and fix jobs file
        try:
            jobs = load_json(JOBS_FILE)
            if not isinstance(jobs, dict):
                await ctx.send("❌ Jobs file is corrupted. Creating new one...")
                jobs = DEFAULT_JOBS.copy()
                save_json(JOBS_FILE, jobs)
            else:
                await ctx.send(f"✅ Jobs file is valid. Contains {len(jobs)} jobs.")
        except Exception as e:
            await ctx.send(f"❌ Error with jobs file: {e}. Creating new one...")
            jobs = DEFAULT_JOBS.copy()
            save_json(JOBS_FILE, jobs)
        
        await ctx.send("✅ Sect and job data files have been checked and fixed if needed!")
        
    except Exception as e:
        await ctx.send(f"❌ An error occurred while fixing data files: {str(e)}")





@bot.command(name="immortal_art_add")
@commands.has_permissions(administrator=True)
async def immortal_art_add(ctx, member: discord.Member, rarity: str, name: str = None, slot: int = None):
    """Add an immortal art to a user. Admin only.
    
    Rarities: common, uncommon, rare, legendary, mythic, divine
    """
    rarity = rarity.lower()
    
    if rarity not in IMMORTAL_ARTS:
        await ctx.send("Invalid rarity. Use: common, uncommon, rare, legendary, mythic, divine")
        return
    
    # If no name specified, choose random from that rarity
    if not name:
        name = random.choice(list(IMMORTAL_ARTS[rarity].keys()))
    elif name not in IMMORTAL_ARTS[rarity]:
        await ctx.send(f"'{name}' is not a valid {rarity} immortal art.")
        return
    
    # Get user's immortal arts data
    user_id = member.id
    meta = get_user_meta(user_id)
    
    if "immortal_arts" not in meta:
        meta["immortal_arts"] = {
            "slots": [None, None, None],
            "rerolls": 3,
            "unlocked_slots": 1
        }
    
    # If slot specified, add to that slot
    if slot is not None:
        if slot < 1 or slot > 3:
            await ctx.send("Slot must be 1, 2, or 3.")
            return
        
        # Unlock the slot if needed
        if slot > meta["immortal_arts"]["unlocked_slots"]:
            meta["immortal_arts"]["unlocked_slots"] = slot
        
        meta["immortal_arts"]["slots"][slot - 1] = {"name": name, "rarity": rarity}
        
        embed = discord.Embed(title="✨ Immortal Art Added to Slot", color=0x2ecc71)
        embed.description = f"Added **{name}** to {member.mention}'s Slot {slot}"
        embed.add_field(name="Art", value=name, inline=True)
        embed.add_field(name="Rarity", value=rarity.title(), inline=True)
        embed.add_field(name="Slot", value=f"Slot {slot}", inline=True)
        
    else:
        # Find first empty slot
        empty_slot = None
        for i, slot_data in enumerate(meta["immortal_arts"]["slots"]):
            if slot_data is None:
                empty_slot = i + 1
                break
        
        if empty_slot is None:
            # All slots full, replace the last one
            empty_slot = meta["immortal_arts"]["unlocked_slots"]
        
        # Unlock the slot if needed
        if empty_slot > meta["immortal_arts"]["unlocked_slots"]:
            meta["immortal_arts"]["unlocked_slots"] = empty_slot
        
        meta["immortal_arts"]["slots"][empty_slot - 1] = {"name": name, "rarity": rarity}
        
        embed = discord.Embed(title="✨ Immortal Art Added", color=0x2ecc71)
        embed.description = f"Added **{name}** to {member.mention}'s Slot {empty_slot}"
        embed.add_field(name="Art", value=name, inline=True)
        embed.add_field(name="Rarity", value=rarity.title(), inline=True)
        embed.add_field(name="Slot", value=f"Slot {empty_slot}", inline=True)
    
    set_user_meta(user_id, meta)
    embed.set_footer(text=f"Added by {ctx.author.display_name}")
    await ctx.send(embed=embed)





@bot.command(name="migrate_all_data")
@commands.has_permissions(administrator=True)
async def migrate_all_data(ctx):
    """Admin command to migrate all users from old system to new separate files"""
    try:
        guild = ctx.guild
        if not guild:
            await ctx.send("❌ This command must be used in a server.")
            return
        
        await ctx.send("🔄 Starting data migration for all users... This may take a moment.")
        
        migrated_count = 0
        total_members = len(guild.members)
        
        for member in guild.members:
            if member.bot:
                continue
                
            try:
                user_id = member.id
                if migrate_user_data_to_new_system(user_id):
                    migrated_count += 1
                    print(f"Migrated data for {member.display_name}")
                
            except Exception as e:
                print(f"Error migrating data for {member.display_name}: {e}")
                continue
        
        # Create success embed
        embed = discord.Embed(title="✅ Data Migration Complete!", color=0x2ecc71)
        embed.description = f"Successfully migrated data for **{migrated_count}** users"
        embed.add_field(name="Total Members", value=f"{total_members}", inline=True)
        embed.add_field(name="Users Migrated", value=f"{migrated_count}", inline=True)
        embed.add_field(name="What Was Migrated", value="• Inventory data\n• Equipment data\n• Attributes/stats\n• Sect membership\n• Job data\n• Immortal arts\n• Money and timestamps", inline=False)
        embed.add_field(name="New System", value="All data is now stored in separate, corruption-proof files!", inline=False)
        embed.set_footer(text=f"Migrated by {ctx.author.display_name}")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await ctx.send(f"❌ An error occurred: {str(e)}")


@bot.command(name="fix_all_user_data")
@commands.has_permissions(administrator=True)
async def fix_all_user_data(ctx):
    """Admin command to fix all users' sect, job, and inventory data"""
    try:
        guild = ctx.guild
        if not guild:
            await ctx.send("❌ This command must be used in a server.")
            return
        
        await ctx.send("🔄 Starting comprehensive data fix for all users... This may take a moment.")
        
        # Load sect data
        sects_data = load_json(SECTS_FILE)
        
        fixed_count = 0
        total_members = len(guild.members)
        
        for member in guild.members:
            if member.bot:
                continue
                
            try:
                user_id = member.id
                meta = get_user_meta(user_id)
                needs_fix = False
                
                # Check and fix inventory structure
                if not meta.get("inventory") or not isinstance(meta.get("inventory"), list):
                    meta["inventory"] = []
                    needs_fix = True
                
                # Check and fix equipment structure
                if not meta.get("equipment") or not isinstance(meta.get("equipment"), dict):
                    meta["equipment"] = {"weapon": None, "armor": None, "artifacts": []}
                    needs_fix = True
                
                # Check and fix attributes structure
                if not meta.get("attributes") or not isinstance(meta.get("attributes"), dict):
                    meta["attributes"] = {"strength": 0, "defence": 0, "longevity": 0, "luck": 0}
                    needs_fix = True
                
                # Check and fix sect data
                user_sect = meta.get("sect")
                actual_sect = None
                
                # Find which sect the user is actually in
                for sect_name, sect_data in sects_data.items():
                    if user_id in sect_data.get("members", []):
                        actual_sect = sect_name
                        break
                
                if actual_sect and not user_sect:
                    # User is in sect file but not in metadata - fix this
                    meta["sect"] = actual_sect
                    meta["sect_rank"] = sects_data[actual_sect].get("positions", {}).get(str(user_id), "outer disciple")
                    needs_fix = True
                elif user_sect and not actual_sect:
                    # User metadata shows sect but not in sect file - clear invalid data
                    meta["sect"] = None
                    meta["sect_rank"] = None
                    needs_fix = True
                
                # Check and fix job data
                if not meta.get("job"):
                    meta["job"] = None
                    needs_fix = True
                
                if not meta.get("selected_job"):
                    meta["selected_job"] = None
                    needs_fix = True
                
                # Save if any fixes were needed
                if needs_fix:
                    set_user_meta(user_id, meta)
                    fixed_count += 1
                    print(f"Fixed data for {member.display_name}")
                
            except Exception as e:
                print(f"Error fixing data for {member.display_name}: {e}")
                continue
        
        # Create success embed
        embed = discord.Embed(title="✅ All User Data Fixed!", color=0x2ecc71)
        embed.description = f"Successfully fixed data for **{fixed_count}** users"
        embed.add_field(name="Total Members", value=f"{total_members}", inline=True)
        embed.add_field(name="Users Fixed", value=f"{fixed_count}", inline=True)
        embed.add_field(name="What Was Fixed", value="• Inventory structure\n• Equipment structure\n• Attributes structure\n• Sect data consistency\n• Job data structure", inline=False)
        embed.set_footer(text=f"Fixed by {ctx.author.display_name}")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await ctx.send(f"❌ An error occurred: {str(e)}")


@bot.command(name="fix_my_sect")
async def fix_my_sect(ctx):
    """Fix your own sect data inconsistency"""
    try:
        user_id = ctx.author.id
        await ctx.send(f"🔧 Fixing sect data for {ctx.author.display_name}...")
        
        # Check user metadata
        meta = get_user_meta(user_id)
        user_sect = meta.get("sect")
        
        # Check sect files
        sects_data = load_json(SECTS_FILE)
        
        # Find which sect the user is actually in
        actual_sect = None
        for sect_name, sect_data in sects_data.items():
            if user_id in sect_data.get("members", []):
                actual_sect = sect_name
                break
        
        if actual_sect and not user_sect:
            # User is in sect file but not in metadata - fix this
            meta["sect"] = actual_sect
            meta["sect_rank"] = sects_data[actual_sect].get("positions", {}).get(str(user_id), "outer disciple")
            set_user_meta(user_id, meta)
            
            embed = discord.Embed(title="✅ Sect Data Fixed!", color=0x2ecc71)
            embed.description = f"Restored your sect membership to **{actual_sect}**"
            embed.add_field(name="Sect", value=actual_sect, inline=True)
            embed.add_field(name="Rank", value=meta["sect_rank"], inline=True)
            embed.set_footer(text="Your sect data is now consistent!")
            
        elif user_sect and actual_sect and user_sect != actual_sect:
            # User metadata shows different sect than sect file - fix this
            meta["sect"] = actual_sect
            meta["sect_rank"] = sects_data[actual_sect].get("positions", {}).get(str(user_id), "outer disciple")
            set_user_meta(user_id, meta)
            
            embed = discord.Embed(title="✅ Sect Data Fixed!", color=0x2ecc71)
            embed.description = f"Fixed sect mismatch. You are now properly in **{actual_sect}**"
            embed.add_field(name="Sect", value=actual_sect, inline=True)
            embed.add_field(name="Rank", value=meta["sect_rank"], inline=True)
            embed.set_footer(text="Your sect data is now consistent!")
            
        elif user_sect and not actual_sect:
            # User metadata shows sect but not in sect file - clear invalid data
            meta["sect"] = None
            meta["sect_rank"] = None
            set_user_meta(user_id, meta)
            
            embed = discord.Embed(title="✅ Sect Data Fixed!", color=0x2ecc71)
            embed.description = "Cleared invalid sect data. You are not in any sect."
            embed.add_field(name="Status", value="No sect membership", inline=True)
            embed.set_footer(text="You can now join a sect normally!")
            
        else:
            # Data is already consistent
            embed = discord.Embed(title="✅ Sect Data OK", color=0x2ecc71)
            embed.description = "Your sect data is already consistent!"
            if user_sect:
                embed.add_field(name="Sect", value=user_sect, inline=True)
                embed.add_field(name="Rank", value=meta.get("sect_rank", "Unknown"), inline=True)
            else:
                embed.add_field(name="Status", value="Not in any sect", inline=True)
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await ctx.send(f"❌ Error fixing sect data: {str(e)}")


@bot.command(name="diagnose_sect_issue")
async def diagnose_sect_issue(ctx):
    """Diagnose sect data inconsistency issues"""
    try:
        user_id = ctx.author.id
        await ctx.send(f"🔍 Diagnosing sect data for {ctx.author.display_name}...")
        
        # Check user metadata
        meta = get_user_meta(user_id)
        user_sect = meta.get("sect")
        user_sect_rank = meta.get("sect_rank")
        
        # Check sect files
        sects_data = load_json(SECTS_FILE)
        
        # Find which sect the user is in (if any)
        user_sect_membership = []
        for sect_name, sect_data in sects_data.items():
            if user_id in sect_data.get("members", []):
                user_sect_membership.append({
                    "name": sect_name,
                    "rank": sect_data.get("positions", {}).get(str(user_id), "member"),
                    "leader": sect_data.get("leader") == user_id
                })
        
        # Create diagnostic embed
        embed = discord.Embed(title="🔍 Sect Data Diagnosis", color=0xf39c12)
        embed.description = f"Diagnostic results for {ctx.author.display_name}"
        
        # User metadata section
        embed.add_field(
            name="📊 User Metadata", 
            value=f"**Sect:** {user_sect or 'None'}\n**Rank:** {user_sect_rank or 'None'}", 
            inline=True
        )
        
        # Sect file section
        if user_sect_membership:
            sect_info = "\n".join([
                f"• **{sect['name']}** - {sect['rank']} {'👑' if sect['leader'] else ''}"
                for sect in user_sect_membership
            ])
            embed.add_field(
                name="🏯 Sect File Data", 
                value=sect_info, 
                inline=True
            )
        else:
            embed.add_field(
                name="🏯 Sect File Data", 
                value="Not found in any sect", 
                inline=True
            )
        
        # Analysis
        if user_sect and user_sect_membership:
            if any(sect["name"] == user_sect for sect in user_sect_membership):
                analysis = "✅ Data is consistent - user is properly in sect"
                embed.color = 0x2ecc71
            else:
                analysis = "❌ Data mismatch - user metadata shows different sect than sect file"
                embed.color = 0xe74c3c
        elif user_sect and not user_sect_membership:
            analysis = "❌ User metadata shows sect but not found in sect file"
            embed.color = 0xe74c3c
        elif not user_sect and user_sect_membership:
            analysis = "❌ Sect file shows membership but user metadata shows no sect"
            embed.color = 0xe74c3c
        else:
            analysis = "✅ User is not in any sect (consistent)"
            embed.color = 0x2ecc71
        
        embed.add_field(name="🔍 Analysis", value=analysis, inline=False)
        
        # Recommendations
        if not user_sect and user_sect_membership:
            recommendations = "**Fix:** Run `?fix_sect_job_data` to repair data files"
        elif user_sect and not user_sect_membership:
            recommendations = "**Fix:** Clear invalid sect data with `?sect_leave`"
        else:
            recommendations = "**Status:** Data appears consistent"
        
        embed.add_field(name="💡 Recommendations", value=recommendations, inline=False)
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await ctx.send(f"❌ Error during diagnosis: {str(e)}")


@bot.command(name="restore_user_data")
@commands.has_permissions(administrator=True)
async def restore_user_data(ctx, user: discord.Member, restore_type: str = "all"):
    """Admin command to restore lost user data (inventory, equipment, stats, etc.)"""
    try:
        await ctx.send(f"🔄 Restoring data for {user.display_name}...")
        
        user_id = user.id
        meta = get_user_meta(user_id)
        
        # Check what data is missing
        missing_data = []
        
        if not meta.get("inventory") or len(meta.get("inventory", [])) == 0:
            missing_data.append("inventory")
        
        if not meta.get("equipment") or not isinstance(meta.get("equipment"), dict):
            missing_data.append("equipment")
        
        if not meta.get("attributes") or not isinstance(meta.get("attributes"), dict):
            missing_data.append("attributes")
        
        if not meta.get("sect"):
            missing_data.append("sect")
        
        if not meta.get("job"):
            missing_data.append("job")
        
        if not missing_data:
            await ctx.send(f"✅ {user.display_name} has all data intact!")
            return
        
        await ctx.send(f"🔍 Missing data detected: {', '.join(missing_data)}")
        
        # Restore missing data
        restored_count = 0
        
        # Restore inventory if missing
        if "inventory" in missing_data:
            meta["inventory"] = []
            restored_count += 1
        
        # Restore equipment if missing
        if "equipment" in missing_data:
            meta["equipment"] = {"weapon": None, "armor": None, "artifacts": []}
            restored_count += 1
        
        # Restore attributes if missing
        if "attributes" in missing_data:
            meta["attributes"] = {"strength": 0, "defence": 0, "longevity": 0, "luck": 0}
            restored_count += 1
        
        # Note: Can't restore sect/job without user choosing them
        
        # Save restored data
        set_user_meta(user_id, meta)
        
        embed = discord.Embed(title="✅ Data Restoration Complete", color=0x2ecc71)
        embed.description = f"Restored {restored_count} data categories for {user.display_name}"
        embed.add_field(name="Restored", value="\n".join([f"• {item.title()}" for item in missing_data if item in ["inventory", "equipment", "attributes"]]), inline=True)
        embed.add_field(name="Still Missing", value="\n".join([f"• {item.title()}" for item in missing_data if item in ["sect", "job"]]), inline=True)
        embed.add_field(name="Next Steps", value="User should:\n• Join a sect with `/sect_join`\n• Select a job with `/selectjob`\n• Re-equip items from inventory", inline=False)
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await ctx.send(f"❌ An error occurred: {str(e)}")





@bot.command(name="sect_set_boost")
@app_commands.autocomplete(sect_name=sect_name_autocomplete)
@commands.has_permissions(administrator=True)
async def sect_set_boost(ctx, sect_name: str, boost_percent: int):
    data = load_json(SECTS_FILE)
    if sect_name not in data:
        await send_embed(ctx, "Sect Boost", "That sect does not exist.", 0xe74c3c)
        return
    boost_percent = max(0, min(1000, int(boost_percent)))
    data[sect_name]["boost_percent"] = boost_percent
    save_json(SECTS_FILE, data)
    await send_embed(ctx, "Sect Boost", f"Set boost for {sect_name} to {boost_percent}%.", 0x2ecc71)


@bot.command(name="loot_role_chance")
@commands.has_permissions(administrator=True)
@app_commands.autocomplete(rarity=rarity_autocomplete, min_rarity=rarity_autocomplete)
async def loot_role_chance(ctx, role: discord.Role, chance_bonus: int, rarity: str = None, rarity_chance: int = None, min_rarity: str = None):
    """Set the cultivation loot chance bonus for a specific role with optional rarity control"""
    loot_roles = load_json(LOOT_ROLES_FILE)
    
    # Validate chance bonus (can be negative for penalties)
    chance_bonus = max(-100, min(100, int(chance_bonus)))
    
    # Validate rarity if provided
    if rarity and rarity.lower() not in RARITY_LIST:
        await send_embed(ctx, "Invalid Rarity", f"Valid rarities: {', '.join(RARITY_LIST)}", 0xe74c3c)
        return
    
    # Validate min_rarity if provided
    if min_rarity and min_rarity.lower() not in RARITY_LIST:
        await send_embed(ctx, "Invalid Minimum Rarity", f"Valid rarities: {', '.join(RARITY_LIST)}", 0xe74c3c)
        return
    
    # Validate rarity chance if provided
    if rarity_chance is not None:
        rarity_chance = max(0, min(100, int(rarity_chance)))
    
    # Create role data structure
    role_data = {
        "chance_bonus": chance_bonus
    }
    
    # Add rarity settings if provided
    if rarity:
        role_data["forced_rarity"] = rarity.lower()
    if rarity_chance is not None:
        role_data["rarity_chance"] = rarity_chance
    if min_rarity:
        role_data["min_rarity"] = min_rarity.lower()
    
    # If all values are default/empty, remove the role
    if chance_bonus == 0 and not rarity and rarity_chance is None:
        if str(role.id) in loot_roles:
            del loot_roles[str(role.id)]
            await ctx.send(f"Removed all loot settings for {role.mention}.")
        else:
            await ctx.send(f"{role.mention} has no loot settings.")
        save_json(LOOT_ROLES_FILE, loot_roles)
        return
    
    # Set the role data
    loot_roles[str(role.id)] = role_data
    save_json(LOOT_ROLES_FILE, loot_roles)
    
    # Calculate final chance
    base_chance = 25  # 25% base chance
    final_chance = min(100, max(0, base_chance + chance_bonus))
    
    embed = discord.Embed(title="Loot Role Settings Updated", color=0x2ecc71)
    embed.description = f"**Role:** {role.mention}"
    
    # Add fields for each setting
    fields = []
    
    # Chance bonus field
    if chance_bonus != 0:
        fields.append(f"**Chance Bonus:** {chance_bonus:+d}% → **Final Chance:** {final_chance}%")
    if chance_bonus > 0:
            fields.append(f"✅ Increased loot chance by {chance_bonus}%")
    else:
            fields.append(f"❌ Decreased loot chance by {abs(chance_bonus)}%")
    
    # Forced rarity field
    if rarity:
        fields.append(f"**Forced Rarity:** {rarity.title()}")
        fields.append(f"🎯 All loot will be {rarity.title()} rarity")
    
    # Rarity chance field
    if rarity_chance is not None:
        fields.append(f"**Rarity Chance:** {rarity_chance}%")
        if rarity_chance == 100:
            fields.append(f"💎 Guaranteed {rarity.title() if rarity else 'highest'} rarity")
        elif rarity_chance == 0:
            fields.append(f"🚫 No {rarity.title() if rarity else 'high'} rarity loot")
        else:
            fields.append(f"🎲 {rarity_chance}% chance for {rarity.title() if rarity else 'high'} rarity")
    
    embed.add_field(name="Settings", value="\n".join(fields), inline=False)
    
    await ctx.send(embed=embed)


@bot.command(name="set_attributes")
@commands.has_permissions(administrator=True)
async def set_attributes(ctx, member: discord.Member, strength: int = None, luck: int = None, longevity: int = None, defence: int = None):
    """Set specific attribute values for a user. Admin only. Leave attribute as None to keep current value."""
    meta = get_user_meta(member.id)
    
    # Initialize attributes if they don't exist
    if "attributes" not in meta:
        meta["attributes"] = {
            "strength": 0,
            "luck": 0,
            "longevity": 0,
            "defence": 0
        }
    
    # Get current values
    current_attrs = meta["attributes"]
    
    # Update only the attributes that were specified
    if strength is not None:
        if strength < 0:
            await ctx.send("Strength cannot be negative.")
            return
        current_attrs["strength"] = strength
    
    if luck is not None:
        if luck < 0:
            await ctx.send("Luck cannot be negative.")
            return
        current_attrs["luck"] = luck
    
    if longevity is not None:
        if longevity < 0:
            await ctx.send("Longevity cannot be negative.")
            return
        current_attrs["longevity"] = longevity
    
    if defence is not None:
        if defence < 0:
            await ctx.send("Defence cannot be negative.")
            return
        current_attrs["defence"] = defence
    
    # Save the updated attributes
    meta["attributes"] = current_attrs
    set_user_meta(member.id, meta)
    
    # Create embed showing the changes
    embed = discord.Embed(title="🎯 Attributes Set", color=0x9b59b6)
    embed.description = f"Updated {member.mention}'s attributes:"
    
    # Show all attributes
    embed.add_field(name="⚔️ Strength", value=f"**{current_attrs['strength']}** points", inline=True)
    embed.add_field(name="🍀 Luck", value=f"**{current_attrs['luck']}** points", inline=True)
    embed.add_field(name="❤️ Longevity", value=f"**{current_attrs['longevity']}** points", inline=True)
    embed.add_field(name="🛡️ Defence", value=f"**{current_attrs['defence']}** points", inline=True)
    
    total_points = sum(current_attrs.values())
    embed.add_field(name="Total Points", value=f"**{total_points}**", inline=False)
    
    await ctx.send(embed=embed)


@bot.command(name="rig_immortal_art_role")
@commands.has_permissions(administrator=True)
@app_commands.autocomplete(rarity=rarity_autocomplete)
async def rig_immortal_art_role(ctx, role: discord.Role, rarity: str, chance_percent: int = 100, duration_hours: int = 24):
    """Rig a role's Immortal Art chances to get a specific rarity. Admin only."""
    if rarity.lower() not in RARITY_LIST:
        await ctx.send(f"Invalid rarity. Valid rarities: {', '.join(RARITY_LIST)}")
        return
    
    if chance_percent < 1 or chance_percent > 100:
        await ctx.send("Chance percent must be between 1 and 100")
        return
    
    if duration_hours < 1 or duration_hours > 168:  # Max 1 week
        await ctx.send("Duration must be between 1 and 168 hours (1 week)")
        return
    
    # Store the rigged Immortal Art data
    rigged_data = {
        "rarity": rarity.lower(),
        "chance_percent": chance_percent,
        "expires": (datetime.now(timezone.utc) + timedelta(hours=duration_hours)).isoformat(),
        "admin": ctx.author.id
    }
    
    # Load existing role Immortal Art settings
    immortal_art_roles = load_json(LOOT_ROLES_FILE)  # Reuse the same file for simplicity
    
    if str(role.id) not in immortal_art_roles:
        immortal_art_roles[str(role.id)] = {}
    
    immortal_art_roles[str(role.id)]["immortal_art_rig"] = rigged_data
    save_json(LOOT_ROLES_FILE, immortal_art_roles)
    
    embed = discord.Embed(title="🎭 Immortal Art Role Rigged!", color=0xe74c3c)
    embed.description = f"**{role.mention}** members will now have **{chance_percent}%** chance to get **{rarity.title()}** rarity Immortal Arts!"
    embed.add_field(name="Duration", value=f"⏰ {duration_hours} hours", inline=True)
    
    # Calculate expiration timestamp for Discord timestamp
    expires_time = datetime.fromisoformat(rigged_data['expires'])
    embed.add_field(name="Expires", value=f"<t:{int(expires_time.timestamp())}:R> at <t:{int(expires_time.timestamp())}:t>", inline=True)
    embed.set_footer(text=f"Rigged by {ctx.author.display_name}")
    
    await ctx.send(embed=embed)


@bot.command(name="clear_rig")
@commands.has_permissions(administrator=True)
async def clear_rig(ctx, target: discord.Member = None, role: discord.Role = None):
    """Clear rigged settings for a user or role. Admin only."""
    if not target and not role:
        await send_embed(ctx, "Clear Rig", "Please specify either a user or a role to clear rigged settings for.", 0xe74c3c)
        return
    
    if target and role:
        await send_embed(ctx, "Clear Rig", "Please specify only one target (either user or role), not both.", 0xe74c3c)
        return
    
    if target:
        # Clear user's rigged reroll
        meta = get_user_meta(target.id)
        if "rigged_reroll" in meta:
            del meta["rigged_reroll"]
            set_user_meta(target.id, meta)
            await send_embed(ctx, "Rig Cleared", f"Cleared rigged reroll settings for {target.mention}.", 0x2ecc71)
        else:
            await send_embed(ctx, "No Rig", f"{target.mention} has no rigged reroll settings.", 0xf1c40f)
    
    elif role:
        # Clear role's rigged Immortal Art
        immortal_art_roles = load_json(LOOT_ROLES_FILE)
        if str(role.id) in immortal_art_roles and "immortal_art_rig" in immortal_art_roles[str(role.id)]:
            del immortal_art_roles[str(role.id)]["immortal_art_rig"]
            save_json(LOOT_ROLES_FILE, immortal_art_roles)
            await send_embed(ctx, "Rig Cleared", f"Cleared rigged Immortal Art settings for {role.mention}.", 0x2ecc71)
        else:
            await send_embed(ctx, "No Rig", f"{role.mention} has no rigged Immortal Art settings.", 0xf1c40f)


@bot.command(name="set_rerolls")
@commands.has_permissions(administrator=True)
async def set_rerolls_admin(ctx, member: discord.Member, rerolls: int):
    """Set the number of immortal art rerolls for a user. Admin only."""
    if rerolls < 0:
        await send_embed(ctx, "Invalid Rerolls", "Rerolls cannot be negative.", 0xe74c3c)
        return
        
    meta = get_user_meta(member.id)
    if "immortal_arts" not in meta:
        meta["immortal_arts"] = {
            "slots": [None, None, None],
            "rerolls": rerolls,
            "unlocked_slots": 1
        }
    else:
        meta["immortal_arts"]["rerolls"] = rerolls
    
    set_user_meta(member.id, meta)
    
    embed = discord.Embed(title="🎲 Rerolls Set", color=0x9b59b6)
    embed.description = f"Set {member.mention}'s immortal art rerolls to **{rerolls}**"
    embed.set_footer(text=f"Set by {ctx.author.display_name}")
    await ctx.send(embed=embed)


@bot.command(name="immortal_art_set")
@commands.has_permissions(administrator=True)
async def immortal_art_set_admin(ctx, member: discord.Member, slot: int, rarity: str, name: str):
    """Set a specific immortal art for a user in a specific slot. Admin only."""
    if slot < 1 or slot > 3:
        await send_embed(ctx, "Invalid Slot", "Slot must be 1, 2, or 3.", 0xe74c3c)
        return
    
    if rarity.lower() not in IMMORTAL_ARTS:
        await send_embed(ctx, "Invalid Rarity", f"Valid rarities: {', '.join(IMMORTAL_ARTS.keys())}", 0xe74c3c)
        return
    
    if name not in IMMORTAL_ARTS[rarity.lower()]:
        await send_embed(ctx, "Invalid Art Name", f"'{name}' not found in {rarity} rarity arts.", 0xe74c3c)
        return
    
    # Set the art in the specified slot
    meta = get_user_meta(member.id)
    if "immortal_arts" not in meta:
        meta["immortal_arts"] = {
            "slots": [None, None, None],
            "rerolls": 3,
            "unlocked_slots": max(1, slot)
        }
    
    meta["immortal_arts"]["slots"][slot - 1] = {"name": name, "rarity": rarity.lower()}
    meta["immortal_arts"]["unlocked_slots"] = max(meta["immortal_arts"]["unlocked_slots"], slot)
    set_user_meta(member.id, meta)
    
    embed = discord.Embed(title="✨ Immortal Art Set", color=0x9b59b6)
    embed.description = f"Set {member.mention}'s **Slot {slot}** to **{name}** ({rarity.title()})"
    embed.set_footer(text=f"Set by {ctx.author.display_name}")
    await ctx.send(embed=embed)


@bot.command(name="view_rigs")
@commands.has_permissions(administrator=True)
async def view_rigs(ctx):
    """View all current rigged settings. Admin only."""
    embed = discord.Embed(title="🎭 Current Rigged Settings", color=0xe74c3c)
    
    # Check for user rigged rerolls
    user_rigs = []
    # This would require scanning all users, so we'll just show a note
    embed.add_field(name="User Reroll Rigs", value="Use `/clear_rig @user` to clear individual user rigs", inline=False)
    
    # Check for role immortal art rigs
    loot_roles = load_json(LOOT_ROLES_FILE)
    role_rigs = []
    
    for role_id_str, role_data in loot_roles.items():
        if isinstance(role_data, dict) and "immortal_art_rig" in role_data:
            rig_data = role_data["immortal_art_rig"]
            try:
                role = ctx.guild.get_role(int(role_id_str))
                role_name = role.mention if role else f"Role {role_id_str}"
                
                expires_time = datetime.fromisoformat(rig_data["expires"])
                time_remaining = expires_time - datetime.now(timezone.utc)
                
                if time_remaining.total_seconds() > 0:
                    role_rigs.append(f"{role_name}: **{rig_data['rarity'].title()}** ({rig_data['chance_percent']}%) - Expires <t:{int(expires_time.timestamp())}:R> at <t:{int(expires_time.timestamp())}:t>")
                else:
                    # Expired rig, mark for cleanup
                    role_rigs.append(f"{role_name}: **{rig_data['rarity'].title()}** ({rig_data['chance_percent']}%) - ⏰ EXPIRED")
            except (ValueError, TypeError, KeyError):
                # Invalid data, mark for cleanup
                role_rigs.append(f"Role {role_id_str}: Invalid data - ⚠️ CORRUPTED")
    
    if role_rigs:
        embed.add_field(name="Role Immortal Art Rigs", value="\n".join(role_rigs), inline=False)
    else:
        embed.add_field(name="Role Immortal Art Rigs", value="No active role rigs", inline=False)
    
    embed.set_footer(text="Use /clear_rig to remove rigged settings")
    await ctx.send(embed=embed)


# -----------------------
# Blackjack - Numbers Only, Always Show Hands, Instant Bust
# -----------------------

class BlackjackView(discord.ui.View):
    def __init__(self, ctx, bet_amt, player_hand, dealer_hand, deck):
        super().__init__(timeout=120)
        self.ctx = ctx
        self.bet = int(bet_amt)
        self.player_hand = player_hand
        self.dealer_hand = dealer_hand  # [hole, up]
        self.deck = deck
        self.resolved = False
        self.message = None
        self.first_action = True
        self.dealer_hole_hidden = True
        self.insurance_taken = False
        self.insurance_bet = 0

    def _rank_value(self, rank):
        if rank in ("J", "Q", "K"):
            return 10
        if rank == "A":
            return 11
        return int(rank)

    def evaluate_hand(self, hand):
        total = 0
        aces = 0
        for card in hand:
            rank = card[:-1]
            v = self._rank_value(rank)
            total += v
            if rank == "A":
                aces += 1
        # make soft adjustments
        soft = False
        while total > 21 and aces:
            total -= 10
            aces -= 1
        if aces > 0 and total <= 21:
            soft = True
        return total, soft

    def hand_value(self, hand):
        return self.evaluate_hand(hand)[0]

    def _display_value(self, rank):
        if rank in ("J", "Q", "K"):
            return "10"
        if rank == "A":
            return "A/11"
        return rank

    def hand_display_numbers(self, hand, hide_hole=False):
        if hide_hole and len(hand) >= 2:
            up = self._display_value(hand[1][:-1])
            return f"?? {up}"
        return " ".join(self._display_value(c[:-1]) for c in hand)

    async def finalize(self, interaction=None):
        if self.resolved:
            return
        
        try:
            self.resolved = True
            self.dealer_hole_hidden = False

            player_val, _ = self.evaluate_hand(self.player_hand)
            dealer_val, dealer_soft = self.evaluate_hand(self.dealer_hand)

            payout = 0
            result_label = "LOSE"

            # Dealer draws to 17 (standard blackjack rules)
            dealer_draw_threshold = 17
            
            # 15% chance dealer gets "lucky" and draws to 18 (house edge)
            if random.random() < 0.15:
                dealer_draw_threshold = 18
            
            while (dealer_val < dealer_draw_threshold or (dealer_val == dealer_draw_threshold and dealer_soft)) and self.deck:
                self.dealer_hand.append(self.deck.pop())
                dealer_val, dealer_soft = self.evaluate_hand(self.dealer_hand)

            # Natural blackjack checks
            player_blackjack = (len(self.player_hand) == 2 and player_val == 21)
            dealer_blackjack = (len(self.dealer_hand) == 2 and dealer_val == 21)

            if player_blackjack and not dealer_blackjack:
                base_payout = int(self.bet * 2.5)  # 3:2
                
                # Apply luck attribute bonus (1% per luck point)
                try:
                    attributes, _ = get_user_attributes(self.ctx.author.id)
                    luck_bonus = attributes.get("luck", 0) * 0.01  # +1% per luck point
                    if luck_bonus > 0:
                        base_payout = int(base_payout * (1 + luck_bonus))
                except Exception as e:
                    print(f"ERROR getting user attributes for {self.ctx.author.id}: {e}")
                    luck_bonus = 0
                
                try:
                    final_payout, bonus = apply_gambling_payout_bonus(self.ctx.author.id, base_payout, "blackjack")
                    payout = final_payout
                except Exception as e:
                    print(f"ERROR applying gambling payout bonus for {self.ctx.author.id}: {e}")
                    payout = base_payout
                    bonus = 0
                
                result_label = "BLACKJACK"
            elif dealer_blackjack and not player_blackjack:
                # Insurance removed — no side payouts
                result_label = "LOSE"
            else:
                if player_val > 21:
                    result_label = "LOSE"
                elif dealer_val > 21:
                    # Dealer busted - player wins
                    base_payout = self.bet * 2
                    
                    # Apply luck attribute bonus (1% per luck point)
                    try:
                        attributes, _ = get_user_attributes(self.ctx.author.id)
                        luck_bonus = attributes.get("luck", 0) * 0.01  # +1% per luck point
                        if luck_bonus > 0:
                            base_payout = int(base_payout * (1 + luck_bonus))
                    except Exception as e:
                        print(f"ERROR getting user attributes for {self.ctx.author.id}: {e}")
                        luck_bonus = 0
                    
                    try:
                        final_payout, bonus = apply_gambling_payout_bonus(self.ctx.author.id, base_payout, "blackjack")
                        payout = final_payout
                    except Exception as e:
                        print(f"ERROR applying gambling payout bonus for {self.ctx.author.id}: {e}")
                        payout = base_payout
                        bonus = 0
                    
                    result_label = "WON"
                elif player_val > dealer_val:
                    # Player has higher value than dealer
                    base_payout = self.bet * 2
                    
                    # Apply luck attribute bonus (1% per luck point)
                    try:
                        attributes, _ = get_user_attributes(self.ctx.author.id)
                        luck_bonus = attributes.get("luck", 0) * 0.01  # +1% per luck point
                        if luck_bonus > 0:
                            base_payout = int(base_payout * (1 + luck_bonus))
                    except Exception as e:
                        print(f"ERROR getting user attributes for {self.ctx.author.id}: {e}")
                        luck_bonus = 0
                    
                    try:
                        final_payout, bonus = apply_gambling_payout_bonus(self.ctx.author.id, base_payout, "blackjack")
                        payout = final_payout
                    except Exception as e:
                        print(f"ERROR applying gambling payout bonus for {self.ctx.author.id}: {e}")
                        payout = base_payout
                        bonus = 0
                    
                    result_label = "WON"
                elif player_val == dealer_val:
                    payout = self.bet
                    result_label = "PUSH"
                else:
                    result_label = "LOSE"

            if payout:
                try:
                    add_cash(self.ctx.author.id, payout)
                except Exception as e:
                    print(f"ERROR adding cash for {self.ctx.author.id}: {e}")
                


            # Colors
            color_map = {"WON": 0x2ecc71, "BLACKJACK": 0x2ecc71, "LOSE": 0xff0000, "PUSH": 0xF1C40F}
            color = color_map.get(result_label, 0x1f8b4c)

            # Build result string
            if result_label in ("WON", "BLACKJACK"):
                amount_str = f"+{MONEY_ICON} {payout:,}"
                if 'bonus' in locals() and bonus > 0:
                    amount_str += f"\n**Immortal Art bonus: +{MONEY_ICON} {bonus:,}**"
            elif result_label == "PUSH":
                amount_str = f"Returned {MONEY_ICON} {payout:,}"
            else:
                amount_str = f"-{MONEY_ICON} {self.bet:,}"

            # Embed
            embed = discord.Embed(title=f"Blackjack — {result_label}", color=color)
            embed.add_field(name="Your Hand", value=f"{self.hand_display_numbers(self.player_hand)}\nValue: {player_val}", inline=False)
            embed.add_field(name="Dealer Hand", value=f"{self.hand_display_numbers(self.dealer_hand)}\nValue: {dealer_val}", inline=False)
            embed.add_field(name="Result", value=amount_str, inline=False)
            embed.set_footer(text=f"Cards remaining: {len(self.deck)}")

            # Disable buttons
            for child in self.children:
                child.disabled = True

            # Update message
            if interaction:
                await interaction.response.edit_message(embed=embed, view=self)
            elif self.message:
                await self.message.edit(embed=embed, view=self)
                
        except Exception as e:
            print(f"ERROR in blackjack finalize for user {self.ctx.author.id}: {e}")
            # Try to send error message
            try:
                if interaction:
                    await interaction.response.send_message("An error occurred while finalizing the game. Please try again.", ephemeral=True)
                elif self.message:
                    await self.message.reply("An error occurred while finalizing the game. Please try again.")
            except:
                pass

    async def update_embed(self, interaction=None):
        try:
            p_val = self.hand_value(self.player_hand)
            d_val = self.hand_value(self.dealer_hand) if not self.dealer_hole_hidden else "?"
            embed = discord.Embed(title="Blackjack", color=0x1f8b4c)
            embed.add_field(name="Your Hand", value=f"{self.hand_display_numbers(self.player_hand)}\nValue: {p_val}", inline=False)
            embed.add_field(name="Dealer Hand", value=f"{self.hand_display_numbers(self.dealer_hand, hide_hole=self.dealer_hole_hidden)}\nValue: {d_val}", inline=False)
            embed.set_footer(text=f"Cards remaining: {len(self.deck)}")
            if interaction:
                await interaction.response.edit_message(embed=embed, view=self)
            elif self.message:
                await self.message.edit(embed=embed, view=self)
        except Exception as e:
            print(f"ERROR in blackjack update_embed for user {self.ctx.author.id}: {e}")
            try:
                if interaction:
                    await interaction.response.send_message("An error occurred while updating the game. Please try again.", ephemeral=True)
            except:
                pass

    async def on_timeout(self):
        if not self.resolved:
            try:
                await self.finalize()
            except Exception as e:
                print(f"ERROR in blackjack timeout for user {self.ctx.author.id}: {e}")
                try:
                    if self.message:
                        await self.message.reply("Game timed out due to an error. Please start a new game.")
                except:
                    pass

    @discord.ui.button(label="Hit", style=discord.ButtonStyle.primary)
    async def hit(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.ctx.author:
            return await interaction.response.send_message("This is not your game.", ephemeral=True)
        
        try:
            self.player_hand.append(self.deck.pop())
            self.first_action = False
            player_val = self.hand_value(self.player_hand)
            
            # Auto-resolve if player hits 21 or busts
            if player_val >= 21:
                self.dealer_hole_hidden = False
                return await self.finalize(interaction)
            
            await self.update_embed(interaction)
        except Exception as e:
            print(f"ERROR in hit button for user {self.ctx.author.id}: {e}")
            await interaction.response.send_message("An error occurred while processing hit. Please try again.", ephemeral=True)

    @discord.ui.button(label="Stand", style=discord.ButtonStyle.success)
    async def stand(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.ctx.author:
            return await interaction.response.send_message("This is not your game.", ephemeral=True)
        
        try:
            self.dealer_hole_hidden = False
            await self.finalize(interaction)
        except Exception as e:
            print(f"ERROR in stand button for user {self.ctx.author.id}: {e}")
            await interaction.response.send_message("An error occurred while processing stand. Please try again.", ephemeral=True)

    @discord.ui.button(label="Double", style=discord.ButtonStyle.secondary)
    async def doubledown(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user != self.ctx.author:
            return await interaction.response.send_message("This is not your game.", ephemeral=True)
        if not self.first_action:
            return await interaction.response.send_message("Double is only available on your first action.", ephemeral=True)
        
        try:
            cash, _ = get_balances(self.ctx.author.id)
            if cash < self.bet:
                return await interaction.response.send_message("You don't have enough to double.", ephemeral=True)
            add_cash(self.ctx.author.id, -self.bet)
            self.bet *= 2
            self.player_hand.append(self.deck.pop())
            self.dealer_hole_hidden = False
            return await self.finalize(interaction)
        except Exception as e:
            print(f"ERROR in double down button for user {self.ctx.author.id}: {e}")
            await interaction.response.send_message("An error occurred while processing double down. Please try again.", ephemeral=True)



    # Insurance removed by request


@bot.hybrid_command(name="blackjack", description="Play blackjack", aliases=["bj"])
@app_commands.autocomplete(bet=amount_autocomplete)
async def blackjack_cmd(ctx, bet: str):
    try:
        cash, _ = get_balances(ctx.author.id)
        bet_amt = parse_amount_arg(bet, cash)
        if bet_amt is None or bet_amt <= 0:
            return await send_embed(ctx, "Blackjack", "Invalid bet amount.", 0xe74c3c)
        if bet_amt > cash:
            return await send_embed(ctx, "Blackjack", "Not enough money.", 0xe74c3c)

        add_cash(ctx.author.id, -bet_amt)

        suits = ["S", "H", "D", "C"]
        ranks = [str(n) for n in range(2, 11)] + ["J", "Q", "K", "A"]
        deck = [r + s for r in ranks for s in suits]
        
        # NERF: Implement house edge by rigging the deck to favor dealer
        # Add extra low cards (2-6) and reduce high cards (10-A) to decrease player win rate
        house_edge_cards = []
        for _ in range(8):  # Add 8 extra low cards
            house_edge_cards.append(random.choice(["2S", "3S", "4S", "5S", "6S", "2H", "3H", "4H", "5H", "6H", "2D", "3D", "4D", "5D", "6D", "2C", "3C", "4C", "5C", "6C"]))
        
        deck.extend(house_edge_cards)
        random.shuffle(deck)

        # Dealer hand is [hole, up]
        dealer_hand = [deck.pop(), deck.pop()]
        player_hand = [deck.pop(), deck.pop()]
        
        # NERF: 15% chance dealer gets "lucky" and gets better starting cards
        if random.random() < 0.15:
            # Replace dealer's hole card with a better one if possible
            if len(deck) > 0:
                current_hole_value = int(dealer_hand[0][:-1]) if dealer_hand[0][:-1].isdigit() else (10 if dealer_hand[0][:-1] in ["J", "Q", "K"] else 11)
                if current_hole_value < 8:  # Only replace if current hole card is low
                    # Look for a better card (8 or higher)
                    for i, card in enumerate(deck):
                        card_value = int(card[:-1]) if card[:-1].isdigit() else (10 if card[:-1] in ["J", "Q", "K"] else 11)
                        if card_value >= 8:
                            # Swap the cards
                            deck[i] = dealer_hand[0]
                            dealer_hand[0] = card
                            break

        view = BlackjackView(ctx, bet_amt, player_hand, dealer_hand, deck)
        embed = discord.Embed(title="Blackjack", color=0x1f8b4c)
        embed.add_field(name="Your Hand",
                        value=f"{view.hand_display_numbers(player_hand)}\nValue: {view.hand_value(player_hand)}",
                        inline=False)
        # Show dealer upcard only
        embed.add_field(name="Dealer Hand",
                        value=f"{view.hand_display_numbers(dealer_hand, hide_hole=True)}\nValue: ?",
                        inline=False)
        embed.set_footer(text=f"Cards remaining: {len(deck)}")

        msg = await ctx.send(embed=embed, view=view)
        view.message = msg

        # Natural blackjack immediate resolve if dealer upcard not Ace (to allow insurance)
        player_val = view.hand_value(player_hand)
        dealer_up = dealer_hand[1][:-1]
        ten_values = {"10", "J", "Q", "K"}
        if player_val == 21 and dealer_up not in ten_values and dealer_up != "A":
            view.dealer_hole_hidden = False
            await view.finalize()
            
    except Exception as e:
        print(f"ERROR in blackjack command for user {ctx.author.id}: {e}")
        # Try to refund the bet if there was an error
        try:
            add_cash(ctx.author.id, bet_amt)
        except:
            pass
        await send_embed(ctx, "Blackjack Error", "An error occurred while starting the game. Your bet has been refunded.", 0xe74c3c)


# -----------------------
# Roulette (multiplayer timed round)
# -----------------------

# Active rounds keyed by channel id
ROULETTE_ROUNDS: Dict[int, Dict] = {}
# Recent outcomes history per channel (store last 10)
ROULETTE_HISTORY: Dict[int, List[int]] = {}

# Roulette board image removed - no more broken images

# Predefined coordinates for placing bets on the board image (x, y) centers and box sizes
# Coordinates are relative to a 1200x466 board (the provided image's typical size). We'll scale as needed.
ROULETTE_LAYOUT = {}


# async def _fetch_image_bytes(url: str) -> bytes | None:
#     try:
#         async with aiohttp.ClientSession() as session:
#             async with session.get(url) as resp:
#                 if resp.status == 200:
#                     return await resp.read()
#     except Exception:
#         return None
#     return None


def _circle_crop(im, size: int):
    if not PILLOW_AVAILABLE or im is None:
        return None
    try:
        im = im.convert("RGBA").resize((size, size))
        mask = Image.new("L", (size, size), 0)
        draw = ImageDraw.Draw(mask)
        draw.ellipse((0, 0, size - 1, size - 1), fill=255)
        output = Image.new("RGBA", (size, size))
        output.paste(im, (0, 0), mask=mask)
        # add white stroke for visibility
        stroke = Image.new("RGBA", (size + 8, size + 8), (0, 0, 0, 0))
        sd = ImageDraw.Draw(stroke)
        sd.ellipse((0, 0, size + 7, size + 7), fill=(0, 0, 0, 0), outline=(255, 255, 255, 220), width=4)
        stroke.paste(output, (4, 4), output)
        return stroke
    except Exception as e:
        print(f"Error in _circle_crop: {e}")
        return None


def _roulette_anchor(choice: str, W: int, H: int) -> tuple[int, int]:
    # Normalize
    c = choice.lower().strip()
    # Baseline layout ratios (approximate to the provided image)
    left_zero_ratio = 0.09
    right_margin_ratio = 0.08
    numbers_height_ratio = 0.58
    dozens_height_ratio = 0.18
    bottom_height_ratio = 1.0 - numbers_height_ratio - dozens_height_ratio

    left_zero_w = int(W * left_zero_ratio)
    right_margin_w = int(W * right_margin_ratio)
    grid_x = left_zero_w
    grid_w = W - left_zero_w - right_margin_w
    col_w = grid_w / 12.0

    numbers_h = int(H * numbers_height_ratio)
    dozens_h = int(H * dozens_height_ratio)
    bottom_h = H - numbers_h - dozens_h

    # 0 slot (vertical strip on the left)
    if c == "0" or c == "green":
        return (left_zero_w // 2, numbers_h // 2)

    # Numbers 1..36
    try:
        n = int(c)
        if 1 <= n <= 36:
            col = (n + 2) // 3  # 1..12
            row_index = 0 if n % 3 == 0 else (1 if n % 3 == 2 else 2)  # 0=top,1=mid,2=bot
            cx = int(grid_x + (col - 0.5) * col_w)
            row_h = numbers_h / 3.0
            cy = int((row_index + 0.5) * row_h)
            return (cx, cy)
    except ValueError:
        pass

    # Dozens
    if c in ("1st12", "2nd12", "3rd12"):
        idx = {"1st12": 0, "2nd12": 1, "3rd12": 2}[c]
        cx = int(grid_x + (idx + 0.5) * (grid_w / 3.0))
        cy = int(numbers_h + dozens_h / 2)
        return (cx, cy)

    # Bottom row: 1-18, even, red, black, odd, 19-36
    bottom_keys = ["1-18", "even", "red", "black", "odd", "19-36"]
    if c in bottom_keys:
        idx = bottom_keys.index(c)
        slot_w = W / 6.0
        cx = int((idx + 0.5) * slot_w)
        cy = int(numbers_h + dozens_h + bottom_h / 2)
        return (cx, cy)

    # Colors (alias to bottom slots)
    if c in ("red", "black"):
        return _roulette_anchor(c, W, H)

    # Ranges (aliases)
    if c in ("1-18", "19-36"):
        return _roulette_anchor(c, W, H)

    # Fallback center
    return (W // 2, H // 2)


# Image generation function removed - just use simple image
# async def render_roulette_board_with_bets(ctx: commands.Context, bets: dict):
#     ... removed for simplicity ...

RED_NUMBERS = {1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36}


def _roulette_color(n: int) -> str:
    return "green" if n == 0 else ("red" if n in RED_NUMBERS else "black")


def _roulette_multiplier(choice: str, outcome: int) -> int:
    c = choice.lower()
    color = _roulette_color(outcome)
    # straight number
    if c.isdigit():
        return 36 if int(c) == outcome else 0
    # even/odd (no 0)
    if c in ("even", "odd"):
        if outcome == 0:
            return 0
        if c == "even" and outcome % 2 == 0:
            return 2
        if c == "odd" and outcome % 2 == 1:
            return 2
        return 0
    # color
    if c in ("red", "black", "green"):
        if c == color:
            return 14 if c == "green" else 2
        return 0
    # ranges
    if c in ("1-18", "19-36"):
        if outcome == 0:
            return 0
        if c == "1-18" and 1 <= outcome <= 18:
            return 2
        if c == "19-36" and 19 <= outcome <= 36:
            return 2
        return 0
    # dozens
    if c in ("1st12", "2nd12", "3rd12"):
        if outcome == 0:
            return 0
        if c == "1st12" and 1 <= outcome <= 12:
            return 3
        if c == "2nd12" and 13 <= outcome <= 24:
            return 3
        if c == "3rd12" and 25 <= outcome <= 36:
            return 3
        return 0
    return 0


# Removed Pillow-based image generation to avoid dependency; using static board image instead.


@bot.hybrid_command(name="roulette", description="Place a roulette bet; starts a 30s round if none exists", aliases=["rl"])
@app_commands.autocomplete(choice=roulette_choice_autocomplete, amount=amount_autocomplete)
async def roulette_cmd(ctx: commands.Context, choice: str, amount: str):
    # Validate the bet choice
    valid_choices = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "red", "black", "green", "1-18", "19-36", "odd", "even", "1st12", "2nd12", "3rd12"]
    
    if choice.lower() not in valid_choices:
        return await send_embed(ctx, "Roulette", f"Invalid bet choice: `{choice}`\n\n**Valid choices:**\n• Numbers: 0-36\n• Colors: red, black, green\n• Ranges: 1-18, 19-36, odd, even\n• Dozens: 1st12, 2nd12, 3rd12", 0xe74c3c)
    
    channel_id = ctx.channel.id
    state = ROULETTE_ROUNDS.get(channel_id)
    created_now = False
    # Create a new 30-second round if none exists
    if not state:
        end_time = datetime.now(timezone.utc) + timedelta(seconds=30)
        state = ROULETTE_ROUNDS[channel_id] = {"host": ctx.author.id, "end": end_time, "bets": {}}
        created_now = True
        # Announcement embed
        ts = int(end_time.timestamp())
        open_embed = discord.Embed(title="🎰 Roulette — Place your bets!", color=0x5865F2)
        # Legend and countdown
        legend = (
            "Choices: Numbers (0-36), red, black, green, odd, even, 1-18, 19-36, 1st12, 2nd12, 3rd12\n"
            f"Payouts: Numbers (36x), Dozens (3x), Colors (2x), Ranges (2x), Even/Odd (2x)\n"
            f"Closes <t:{ts}:R> at <t:{ts}:t>"
        )
        # Recent history line
        hist = ROULETTE_HISTORY.get(channel_id, [])
        if hist:
            def _fmt(n:int):
                c = _roulette_color(n)
                return ("🟢" if c=="green" else ("🔴" if c=="red" else "⚫")) + str(n)
            history_line = " ".join(_fmt(n) for n in hist[-10:])
            open_embed.add_field(name="Recent Spins", value=history_line, inline=False)
        open_embed.description = legend
        # Keep static image if desired
        # open_embed.set_image(url=ROULETTE_BOARD_IMAGE)  # Image removed
        open_embed.set_footer(text="Use /roulette <choice> <amount> to join.")
        await ctx.send(embed=open_embed)

        async def _close_after_delay():
            await asyncio.sleep(30)
            if channel_id not in ROULETTE_ROUNDS:
                return
            local_state = ROULETTE_ROUNDS.pop(channel_id)
            bets: Dict[int, Dict] = local_state.get("bets", {})
            outcome = random.randint(0, 36)
            color = _roulette_color(outcome)
            # Save to history
            hist = ROULETTE_HISTORY.get(channel_id, [])
            hist.append(outcome)
            ROULETTE_HISTORY[channel_id] = hist[-10:]
            winners = []
            for uid, user_bets in bets.items():
                user_total_won = 0
                user_total_bet = 0
                user_wins = []

                # Iterate all choices; support multiple bets per choice (list)
                for choice, bet_entry in user_bets.items():
                    bet_list = bet_entry if isinstance(bet_entry, list) else [bet_entry]
                    mult = _roulette_multiplier(choice, outcome)
                    for bet_data in bet_list:
                        user_total_bet += int(bet_data.get("amount", 0))
                        if mult <= 0:
                            continue
                        base_payout = int(bet_data["amount"]) * mult
                        
                        # Calculate total bonus percentage (capped at 5%)
                        total_bonus_percent = 0
                        
                        # Apply gambling role bonus
                        role_bonus = int(bet_data.get("role_bonus", 0))
                        if role_bonus:
                            total_bonus_percent += role_bonus / 100.0
                        
                        # Apply luck attribute bonus (1% per luck point)
                        attributes, _ = get_user_attributes(uid)
                        luck_bonus = attributes.get("luck", 0) * 0.01  # +1% per luck point
                        if luck_bonus > 0:
                            total_bonus_percent += luck_bonus
                        
                        # Apply Immortal Art gambling bonuses
                        _, immortal_bonus = apply_gambling_payout_bonus(uid, base_payout, "roulette")
                        if immortal_bonus > 0:
                            # Convert bonus amount to percentage
                            bonus_percent = immortal_bonus / base_payout
                            total_bonus_percent += bonus_percent
                        
                        # Cap total bonus at 5%
                        total_bonus_percent = min(total_bonus_percent, 0.05)
                        
                        # Apply capped bonus
                        final_payout = int(base_payout * (1 + total_bonus_percent))
                        
                        # Check for critical win (still allowed, but rare)
                        if check_gambling_crit_win(uid):
                            final_payout *= 2
                        
                        # Check for double win chance (still allowed, but rare)
                        if check_double_win_chance(uid):
                            final_payout *= 2
                        
                        # Calculate final bonus for display
                        bonus = final_payout - base_payout

                        add_cash(uid, final_payout)
                        user_total_won += final_payout
                        user_wins.append((choice, final_payout, mult, int(bet_data["amount"]), bonus))
                        


                if user_total_won > 0:
                    winners.append((uid, user_total_won, user_total_bet, user_wins))

            if not winners:
                embed2 = discord.Embed(color=0x2b2d31)
                embed2.description = f"🎉 The ball landed on: **{color} {outcome}**\n\n**No Winners :(**"
                await ctx.send(embed=embed2)
                return

            winners_lines = []
            for winner_data in winners:
                if len(winner_data) == 4:  # New format: (uid, total_won, total_bet, user_wins)
                    uid, total_won, total_bet, user_wins = winner_data
                    delta = total_won - total_bet
                    sign = "+" if delta >= 0 else "-"
                    
                    # Show total win for this user
                    line = f"<@{uid}> — **Total Won:** {MONEY_ICON} {total_won:,} ({sign}{abs(delta):,})\n"
                    
                    # Show individual winning bets
                    for choice, payout, mult, bet_amt, bonus in user_wins:
                        choice_delta = payout - bet_amt
                        choice_sign = "+" if choice_delta >= 0 else "-"
                        line += f"  └ `{choice}` (x{mult}): {MONEY_ICON} {payout:,} ({choice_sign}{abs(choice_delta):,})"
                    if bonus > 0:
                        line += f" **[+{MONEY_ICON} {bonus:,} bonus]**"
                    line += "\n"
                    
                    winners_lines.append(line)
                else:  # Old format (fallback)
                    uid, payout, mult, bet_amt = winner_data
                    delta = payout - bet_amt
                    sign = "+" if delta >= 0 else "-"
                    winners_lines.append(f"<@{uid}> — x{mult} → {MONEY_ICON} {payout:,} ({sign}{abs(delta):,})")
            embed3 = discord.Embed(title="Roulette Results", color=0x2ecc71)
            embed3.description = f"🎉 The ball landed on: **{color} {outcome}**"
            embed3.add_field(name="Winners", value="\n".join(winners_lines), inline=False)
            await ctx.send(embed=embed3)

        ctx.bot.loop.create_task(_close_after_delay())

    # Place bet in the active round (allow multiple bets)
    remaining = int((state["end"] - datetime.now(timezone.utc)).total_seconds())
    if remaining <= 0:
        return await send_embed(ctx, "Roulette", "Betting is closed. Try again.", 0xe74c3c)

    # Amount parsing and wallet check
    cash, _ = get_balances(ctx.author.id)
    amt = parse_amount_arg(amount, cash)
    if amt is None or amt <= 0:
        return await send_embed(ctx, "Roulette", "Invalid bet amount (number, `all`, `half`, `1k`, `1m`, `1b`, etc.).", 0xe74c3c)
    if amt > cash:
        return await send_embed(ctx, "Roulette", "You don't have enough Spirit Stones.", 0xe74c3c)

    # Initialize user's bets if not exists
    if ctx.author.id not in state["bets"]:
        state["bets"][ctx.author.id] = {}

    # Deduct money and place bet (allow multiple per choice)
    add_cash(ctx.author.id, -amt)
    role_bonus = await _get_gamble_bonus("roulette", ctx.author)
    user_bets = state["bets"][ctx.author.id]
    if choice not in user_bets:
        user_bets[choice] = []
    # Ensure list structure for stacking bets
    if not isinstance(user_bets[choice], list):
        user_bets[choice] = [user_bets[choice]]
    user_bets[choice].append({"amount": int(amt), "role_bonus": role_bonus, "ts": int(datetime.now(timezone.utc).timestamp())})

    # Acknowledge with round summary and show all bets
    def _sum_user_total(bets_dict: Dict[str, object]) -> int:
        total = 0
        for _, entry in bets_dict.items():
            if isinstance(entry, list):
                total += sum(int(b["amount"]) for b in entry)
            else:
                total += int(entry.get("amount", 0))
        return total

    total_pool = sum(_sum_user_total(bd) for bd in state["bets"].values())
    num_players = len(state["bets"])

    # Create confirmation message and generated image
    ack = discord.Embed(color=0x2b2d31)
    ack.description = f"You have placed a bet of {MONEY_ICON} {amt:,} on {choice}."

    # Show all current bets summary
    all_bets_text = ""
    for user_id, bets_dict in state["bets"].items():
        user_member = ctx.guild.get_member(user_id)
        user_name = user_member.display_name if user_member else f"User {user_id}"
        user_total = _sum_user_total(bets_dict)
        all_bets_text += f"**{user_name}:** {MONEY_ICON} {user_total:,}\n"
        for ch, entry in bets_dict.items():
            if isinstance(entry, list):
                for b in entry:
                    all_bets_text += f"  └ {ch}: {MONEY_ICON} {int(b['amount']):,}\n"
            else:
                all_bets_text += f"  └ {ch}: {MONEY_ICON} {int(entry.get('amount',0)):,}\n"

    if all_bets_text:
        ack.add_field(name="📊 All Current Bets", value=all_bets_text, inline=False)

    ack.add_field(name="Total Pool", value=f"{MONEY_ICON} {total_pool:,}", inline=True)
    ack.add_field(name="Players", value=str(num_players), inline=True)
    ack.set_footer(text=f"Time remaining: {remaining} sec.")

    # Just use the image directly
            # ack.set_image(url=ROULETTE_BOARD_IMAGE)  # Image removed
    await ctx.send(embed=ack)


@bot.hybrid_command(name="roulette_status", description="Show current roulette round status and all bets")
async def roulette_status(ctx):
    """Show current roulette round status and all bets"""
    channel_id = ctx.channel.id
    state = ROULETTE_ROUNDS.get(channel_id)
    
    if not state:
        await send_embed(ctx, "🎰 Roulette Status", "No active roulette round in this channel.", 0x95a5a6)
        return
    
    # Calculate remaining time
    remaining = int((state["end"] - datetime.now(timezone.utc)).total_seconds())
    if remaining <= 0:
        await send_embed(ctx, "🎰 Roulette Status", "Betting is closed for this round.", 0xe74c3c)
        return
    
    # Create status embed
    embed = discord.Embed(title="🎰 Roulette Round Status", color=0x5865F2)
    embed.add_field(name="⏰ Time Remaining", value=f"{remaining} seconds", inline=True)
    embed.add_field(name="👑 Host", value=f"<@{state['host']}>", inline=True)
    
    # Show all current bets
    if state["bets"]:
        total_pool = 0
        for user_bets in state["bets"].values():
            for choice, bet_entry in user_bets.items():
                if isinstance(bet_entry, list):
                    total_pool += sum(int(b["amount"]) for b in bet_entry)
                else:
                    total_pool += int(bet_entry.get("amount", 0))
        embed.add_field(name="💰 Total Pool", value=f"{MONEY_ICON} {total_pool:,}", inline=True)
        
        all_bets_text = ""
        for user_id, user_bets in state["bets"].items():
            user_member = ctx.guild.get_member(user_id)
            user_name = user_member.display_name if user_member else f"User {user_id}"
            user_total = 0
            for choice, bet_entry in user_bets.items():
                if isinstance(bet_entry, list):
                    user_total += sum(int(b["amount"]) for b in bet_entry)
                else:
                    user_total += int(bet_entry.get("amount", 0))
            all_bets_text += f"**{user_name}:** {MONEY_ICON} {user_total:,}\n"
            for choice, bet_entry in user_bets.items():
                if isinstance(bet_entry, list):
                    for bet in bet_entry:
                        all_bets_text += f"  └ `{choice}`: {MONEY_ICON} {int(bet['amount']):,}\n"
                else:
                    all_bets_text += f"  └ `{choice}`: {MONEY_ICON} {int(bet_entry.get('amount', 0)):,}\n"
        
        embed.add_field(name="📊 All Current Bets", value=all_bets_text, inline=False)
    else:
        embed.add_field(name="📊 Current Bets", value="No bets placed yet", inline=False)
    
    embed.set_footer(text=f"Use /roulette <choice> <amount> to place your bets!")
    await ctx.send(embed=embed)


# -----------------------
# Young Master Income Command
# -----------------------
# Sect Shop Commands
# -----------------------


# -----------------------
# Sect Shop Commands
# -----------------------

@bot.hybrid_command(name="sect_shop", description="View and purchase sect upgrades (Sect Leader and Ancestors only)")
async def sect_shop(ctx):
    """View available sect upgrades and purchase them"""
    meta = get_user_meta(ctx.author.id)
    sect_name = meta.get("sect")
    
    if not sect_name:
        await send_embed(ctx, "No Sect", "You must be in a sect to access the sect shop.", 0xe74c3c)
        return
    
    data = load_json(SECTS_FILE)
    if sect_name not in data:
        await send_embed(ctx, "Sect Not Found", "Your sect could not be found.", 0xe74c3c)
        return
    
    # Check if user is sect leader or ancestor
    user_rank = meta.get("sect_rank", "outer disciple")
    if ctx.author.id != data[sect_name]["leader"] and user_rank != "ancestor":
        await send_embed(ctx, "Access Denied", "Only the sect leader and ancestors can access the sect shop.", 0xe74c3c)
        return
    
    # Get current upgrades
    current_upgrades = get_sect_upgrades(sect_name)
    sect_boosts = get_sect_boosts(sect_name)
    sect_rank = get_sect_rank(sect_name)
    
    embed = discord.Embed(
        title="🏪 Sect Shop",
        description=f"Welcome to the {sect_name} sect shop!\nPurchase upgrades to benefit all your sect members.",
        color=0x9b59b6
    )
    
    # Show current sect rank and bonuses
    if sect_rank in TOP_SECT_BOOSTERS:
        rank_info = TOP_SECT_BOOSTERS[sect_rank]
        embed.add_field(
            name=f"{rank_info['name']} - Current Rank #{sect_rank}",
            value=f"**Income Boost:** +{rank_info['income_boost']}%\n"
                  f"**XP Boost:** +{rank_info['xp_boost']}%\n"
                  f"*Automatic bonus for top 3 sects*",
            inline=False
        )
    else:
        embed.add_field(
            name="📊 Current Rank",
            value=f"Rank #{sect_rank}\n*Work together to reach top 3 for automatic bonuses!*",
            inline=False
        )
    
    # Show current total boosts
    embed.add_field(
        name="🎯 Current Total Boosts",
        value=f"**Income:** +{sect_boosts['income_boost']}%\n"
              f"**XP:** +{sect_boosts['xp_boost']}%\n"
              f"**Expedition:** +{sect_boosts['expedition_boost']}%\n"
              f"**Crafting Discount:** -{sect_boosts['crafting_discount']}%\n"
              f"**Daily Bonus:** +{sect_boosts['daily_bonus']}%\n"
              f"**Weekly Bonus:** +{sect_boosts['weekly_bonus']}%\n"
              f"**Immortal Art:** +{sect_boosts['immortal_art_boost']}%",
        inline=False
    )
    
    # Group upgrades by category
    categories = {}
    for upgrade_id, upgrade_data in SECT_SHOP_UPGRADES.items():
        category = upgrade_data["category"]
        if category not in categories:
            categories[category] = []
        categories[category].append((upgrade_id, upgrade_data))
    
    # Display upgrades by category
    for category, upgrades in categories.items():
        category_name = category.title()
        category_emoji = {"core": "⭐", "adventure": "🗺️", "economy": "💰", "mystical": "✨", "utility": "🔧"}.get(category, "📦")
        
        category_text = ""
        for upgrade_id, upgrade_data in upgrades:
            current_level = current_upgrades.get(upgrade_id, 0)
            max_level = upgrade_data["max_level"]
            emoji = upgrade_data["emoji"]
            
            if current_level >= max_level:
                category_text += f"**{upgrade_data['name']}** - MAXED (Level {current_level}/{max_level})\n"
            else:
                cost = get_sect_upgrade_cost(sect_name, upgrade_id)
                effect = upgrade_data["effect_per_level"]
                category_text += f"**{upgrade_data['name']}** - Level {current_level}/{max_level}\n"
                category_text += f"   Cost: {MONEY_ICON} {cost:,} | Effect: +{effect}% per level\n"
                category_text += f"   `/sect_upgrade {upgrade_id}`\n\n"
        
        embed.add_field(
            name=f"{category_emoji} {category_name} Upgrades",
            value=category_text.strip(),
            inline=False
        )
    
    embed.set_footer(text="Use /sect_upgrade <upgrade_type> to purchase upgrades • Sect leader and ancestors can purchase")
    await ctx.send(embed=embed)


@bot.hybrid_command(name="sect_upgrade", description="Purchase a sect upgrade (Sect Leader and Ancestors only)")
@app_commands.autocomplete(upgrade_type=sect_upgrade_autocomplete)
async def sect_upgrade(ctx, upgrade_type: str):
    """Purchase a sect upgrade"""
    meta = get_user_meta(ctx.author.id)
    sect_name = meta.get("sect")
    
    if not sect_name:
        await send_embed(ctx, "No Sect", "You must be in a sect to purchase upgrades.", 0xe74c3c)
        return
    
    data = load_json(SECTS_FILE)
    if sect_name not in data:
        await send_embed(ctx, "Sect Not Found", "Your sect could not be found.", 0xe74c3c)
        return
    
    # Check if user is sect leader or ancestor
    user_rank = meta.get("sect_rank", "outer disciple")
    if ctx.author.id != data[sect_name]["leader"] and user_rank != "ancestor":
        await send_embed(ctx, "Access Denied", "Only the sect leader and ancestors can purchase upgrades.", 0xe74c3c)
        return
    
    # Validate upgrade type
    if upgrade_type not in SECT_SHOP_UPGRADES:
        available_upgrades = ", ".join(SECT_SHOP_UPGRADES.keys())
        await send_embed(ctx, "Invalid Upgrade", f"Available upgrades: {available_upgrades}", 0xe74c3c)
        return
    
    # Check if upgrade can be purchased
    if not can_upgrade_sect(sect_name, upgrade_type):
        await send_embed(ctx, "Cannot Upgrade", "This upgrade is already at maximum level.", 0xe74c3c)
        return
    
    # Get upgrade cost
    cost = get_sect_upgrade_cost(sect_name, upgrade_type)
    
    # Check if sect has enough money in the bank
    sect_bank = data[sect_name].get("bank", 0)
    if sect_bank < cost:
        await send_embed(ctx, "Insufficient Funds", f"The sect needs {MONEY_ICON} {cost:,} in the sect bank to purchase this upgrade. Current bank: {MONEY_ICON} {sect_bank:,}", 0xe74c3c)
        return
    
    # Purchase the upgrade
    if "upgrades" not in data[sect_name]:
        data[sect_name]["upgrades"] = {}
    
    current_level = data[sect_name]["upgrades"].get(upgrade_type, 0)
    data[sect_name]["upgrades"][upgrade_type] = current_level + 1
    data[sect_name]["bank"] = sect_bank - cost
    
    save_json(SECTS_FILE, data)
    
    # Update top sect boosters
    update_top_sect_boosters()
    
    # Get upgrade info
    upgrade_data = SECT_SHOP_UPGRADES[upgrade_type]
    new_level = current_level + 1
    effect = upgrade_data["effect_per_level"]
    
    embed = discord.Embed(
        title="✅ Upgrade Purchased!",
        description=f"Successfully upgraded **{upgrade_data['name']}** to level {new_level}",
        color=0x2ecc71
    )
    
    embed.add_field(name="💰 Cost", value=f"{MONEY_ICON} {cost:,}", inline=True)
    embed.add_field(name="📈 Effect", value=f"+{effect}% per level", inline=True)
    embed.add_field(name="🎯 New Level", value=f"Level {new_level}/{upgrade_data['max_level']}", inline=True)
    
    embed.add_field(
        name="💡 What This Means",
        value=f"All sect members now get +{effect * new_level}% {upgrade_data['description'].lower()}",
        inline=False
    )
    
    embed.set_footer(text=f"Use /sect_shop to view all available upgrades")
    await ctx.send(embed=embed)


@bot.hybrid_command(name="sect_boosts", description="View current sect boosts and bonuses")
async def sect_boosts(ctx):
    """View current sect boosts and bonuses"""
    meta = get_user_meta(ctx.author.id)
    sect_name = meta.get("sect")
    
    if not sect_name:
        await send_embed(ctx, "No Sect", "You must be in a sect to view boosts.", 0xe74c3c)
        return
    
    data = load_json(SECTS_FILE)
    if sect_name not in data:
        await send_embed(ctx, "Sect Not Found", "Your sect could not be found.", 0xe74c3c)
        return
    
    # Validate that user is actually a member or leader of the sect
    if not validate_sect_membership(ctx.author.id, sect_name):
        await send_embed(ctx, "Not a Member", "You are not actually a member of this sect.", 0xe74c3c)
        return
    
    # Get current boosts
    sect_boosts = get_sect_boosts(sect_name)
    sect_rank = get_sect_rank(sect_name)
    current_upgrades = get_sect_upgrades(sect_name)
    
    embed = discord.Embed(
        title=f"🎯 {sect_name} - Sect Boosts & Bonuses",
        description="Current active bonuses for all sect members",
        color=0x9b59b6
    )
    
    # Show rank and automatic bonuses
    if sect_rank in TOP_SECT_BOOSTERS:
        rank_info = TOP_SECT_BOOSTERS[sect_rank]
        embed.add_field(
            name=f"{rank_info['name']} - Rank #{sect_rank}",
            value=f"**Automatic Income Boost:** +{rank_info['income_boost']}%\n"
                  f"**Automatic XP Boost:** +{rank_info['xp_boost']}%\n"
                  f"*These bonuses are permanent while you maintain this rank*",
            inline=False
        )
    else:
        embed.add_field(
            name="📊 Current Rank",
            value=f"Rank #{sect_rank}\n*Reach top 3 to get automatic bonuses!*",
            inline=False
        )
    
    # Show purchased upgrades
    if current_upgrades:
        upgrades_text = ""
        for upgrade_id, level in current_upgrades.items():
            if upgrade_id in SECT_SHOP_UPGRADES:
                upgrade_data = SECT_SHOP_UPGRADES[upgrade_id]
                emoji = upgrade_data["emoji"]
                effect = upgrade_data["effect_per_level"] * level
                upgrades_text += f"{emoji} **{upgrade_data['name']}** (Level {level})\n"
                upgrades_text += f"   +{effect}% {upgrade_data['description'].lower()}\n\n"
        
        embed.add_field(
            name="🏗️ Purchased Upgrades",
            value=upgrades_text.strip(),
            inline=False
        )
    else:
        embed.add_field(
            name="🏗️ Purchased Upgrades",
            value="No upgrades purchased yet.\n*Sect leader can buy upgrades in `/sect_shop`*",
            inline=False
        )
    
    # Show total combined bonuses
    embed.add_field(
        name="🎯 Total Combined Bonuses",
        value=f"**Income Boost:** +{sect_boosts['income_boost']}%\n"
              f"**XP Boost:** +{sect_boosts['xp_boost']}%\n"
              f"**Expedition Enhancement:** +{sect_boosts['expedition_boost']}%\n"
              f"**Crafting Discount:** -{sect_boosts['crafting_discount']}%\n"
              f"**Daily Bonus:** +{sect_boosts['daily_bonus']}%\n"
              f"**Weekly Bonus:** +{sect_boosts['weekly_bonus']}%\n"
              f"**Immortal Art Boost:** +{sect_boosts['immortal_art_boost']}%",
        inline=False
    )
    
    embed.set_footer(text="These bonuses apply to all sect members automatically")
    await ctx.send(embed=embed)





@bot.command(name="delete_sect")
async def delete_sect(ctx):
    """Delete your sect completely (Sect Leader or Admin only)"""
    # Check if user is admin or sect leader
    if not ctx.author.guild_permissions.administrator:
        meta = get_user_meta(ctx.author.id)
        sect_name = meta.get("sect")
        
        if not sect_name:
            await send_embed(ctx, "No Sect", "You must be in a sect to use this command.", 0xe74c3c)
            return
        
        data = load_json(SECTS_FILE)
        if sect_name not in data:
            await send_embed(ctx, "Sect Not Found", "Your sect could not be found.", 0xe74c3c)
            return
        
        # Check if user is sect leader
        if data[sect_name].get("leader") != ctx.author.id:
            await send_embed(ctx, "Not Sect Leader", "Only sect leaders can delete their sect.", 0xe74c3c)
            return
    else:
        # Admin can delete any sect
        meta = get_user_meta(ctx.author.id)
        sect_name = meta.get("sect")
        
        if not sect_name:
            await send_embed(ctx, "No Sect", "You must be in a sect to use this command.", 0xe74c3c)
            return
        
        data = load_json(SECTS_FILE)
        if sect_name not in data:
            await send_embed(ctx, "Sect Not Found", "Your sect could not be found.", 0xe74c3c)
            return
    
    # Get all members to clear their sect data
    sect_data = data[sect_name]
    all_members = []
    
    # Add leader
    if "leader" in sect_data:
        all_members.append(sect_data["leader"])
    
    # Add regular members
    if "members" in sect_data:
        all_members.extend([int(mid) if isinstance(mid, str) else mid for mid in sect_data["members"]])
    
    # Clear sect data for all members
    for member_id in all_members:
        member_meta = get_user_meta(member_id)
        member_meta["sect"] = None
        member_meta["sect_rank"] = None
        set_user_meta(member_id, member_meta)
    
    # Delete the sect
    del data[sect_name]
    save_json(SECTS_FILE, data)
    
    embed = discord.Embed(title="🗑️ Sect Deleted!", color=0xe74c3c)
    embed.description = f"**{sect_name}** has been completely deleted!"
    embed.add_field(name="Deleted By", value=f"{ctx.author.display_name}", inline=True)
    embed.add_field(name="Members Affected", value=f"{len(all_members)} members", inline=True)
    embed.add_field(name="Note", value="All members have been removed from the sect", inline=False)
    embed.set_footer(text="Sect can be recreated if needed")
    
    await ctx.send(embed=embed)


@bot.hybrid_command(name="sect_contribute", description="Contribute money to your sect for upgrades")
@app_commands.autocomplete(amount=amount_autocomplete)
async def sect_contribute(ctx, amount: str):
    """Contribute money to your sect for purchasing upgrades"""
    cash, bank = get_balances(ctx.author.id)
    amt = parse_amount_arg(amount, cash)
    if amt is None:
        await send_embed(ctx, "Invalid Amount", "Please provide a valid amount (number, `all`, `half`, `1k`, `1m`, `1b`, etc.).", 0xe74c3c)
        return
    if amt <= 0:
        await send_embed(ctx, "Invalid Amount", "Please contribute a positive amount.", 0xe74c3c)
        return
    
    meta = get_user_meta(ctx.author.id)
    sect_name = meta.get("sect")
    
    if not sect_name:
        await send_embed(ctx, "No Sect", "You must be in a sect to contribute.", 0xe74c3c)
        return
    
    data = load_json(SECTS_FILE)
    if sect_name not in data:
        await send_embed(ctx, "Sect Not Found", "Your sect could not be found.", 0xe74c3c)
        return
    
    # Check if user has enough money
    if cash < amt:
        await send_embed(ctx, "Insufficient Funds", f"You only have {MONEY_ICON} {cash:,} in cash.", 0xe74c3c)
        return
    
    # Deduct money from user and add to sect bank
    set_cash(ctx.author.id, cash - amt)
    
    if "bank" not in data[sect_name]:
        data[sect_name]["bank"] = 0
    data[sect_name]["bank"] += amt
    
    save_json(SECTS_FILE, data)
    
    embed = discord.Embed(
        title="💰 Contribution Successful!",
        description=f"Thank you for contributing to {sect_name}!",
        color=0x2ecc71
    )
    
    embed.add_field(name="💰 Amount Contributed", value=f"{MONEY_ICON} {amt:,}", inline=True)
    embed.add_field(name="🏦 Sect Bank", value=f"{MONEY_ICON} {data[sect_name]['bank']:,}", inline=True)
    embed.add_field(name="👤 Your New Balance", value=f"{MONEY_ICON} {cash - amt:,}", inline=True)
    
    embed.set_footer(text="Sect leader can use the sect bank to purchase upgrades in /sect_shop")
    await ctx.send(embed=embed)


@bot.hybrid_command(name="sect_bank_view", description="View your sect's current bank balance")
async def sect_bank_view(ctx):
    """View your sect's current bank balance and upgrade information"""
    meta = get_user_meta(ctx.author.id)
    sect_name = meta.get("sect")
    
    if not sect_name:
        await send_embed(ctx, "No Sect", "You must be in a sect to view the bank.", 0xe74c3c)
        return
    
    data = load_json(SECTS_FILE)
    if sect_name not in data:
        await send_embed(ctx, "Sect Not Found", "Your sect could not be found.", 0xe74c3c)
        return
    
    sect_bank = data[sect_name].get("bank", 0)
    
    embed = discord.Embed(
        title=f"🏦 {sect_name} - Sect Bank",
        description="Current sect bank balance and upgrade information",
        color=0x9b59b6
    )
    
    embed.add_field(
        name="💰 Current Bank Balance",
        value=f"{MONEY_ICON} {sect_bank:,}",
        inline=False
    )
    
    # Show what can be purchased
    if sect_bank > 0:
        affordable_upgrades = []
        for upgrade_id, upgrade_data in SECT_SHOP_UPGRADES.items():
            cost = get_sect_upgrade_cost(sect_name, upgrade_id)
            if cost > 0 and sect_bank >= cost:
                affordable_upgrades.append(f"• {upgrade_data['emoji']} {upgrade_data['name']} - {MONEY_ICON} {cost:,}")
        
        if affordable_upgrades:
            embed.add_field(
                name="🛒 Affordable Upgrades",
                value="\n".join(affordable_upgrades[:5]),  # Show top 5
                inline=False
            )
        else:
            embed.add_field(
                name="🛒 Affordable Upgrades",
                value="No upgrades can be afforded with current bank balance.",
                inline=False
            )
    else:
        embed.add_field(
            name="🛒 Affordable Upgrades",
            value="No funds available. Members can contribute using `/sect_contribute <amount>`",
            inline=False
        )
    
    embed.add_field(
        name="💡 How to Help",
        value="• Use `/sect_contribute <amount>` to donate money\n"
              "• Sect leader can purchase upgrades in `/sect_shop`\n"
              "• Work together to build a powerful sect!",
        inline=False
    )
    
    embed.set_footer(text="Only sect leader can spend sect funds on upgrades")
    await ctx.send(embed=embed)


@bot.command(name="sect_leaderboard")
async def sect_leaderboard(ctx):
    """View sect rankings and top 3 bonuses"""
    data = load_json(SECTS_FILE)
    
    if not data:
        await send_embed(ctx, "No Sects", "No sects exist yet.", 0xe67e22)
        return
    
    # Calculate combined score for all sects (wealth + member count)
    sects = []
    for sect_name, sect_data in data.items():
        total_wealth = 0
        for member_id in sect_data.get("members", []):
            cash, bank = get_balances(member_id)
            total_wealth += cash + bank
        
        # Add sect bank to total wealth
        sect_bank = sect_data.get("bank", 0)
        total_wealth += sect_bank
        
        # Calculate combined score: 70% wealth + 30% member count
        member_count = len(sect_data.get("members", []))
        member_score = member_count * 100000  # 100k per member
        combined_score = (total_wealth * 0.7) + (member_score * 0.3)
        
        sects.append((sect_name, total_wealth, sect_bank, member_count, combined_score))
    
    # Sort by combined score
    sects.sort(key=lambda x: x[4], reverse=True)
    
    embed = discord.Embed(
        title="🏆 Sect Leaderboard",
        description="Sect rankings based on **70% Total Wealth + 30% Member Count**",
        color=0xFFD700
    )
    
    # Show top 10 sects
    for i, (sect_name, total_wealth, sect_bank, member_count, combined_score) in enumerate(sects[:10]):
        rank = i + 1
        
        # Add rank emoji and color for top 3
        if rank == 1:
            rank_display = "🥇 1st"
            rank_color = 0xFFD700
        elif rank == 2:
            rank_display = "🥈 2nd"
            rank_color = 0xC0C0C0
        elif rank == 3:
            rank_display = "🥉 3rd"
            rank_color = 0xCD7F32
        else:
            rank_display = f"#{rank}"
            rank_color = 0x9b59b6
        
        # Show member count and sect bank
        sect_bank_display = f"{MONEY_ICON} {sect_bank:,}" if sect_bank > 0 else "No bank"
        
        # Show top 3 bonuses
        if rank <= 3:
            booster = TOP_SECT_BOOSTERS[rank]
            bonus_info = f"**{booster['name']}**\n"
            bonus_info += f"💰 +{booster['income_boost']}% Income | 🎯 +{booster['xp_boost']}% XP"
        else:
            bonus_info = "No automatic bonuses"
        
        embed.add_field(
            name=f"{rank_display} - {sect_name}",
            value=f"**Combined Score:** {combined_score:,.0f}\n"
                  f"**Total Wealth:** {MONEY_ICON} {total_wealth:,}\n"
                  f"**Members:** {member_count}\n"
                  f"**Sect Bank:** {sect_bank_display}\n"
                  f"**Bonuses:** {bonus_info}",
            inline=False
        )
    
    embed.set_footer(text="Top 3 sects get automatic bonuses • Scoring: 70% Wealth + 30% Member Count • Use /sect_contribute to help your sect")
    await ctx.send(embed=embed)


# -----------------------
# Admin Commands for Sect Management
# -----------------------

@bot.command(name="update_sect_rankings")
@commands.has_permissions(administrator=True)
async def update_sect_rankings_admin(ctx):
    """Admin command to manually update sect rankings and top 3 boosters"""
    await ctx.defer()
    
    # Update rankings
    update_top_sect_boosters()
    
    # Get updated data
    data = load_json(SECTS_FILE)
    
    embed = discord.Embed(
        title="✅ Sect Rankings Updated",
        description="Sect rankings and top 3 boosters have been recalculated",
        color=0x2ecc71
    )
    
    # Show top 3 sects
    top_sects = []
    for sect_name, sect_data in data.items():
        if "rank" in sect_data and sect_data["rank"] <= 3:
            rank = sect_data["rank"]
            rank_info = sect_data.get("rank_info", {})
            total_wealth = sect_data.get("total_wealth", 0)
            member_count = len(sect_data.get("members", []))
            
            top_sects.append((rank, sect_name, total_wealth, member_count, rank_info))
    
    # Sort by rank
    top_sects.sort(key=lambda x: x[0])
    
    for rank, sect_name, wealth, members, rank_info in top_sects:
        embed.add_field(
            name=f"{rank_info['name']} - {sect_name}",
            value=f"**Total Wealth:** {MONEY_ICON} {wealth:,}\n"
                  f"**Members:** {members}\n"
                  f"**Income Boost:** +{rank_info['income_boost']}%\n"
                  f"**XP Boost:** +{rank_info['xp_boost']}%",
            inline=False
        )
    
    embed.set_footer(text="Rankings are automatically updated when upgrades are purchased")
    await ctx.send(embed=embed)


# -----------------------
# Tournament System Functions
# -----------------------



class TournamentLobbyView(discord.ui.View):
    def __init__(self, tournament_id: str, host_id: int):
        super().__init__(timeout=None)
        self.tournament_id = tournament_id
        self.host_id = host_id
    
    @discord.ui.button(label="Join Tournament", style=discord.ButtonStyle.green, emoji="✅")
    async def join_tournament(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            # Allow hosts to join their own tournaments
            
            tournaments = _load_tournaments()
            t = tournaments.get(self.tournament_id)
            if not t:
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.send_message("❌ Tournament not found.", ephemeral=True)
                return
            
            if t["status"] != "recruiting":
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.send_message("❌ Tournament is no longer recruiting.", ephemeral=True)
                return
            
            participants = t.get("participants", [])
            if interaction.user.id in participants:
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.send_message("❌ You are already in this tournament.", ephemeral=True)
                return
            
            participants.append(interaction.user.id)
            t["participants"] = participants
            _save_tournaments(tournaments)
            
            if interaction.response and not interaction.response.is_done():
                await interaction.response.send_message(f"✅ Joined tournament! Current participants: {len(participants)}", ephemeral=True)
            await self.update_tournament_embed(interaction.channel)
        except Exception as e:
            print(f"Error in join tournament: {e}")
            try:
                if interaction.response and interaction.response.is_done():
                    await interaction.followup.send(f"✅ Joined tournament! Current participants: {len(participants)}", ephemeral=True)
            except:
                pass
    
    @discord.ui.button(label="Leave Tournament", style=discord.ButtonStyle.red, emoji="❌")
    async def leave_tournament(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            tournaments = _load_tournaments()
            t = tournaments.get(self.tournament_id)
            if not t:
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.send_message("❌ Tournament not found.", ephemeral=True)
                return
            
            if t["status"] != "recruiting":
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.send_message("❌ Cannot leave after tournament starts.", ephemeral=True)
                return
            
            participants = t.get("participants", [])
            if interaction.user.id not in participants:
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.send_message("You haven't joined this tournament.", ephemeral=True)
                return
            
            participants.remove(interaction.user.id)
            t["participants"] = participants
            _save_tournaments(tournaments)
            
            if interaction.response and not interaction.response.is_done():
                await interaction.response.send_message(f"✅ Left tournament. Current participants: {len(participants)}", ephemeral=True)
            await self.update_tournament_embed(interaction.channel)
        except Exception as e:
            print(f"Error in leave tournament: {e}")
            try:
                if interaction.response and interaction.response.is_done():
                    await interaction.followup.send(f"✅ Left tournament. Current participants: {len(participants)}", ephemeral=True)
            except:
                pass
    
    @discord.ui.button(label="Start Tournament", style=discord.ButtonStyle.blurple, emoji="🏁")
    async def start_tournament(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            if interaction.user.id != self.host_id:
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.send_message("❌ Only the tournament host can start the tournament.", ephemeral=True)
                return
            
            tournaments = _load_tournaments()
            t = tournaments.get(self.tournament_id)
            if not t:
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.send_message("❌ Tournament not found.", ephemeral=True)
                return
            
            participants = t.get("participants", [])
            if len(participants) < 2:
                if interaction.response and not interaction.response.is_done():
                    await interaction.response.send_message("❌ Need at least 2 participants to start.", ephemeral=True)
                return
            
            t["status"] = "in_progress"
            _save_tournaments(tournaments)
            
            if interaction.response and not interaction.response.is_done():
                await interaction.response.send_message("🏁 Tournament starting!", ephemeral=True)
            await self.run_tournament(interaction.channel, participants)
        except Exception as e:
            print(f"Error in start tournament: {e}")
            try:
                if interaction.response and interaction.response.is_done():
                    await interaction.followup.send("🏁 Tournament starting!", ephemeral=True)
            except:
                pass
    
    async def update_tournament_embed(self, channel):
        """Update the tournament embed with current participant count"""
        try:
            tournaments = _load_tournaments()
            t = tournaments.get(self.tournament_id)
            if not t:
                return
            
            participants = t.get("participants", [])
            embed = discord.Embed(
                title=f"{TOURNAMENT_EMOJI} {t['title']}",
                description=t.get('description', ''),
                color=TOURNAMENT_COLOR
            )
            embed.add_field(name="Status", value=t['status'].title(), inline=True)
            embed.add_field(name="Participants", value=f"{len(participants)}", inline=True)
            embed.add_field(name="Rewards", value=f"{MONEY_ICON} {t['money_reward']:,} | XP: {t['xp_reward']:,}", inline=True)
            
            if t['status'] == 'recruiting':
                embed.set_footer(text="Use the buttons below to join/leave or start the tournament")
            else:
                embed.set_footer(text="Tournament in progress")
            
            # Update the message
            messages = [msg async for msg in channel.history(limit=100)]
            for msg in messages:
                if msg.author == channel.guild.me and any(view.children for view in msg.components):
                    await msg.edit(embed=embed, view=self if t['status'] == 'recruiting' else None)
                    break
        except Exception as e:
            print(f"Failed to update tournament embed: {e}")
    
    async def run_tournament(self, channel, participants):
        """Run the tournament brackets"""
        if len(participants) < 2:
            await channel.send("❌ Not enough participants to run tournament.")
            return
        
        # Simple single elimination bracket
        remaining = participants.copy()
        round_num = 1
        
        while len(remaining) > 1:
            await channel.send(f"🏆 **Round {round_num}** starting with {len(remaining)} participants!")
            
            # Pair up participants
            matches = []
            for i in range(0, len(remaining), 2):
                if i + 1 < len(remaining):
                    matches.append((remaining[i], remaining[i + 1]))
                else:
                    # Odd number, give bye to last player
                    matches.append((remaining[i], None))
            
            # Run matches
            winners = []
            for player1_id, player2_id in matches:
                if player2_id is None:
                    # Bye
                    winners.append(player1_id)
                    await channel.send(f"🎉 <@{player1_id}> gets a bye to the next round!")
                    continue
                
                player1 = channel.guild.get_member(player1_id)
                player2 = channel.guild.get_member(player2_id)
                
                if not player1 or not player2:
                    # Skip if players left
                    continue
                
                await channel.send(f"⚔️ **{player1.display_name}** vs **{player2.display_name}**")
                
                winner = await _run_tournament_duel(channel, player1, player2)
                if winner:
                    winners.append(winner.id)
                    await channel.send(f"🏆 **{winner.display_name}** wins the match!")
                else:
                    # Random winner on draw
                    winner = random.choice([player1, player2])
                    winners.append(winner.id)
                    await channel.send(f"🤝 It's a draw! **{winner.display_name}** advances randomly.")
            
            remaining = winners
            round_num += 1
            
            if len(remaining) > 1:
                await asyncio.sleep(5)  # Brief pause between rounds
        
        # Tournament complete
        if remaining:
            winner_id = remaining[0]
            winner = channel.guild.get_member(winner_id)
            
            # Award prizes
            tournaments = _load_tournaments()
            t = tournaments.get(self.tournament_id)
            if t and winner:
                money_reward = t.get('money_reward', 0)
                xp_reward = t.get('xp_reward', 0)
                
                # Give money
                current_cash, _ = get_balances(winner_id)
                set_cash(winner_id, current_cash + money_reward)
                
                # Give XP (if you have an XP system)
                # add_xp(winner_id, xp_reward)
                
                embed = discord.Embed(
                    title="🏆 Tournament Complete!",
                    description=f"**{winner.display_name}** is the champion!",
                    color=0xffd700
                )
                embed.add_field(name="Prize Money", value=f"{MONEY_ICON} {money_reward:,}", inline=True)
                embed.add_field(name="XP Reward", value=f"{xp_reward:,}", inline=True)
                
                await channel.send(embed=embed)
                
                # Update tournament status
                t['status'] = 'completed'
                t['winner'] = winner_id
                _save_tournaments(tournaments)

# -----------------------
# Tournament Commands
# -----------------------

@bot.command(name="tournament_create")
@commands.has_permissions(administrator=True)
async def tournament_create(ctx, title: str, money_reward: int = 10000, xp_reward: int = 500, *, description: str = ""):
    """Create a new tournament"""
    tournament_id = _generate_tournament_id()
    
    tournament_data = {
        "title": title,
        "description": description,
        "host": ctx.author.id,
        "money_reward": money_reward,
        "xp_reward": xp_reward,
        "status": "recruiting",
        "participants": [],
        "created_at": datetime.now(timezone.utc).isoformat()
    }
    
    tournaments = _load_tournaments()
    tournaments[tournament_id] = tournament_data
    _save_tournaments(tournaments)
    
    embed = discord.Embed(
        title=f"{TOURNAMENT_EMOJI} {title}",
        description=description or "Join the tournament and prove your strength!",
        color=TOURNAMENT_COLOR
    )
    embed.add_field(name="Status", value="Recruiting", inline=True)
    embed.add_field(name="Participants", value="0", inline=True)
    embed.add_field(name="Rewards", value=f"{MONEY_ICON} {money_reward:,} | XP: {xp_reward:,}", inline=True)
    embed.set_footer(text="Use the buttons below to join/leave or start the tournament")
    
    view = TournamentLobbyView(tournament_id, ctx.author.id)
    await ctx.send(embed=embed, view=view)


@bot.hybrid_command(name="tournament_host", description="Admin: Create or take control of a tournament with full setup")
@app_commands.describe(
    action="Action to perform: 'create' for new tournament, 'control' to take control of existing",
    tournament_id="Tournament ID (required for 'control' action)",
    title="Tournament title (required for 'create' action)",
    money_reward="Money reward for winner (default: 10000)",
    xp_reward="XP reward for winner (default: 500)",
    description="Tournament description (optional)"
)
async def tournament_host(ctx, action: str, tournament_id: str = "", title: str = "", money_reward: int = 10000, xp_reward: int = 500, *, description: str = ""):
    """Create a new tournament or take control of an existing one - Admin only"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    # Additional check for create action - only admins can create tournaments
    if action.lower() == "create" and not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "Only administrators can create new tournaments.", 0xe74c3c)
        return
    
    try:
        tournaments = _load_tournaments()
        
        if action.lower() == "create":
            # Create new tournament
            if not title:
                await send_embed(ctx, "Tournament Creation", "Please provide a tournament title.", 0xe74c3c)
                return
            
            # Generate unique tournament ID
            new_tournament_id = _generate_tournament_id()
            
            tournament_data = {
                "title": title,
                "description": description or "Join the tournament and prove your strength!",
                "host": ctx.author.id,
                "money_reward": money_reward,
                "xp_reward": xp_reward,
                "status": "recruiting",
                "participants": [],
                "created_at": int(time.time()),
                "rewards": {
                    "money": money_reward,
                    "xp": xp_reward
                }
            }
            
            tournaments[new_tournament_id] = tournament_data
            _save_tournaments(tournaments)
            
            embed = discord.Embed(
                title=f"{TOURNAMENT_EMOJI} {title}",
                description=description or "Join the tournament and prove your strength!",
                color=TOURNAMENT_COLOR
            )
            embed.add_field(name="Status", value="Recruiting", inline=True)
            embed.add_field(name="Participants", value="0", inline=True)
            embed.add_field(name="Rewards", value=f"{MONEY_ICON} {money_reward:,} | XP: {xp_reward:,}", inline=True)
            embed.add_field(name="Tournament ID", value=f"`{new_tournament_id}`", inline=True)
            embed.add_field(name="Host", value=ctx.author.mention, inline=True)
            embed.set_footer(text="Use the buttons below to join/leave or start the tournament")
            
            view = TournamentLobbyView(new_tournament_id, ctx.author.id)
            await ctx.send(embed=embed, view=view)
            
        elif action.lower() == "control":
            # Take control of existing tournament
            if not tournament_id:
                await send_embed(ctx, "Tournament Control", "Please provide a tournament ID to take control of.", 0xe74c3c)
                return
            
            if tournament_id not in tournaments:
                await send_embed(ctx, "Tournament Not Found", f"No tournament found with ID: `{tournament_id}`", 0xe74c3c)
                return
            
            tournament = tournaments[tournament_id]
            
            # Check if tournament is already completed
            if tournament.get("status") == "completed":
                await send_embed(ctx, "Tournament Control", "This tournament has already been completed and cannot be modified.", 0xe74c3c)
                return
            
            # Take control of the tournament
            old_host = tournament.get("host")
            tournament["host"] = ctx.author.id
            
            # Save the updated tournament
            _save_tournaments(tournaments)
            
            embed = discord.Embed(title="🎮 Tournament Host Changed", color=0x2ecc71)
            embed.description = f"You are now the host of **{tournament['title']}**"
            embed.add_field(name="Tournament ID", value=f"`{tournament_id}`", inline=True)
            embed.add_field(name="Status", value=tournament.get("status", "unknown").title(), inline=True)
            embed.add_field(name="Participants", value=f"{len(tournament.get('participants', []))}", inline=True)
            embed.add_field(name="Rewards", value=f"{MONEY_ICON} {tournament.get('money_reward', 0):,} | XP: {tournament.get('xp_reward', 0):,}", inline=True)
            
            if old_host:
                old_host_member = ctx.guild.get_member(old_host)
                if old_host_member:
                    embed.add_field(name="Previous Host", value=old_host_member.mention, inline=True)
            
            embed.set_footer(text="You can now control this tournament using the tournament management commands")
            
            await ctx.send(embed=embed)
            
        else:
            await send_embed(ctx, "Tournament Host", "Invalid action. Use 'create' to create a new tournament or 'control' to take control of an existing one.", 0xe74c3c)
            
    except Exception as e:
        await send_embed(ctx, "Tournament Host Error", f"An error occurred: {str(e)}", 0xe74c3c)
        print(f"Error in tournament_host: {e}")
        import traceback
        traceback.print_exc()


@bot.command(name="tournament_manage")
@app_commands.describe(
    tournament_id="Tournament ID to manage",
    action="Action: 'pause', 'resume', 'cancel', 'edit_rewards', 'kick_player'",
    player_id="Player ID (for kick action)",
    money_reward="New money reward (for edit_rewards)",
    xp_reward="New XP reward (for edit_rewards)"
)
async def tournament_manage(ctx, tournament_id: str, action: str, player_id: str = "", money_reward: int = 0, xp_reward: int = 0):
    """Manage tournament settings and status - Host/Admin only"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        tournaments = _load_tournaments()
        
        if tournament_id not in tournaments:
            await send_embed(ctx, "Tournament Not Found", f"No tournament found with ID: `{tournament_id}`", 0xe74c3c)
            return
        
        tournament = tournaments[tournament_id]
        current_host = tournament.get("host")
        
        # Check if user is host or admin
        if ctx.author.id != current_host and not ctx.author.guild_permissions.administrator:
            await send_embed(ctx, "Access Denied", "Only the tournament host or an administrator can manage this tournament.", 0xe74c3c)
            return
        
        if action.lower() == "pause":
            if tournament.get("status") != "active":
                await send_embed(ctx, "Tournament Management", "Can only pause active tournaments.", 0xe74c3c)
                return
            
            tournament["status"] = "paused"
            tournament["paused_at"] = int(time.time())
            tournament["paused_by"] = ctx.author.id
            _save_tournaments(tournaments)
            
            await send_embed(ctx, "Tournament Paused", f"Tournament **{tournament.get('title', 'Unknown')}** has been paused.", 0xf1c40f)
            
        elif action.lower() == "resume":
            if tournament.get("status") != "paused":
                await send_embed(ctx, "Tournament Management", "Can only resume paused tournaments.", 0xe74c3c)
                return
            
            tournament["status"] = "active"
            if "paused_at" in tournament:
                del tournament["paused_at"]
            if "paused_by" in tournament:
                del tournament["paused_by"]
            _save_tournaments(tournaments)
            
            await send_embed(ctx, "Tournament Resumed", f"Tournament **{tournament.get('title', 'Unknown')}** has been resumed.", 0x2ecc71)
            
        elif action.lower() == "cancel":
            if tournament.get("status") in ["completed", "cancelled"]:
                await send_embed(ctx, "Tournament Management", "Cannot cancel completed or already cancelled tournaments.", 0xe74c3c)
                return
            
            tournament["status"] = "paused"
            tournament["cancelled_at"] = int(time.time())
            tournament["cancelled_by"] = ctx.author.id
            _save_tournaments(tournaments)
            
            await send_embed(ctx, "Tournament Cancelled", f"Tournament **{tournament.get('title', 'Unknown')}** has been cancelled.", 0xe74c3c)
            
        elif action.lower() == "edit_rewards":
            if tournament.get("status") != "recruiting":
                await send_embed(ctx, "Tournament Management", "Can only edit rewards for recruiting tournaments.", 0xe74c3c)
                return
            
            old_money = tournament.get("money_reward", 0)
            old_xp = tournament.get("xp_reward", 0)
            
            tournament["money_reward"] = money_reward
            tournament["xp_reward"] = xp_reward
            tournament["rewards"] = {"money": money_reward, "xp": xp_reward}
            _save_tournaments(tournaments)
            
            embed = discord.Embed(title="🏆 Tournament Rewards Updated", color=TOURNAMENT_COLOR)
            embed.description = f"**Tournament:** {tournament.get('title', 'Unknown')}"
            embed.add_field(name="Old Rewards", value=f"{MONEY_ICON} {old_money:,} | XP: {old_xp:,}", inline=True)
            embed.add_field(name="New Rewards", value=f"{MONEY_ICON} {money_reward:,} | XP: {xp_reward:,}", inline=True)
            embed.set_footer(text=f"Tournament ID: {tournament_id[:8]}...")
            
            await ctx.send(embed=embed)
            
        elif action.lower() == "kick_player":
            if not player_id:
                await send_embed(ctx, "Tournament Management", "Please provide a player ID to kick.", 0xe74c3c)
                return
            
            participants = tournament.get("participants", [])
            if int(player_id) not in participants:
                await send_embed(ctx, "Tournament Management", "Player is not in this tournament.", 0xe74c3c)
                return
            
            participants.remove(int(player_id))
            tournament["participants"] = participants
            _save_tournaments(tournaments)
            
            await send_embed(ctx, "Tournament Management", f"Player <@{player_id}> has been removed from the tournament.", 0xe74c3c)
            
        else:
            await send_embed(ctx, "Tournament Management", f"Invalid action '{action}'. Valid actions: pause, resume, cancel, edit_rewards, kick_player", 0xe74c3c)
            
    except Exception as e:
        await send_embed(ctx, "Tournament Management Error", f"An error occurred: {str(e)}", 0xe74c3c)
        print(f"Error in tournament_manage: {e}")
        import traceback
        traceback.print_exc()


@bot.command(name="tournament_status")
@app_commands.describe(tournament_id="Tournament ID to check")
async def tournament_status(ctx, tournament_id: str):
    """Get detailed status of a specific tournament"""
    try:
        tournaments = _load_tournaments()
        
        if tournament_id not in tournaments:
            await send_embed(ctx, "Tournament Not Found", f"No tournament found with ID: `{tournament_id}`", 0xe74c3c)
            return
        
        tournament = tournaments[tournament_id]
        
        embed = discord.Embed(title=f"🏆 {tournament.get('title', 'Tournament')} Status", color=TOURNAMENT_COLOR)
        embed.description = tournament.get("description", "No description available")
        
        # Basic info
        status = tournament.get("status", "unknown").title()
        participants = tournament.get("participants", [])
        host_id = tournament.get("host", 0)
        
        embed.add_field(name="Status", value=status, inline=True)
        embed.add_field(name="Participants", value=f"{len(participants)}", inline=True)
        embed.add_field(name="Host", value=f"<@{host_id}>", inline=True)
        
        # Rewards
        money_reward = tournament.get("money_reward", 0)
        xp_reward = tournament.get("xp_reward", 0)
        embed.add_field(name="Money Reward", value=f"{MONEY_ICON} {money_reward:,}", inline=True)
        embed.add_field(name="XP Reward", value=f"{xp_reward:,}", inline=True)
        
        # Tournament ID
        embed.add_field(name="Tournament ID", value=f"`{tournament_id}`", inline=False)
        
        # Timestamps
        created_at = tournament.get("created_at", 0)
        if created_at:
            embed.add_field(name="Created", value=f"<t:{created_at}:R>", inline=True)
        
        if tournament.get("status") == "active":
            current_round = tournament.get("current_round", 1)
            remaining = tournament.get("remaining_participants", len(participants))
            embed.add_field(name="Current Round", value=f"Round {current_round}", inline=True)
            embed.add_field(name="Remaining", value=f"{remaining}", inline=True)
        
        if tournament.get("status") == "completed":
            winner_id = tournament.get("winner_id", 0)
            completed_at = tournament.get("completed_at", 0)
            embed.add_field(name="Winner", value=f"<@{winner_id}>", inline=True)
            if completed_at:
                embed.add_field(name="Completed", value=f"<t:{completed_at}:R>", inline=True)
        
        # Participant list (if not too many)
        if participants and len(participants) <= 10:
            participant_list = ", ".join([f"<@{p}>" for p in participants])
            embed.add_field(name="Participants", value=participant_list, inline=False)
        
        embed.set_footer(text=f"Tournament ID: {tournament_id[:8]}...")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        await send_embed(ctx, "Tournament Status Error", f"An error occurred: {str(e)}", 0xe74c3c)
        print(f"Error in tournament_status: {e}")


@bot.command(name="tournament_list")
async def tournament_list(ctx):
    """List all tournaments"""
    tournaments = _load_tournaments()
    
    if not tournaments:
        return await send_embed(ctx, "Tournaments", "No tournaments found.", 0x95a5a6)
    
    embed = discord.Embed(title=f"{TOURNAMENT_EMOJI} Active Tournaments", color=TOURNAMENT_COLOR)
    
    for tournament_id, t in tournaments.items():
        participants = t.get("participants", [])
        status = t["status"].title()
        
        embed.add_field(
            name=f"{t['title']} ({status})",
            value=f"Participants: {len(participants)}\nRewards: {MONEY_ICON} {t['money_reward']:,} | XP: {t['xp_reward']:,}\nID: `{tournament_id}`",
            inline=False
        )
    
    await ctx.send(embed=embed)



# -----------------------
# Market Commands
# -----------------------




@bot.command(name="set_store_stock")
@commands.has_permissions(administrator=True)
async def set_store_stock(ctx, item_name: str, stock: int):
    """Set the stock of a store item"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    store = load_json(STORE_FILE)
    item_key = item_name.lower()
    
    if item_key not in store:
        await send_embed(ctx, "Item Not Found", f"Item '{item_name}' not found in the store.", 0xe74c3c)
        return
    
    old_stock = store[item_key].get("stock", 0)
    store[item_key]["stock"] = max(0, stock)
    save_json(STORE_FILE, store)
    
    embed = discord.Embed(title="Stock Updated", color=0x2ecc71)
    embed.description = f"**{item_name.title()}** stock changed from {old_stock} to {store[item_key]['stock']}"
    await ctx.send(embed=embed)


# -----------------------
# Quest System
# -----------------------

# Quest types and their requirements
QUEST_TYPES = {
    "daily": {
        "work": {
            "description": "Work {amount} times",
            "min_amount": 1,
            "max_amount": 6,
            "reward_type": "money",
            "reward_range": (100000, 300000)
        },
        "mine": {
            "description": "Mine {amount} ores", 
            "min_amount": 5,
            "max_amount": 10,
            "reward_type": "money",
            "reward_range": (100000, 300000)
        },
        "blacksmith": {
            "description": "Craft {amount} item(s)",
            "min_amount": 1,
            "max_amount": 3,
            "reward_type": "money", 
            "reward_range": (100000, 300000)
        },
        "cultivate": {
            "description": "Cultivate {amount} times",
            "min_amount": 1,
            "max_amount": 6,
            "reward_type": "money",
            "reward_range": (100000, 300000)
        },
        "collect": {
            "description": "Collect {amount} times",
            "min_amount": 5,
            "max_amount": 12,
            "reward_type": "money",
            "reward_range": (100000, 300000)
        }
    },
    "weekly": {
        "work": {
            "description": "Work {amount} times",
            "min_amount": 5,
            "max_amount": 10,
            "reward_type": "money",
            "reward_range": (500000, 1500000)
        },
        "mine": {
            "description": "Mine {amount} ores",
            "min_amount": 5,
            "max_amount": 10,
            "reward_type": "money", 
            "reward_range": (500000, 1500000)
        },
        "blacksmith": {
            "description": "Craft {amount} item(s)",
            "min_amount": 3,
            "max_amount": 8,
            "reward_type": "money",
            "reward_range": (500000, 1500000)
        },
        "cultivate": {
            "description": "Cultivate {amount} times",
            "min_amount": 5,
            "max_amount": 10,
            "reward_type": "money",
            "reward_range": (500000, 1500000)
        },
        "wealth": {
            "description": "Earn {amount} money from any source",
            "min_amount": 1000000,
            "max_amount": 5000000,
            "reward_type": "item",
            "reward_items": ["rare_weapon", "rare_armor", "rare_artifact", "epic_ore"]
        },
        "collect": {
            "description": "Collect {amount} times",
            "min_amount": 5,
            "max_amount": 10,
            "reward_type": "money",
            "reward_range": (500000, 1500000)
        }
    }
}

def generate_multi_objective_quest(quest_type: str, user_id: int) -> dict:
    """Generate a single quest with multiple objectives for a user"""
    if quest_type not in QUEST_TYPES:
        return None
    
    # Determine how many objectives based on quest type
    if quest_type == "daily":
        objective_count = 3
    else:  # weekly
        objective_count = 6
    
    # Select random quest categories (no duplicates)
    available_categories = list(QUEST_TYPES[quest_type].keys())
    if len(available_categories) < objective_count:
        # If we don't have enough unique categories, reduce the objective count
        objective_count = len(available_categories)
    
    selected_categories = random.sample(available_categories, objective_count)
    
    # Generate objectives for each category
    objectives = []
    for category in selected_categories:
        quest_template = QUEST_TYPES[quest_type][category]
        
        # Generate random amount
        amount = random.randint(quest_template["min_amount"], quest_template["max_amount"])
        
        objective = {
            "category": category,
            "description": quest_template["description"].format(amount=amount),
            "requirement": {
                "action": category,
                "amount": amount,
                "current": 0
            },
            "completed": False
        }
        objectives.append(objective)
    
    # Generate reward (better reward for more objectives)
    if quest_type == "daily":
        # Daily quest reward
        reward_amount = random.randint(100000, 500000)
        
        # Daily quests have a chance for items and rerolls
        reward_type = "money"
        bonus_rewards = []
        
        # 15% chance for item drop in daily quests
        if random.random() < 0.15:
            item_rewards = ["common_weapon", "uncommon_armor", "rare_artifact", "common_ore", "uncommon_material"]
            bonus_item = random.choice(item_rewards)
            bonus_rewards.append({"type": "item", "item": bonus_item})
            reward_type = "mixed"
        
        # 10% chance for immortal art reroll in daily quests
        if random.random() < 0.10:
            bonus_rewards.append({"type": "reroll", "amount": 1})
            reward_type = "mixed"
        
        if reward_type == "mixed":
            reward = {
                "type": "mixed",
                "money": reward_amount,
                "bonuses": bonus_rewards
            }
        else:
            reward = {"type": "money", "amount": reward_amount}
            
    else:
        # Weekly quest reward (better)
        reward_amount = random.randint(500000, 1500000)
        
        # Weekly quests have higher chances for items and rerolls
        reward_type = "money"
        bonus_rewards = []
        
        # 40% chance for item drop in weekly quests
        if random.random() < 0.40:
            item_rewards = ["uncommon_weapon", "rare_armor", "epic_artifact", "rare_ore", "epic_material", "legendary_weapon"]
            bonus_item = random.choice(item_rewards)
            bonus_rewards.append({"type": "item", "item": bonus_item})
            reward_type = "mixed"
        
        # 25% chance for immortal art reroll in weekly quests
        if random.random() < 0.25:
            reroll_amount = random.randint(1, 2)  # 1-2 rerolls for weekly quests
            bonus_rewards.append({"type": "reroll", "amount": reroll_amount})
            reward_type = "mixed"
        
        if reward_type == "mixed":
            reward = {
                "type": "mixed",
                "money": reward_amount,
                "bonuses": bonus_rewards
            }
        else:
            reward = {"type": "money", "amount": reward_amount}
    
    quest = {
        "id": f"{quest_type}_{user_id}_{int(time.time())}",
        "type": quest_type,
        "objectives": objectives,
        "all_objectives_completed": False,
        "reward": reward,
        "expires_at": time.time() + (86400 if quest_type == "daily" else 604800),  # 1 day or 1 week
        "created_at": time.time()
    }
    
    return quest



def get_user_quests(user_id: int) -> dict:
    """Get user's current quests"""
    try:
        with open(f"data/user_quests.json", "r") as f:
            quests_data = json.load(f)
        user_quests = quests_data.get(str(user_id), {"daily": [], "weekly": [], "cooldowns": {}})
        
        # Ensure cooldowns exist
        if "cooldowns" not in user_quests:
            user_quests["cooldowns"] = {}
        
        return user_quests
    except FileNotFoundError:
        return {"daily": [], "weekly": [], "cooldowns": {}}

def save_user_quests(user_id: int, quests: dict):
    """Save user's quests"""
    try:
        with open(f"data/user_quests.json", "r") as f:
            quests_data = json.load(f)
    except FileNotFoundError:
        quests_data = {}
    
    quests_data[str(user_id)] = quests
    
    # Ensure data directory exists
    os.makedirs("data", exist_ok=True)
    
    with open(f"data/user_quests.json", "w") as f:
        json.dump(quests_data, f, indent=2)

def check_quest_cooldown(user_id: int, quest_type: str) -> tuple[bool, int]:
    """Check if user can generate a new quest of the specified type.
    Returns (can_generate, seconds_remaining)"""
    quests = get_user_quests(user_id)
    cooldowns = quests.get("cooldowns", {})
    
    current_time = time.time()
    last_generated = cooldowns.get(quest_type, 0)
    
    if quest_type == "daily":
        cooldown_duration = 86400  # 24 hours
    elif quest_type == "weekly":
        cooldown_duration = 604800  # 7 days
    else:
        return True, 0
    
    time_elapsed = current_time - last_generated
    can_generate = time_elapsed >= cooldown_duration
    seconds_remaining = max(0, cooldown_duration - time_elapsed)
    
    return can_generate, seconds_remaining

def set_quest_cooldown(user_id: int, quest_type: str):
    """Set the cooldown timestamp for a quest type"""
    quests = get_user_quests(user_id)
    
    if "cooldowns" not in quests:
        quests["cooldowns"] = {}
    
    quests["cooldowns"][quest_type] = time.time()
    save_user_quests(user_id, quests)

def clean_corrupted_quests(user_id: int):
    """Clean up corrupted quest data for a user"""
    quests = get_user_quests(user_id)
    cleaned = False
    
    # Ensure cooldowns exist
    if "cooldowns" not in quests:
        quests["cooldowns"] = {}
    
    for quest_type in ["daily", "weekly"]:
        quest_list = quests.get(quest_type, [])
        if isinstance(quest_list, list):
            # Filter out corrupted quests
            original_count = len(quest_list)
            quest_list[:] = [q for q in quest_list if (
                isinstance(q, dict) and 
                q.get("objectives") and
                isinstance(q.get("objectives"), list) and
                q.get("reward")
            )]
            
            if len(quest_list) < original_count:
                cleaned = True
                print(f"Cleaned {original_count - len(quest_list)} corrupted quests for user {user_id}")
    
    if cleaned:
        save_user_quests(user_id, quests)
    
    return cleaned

def validate_quest_completion_status(user_id: int):
    """Validate and fix incorrect quest completion status"""
    quests = get_user_quests(user_id)
    fixed = False
    
    for quest_type in ["daily", "weekly"]:
        quest_list = quests.get(quest_type, [])
        if isinstance(quest_list, list):
            for quest in quest_list:
                if (isinstance(quest, dict) and 
                    quest.get("objectives") and
                    isinstance(quest["objectives"], list)):
                    
                    # Recalculate completion status based on actual objective completion
                    actual_completed = all(obj.get("completed", False) for obj in quest["objectives"])
                    stored_completed = quest.get("all_objectives_completed", False)
                    
                    # Fix if there's a mismatch
                    if actual_completed != stored_completed:
                        quest["all_objectives_completed"] = actual_completed
                        fixed = True
                        print(f"Fixed quest completion status for user {user_id}: {actual_completed} vs {stored_completed}")
    
    if fixed:
        save_user_quests(user_id, quests)
    
    return fixed

def check_quest_progress(user_id: int, action: str, amount: int = 1):
    """Check and update quest progress for a user"""
    quests = get_user_quests(user_id)
    
    # Clean corrupted quests first
    clean_corrupted_quests(user_id)
    
    # Validate quest completion status
    validate_quest_completion_status(user_id)
    
    for quest_type in ["daily", "weekly"]:
        quest_list = quests.get(quest_type, [])
        if isinstance(quest_list, list):
            for quest in quest_list:
                # Validate quest structure before accessing
                if (isinstance(quest, dict) and 
                    quest.get("objectives") and
                    isinstance(quest["objectives"], list)):
                    
                    # Check each objective
                    for objective in quest["objectives"]:
                        if (isinstance(objective, dict) and
                            objective.get("requirement") and
                            isinstance(objective["requirement"], dict) and
                            not objective.get("completed", False)):
                            
                            # Check if this is a wealth quest (money earning)
                            if objective["requirement"].get("action") == "wealth":
                                # For wealth quests, we need to track money earned
                                # This will be handled separately when money is added
                                continue
                            
                            # Check if action matches
                            if objective["requirement"].get("action") == action:
                                objective["requirement"]["current"] += amount
                                
                                # Check if objective is completed
                                if objective["requirement"]["current"] >= objective["requirement"]["amount"]:
                                    objective["completed"] = True
                    
                    # Calculate completion status AFTER processing all objectives
                    all_completed = all(obj.get("completed", False) for obj in quest["objectives"])
                    quest["all_objectives_completed"] = all_completed
                    save_user_quests(user_id, quests)

def check_wealth_quest_progress(user_id: int, money_earned: int):
    """Check and update wealth quest progress when money is earned"""
    quests = get_user_quests(user_id)
    
    for quest_type in ["daily", "weekly"]:
        quest_list = quests.get(quest_type, [])
        if isinstance(quest_list, list):
            for quest in quest_list:
                if (isinstance(quest, dict) and 
                    quest.get("objectives") and
                    isinstance(quest["objectives"], list)):
                    
                    for objective in quest["objectives"]:
                        if (isinstance(objective, dict) and
                            objective.get("requirement") and
                            isinstance(objective["requirement"], dict) and
                            objective["requirement"].get("action") == "wealth" and
                            not objective.get("completed", False)):
                            
                            objective["requirement"]["current"] += money_earned
                            
                            # Check if objective is completed
                            if objective["requirement"]["current"] >= objective["requirement"]["amount"]:
                                objective["completed"] = True
                    
                    # Calculate completion status AFTER processing all objectives
                    all_completed = all(obj.get("completed", False) for obj in quest["objectives"])
                    quest["all_objectives_completed"] = all_completed
                    save_user_quests(user_id, quests)

def format_quest_reward(reward: dict) -> str:
    """Format quest reward for display"""
    if reward["type"] == "money":
        return f"{MONEY_ICON} {reward['amount']:,}"
    elif reward["type"] == "mixed":
        money_text = f"{MONEY_ICON} {reward['money']:,}"
        bonus_texts = []
        
        for bonus in reward.get("bonuses", []):
            if bonus["type"] == "item":
                bonus_texts.append(f"🎁 {bonus['item'].replace('_', ' ').title()}")
            elif bonus["type"] == "reroll":
                bonus_texts.append(f"✨ {bonus['amount']} Immortal Art Reroll{'s' if bonus['amount'] > 1 else ''}")
        
        if bonus_texts:
            return f"{money_text} + {' + '.join(bonus_texts)}"
        else:
            return money_text
    else:
        return f"🎁 {reward['item'].replace('_', ' ').title()}"

# Quest command functions
@bot.hybrid_command(name="quests", description="View your current daily and weekly quests")
async def quests_cmd(ctx):
    """View your current daily and weekly quests"""
    user_id = ctx.author.id
    
    # Validate quest completion status first
    validate_quest_completion_status(user_id)
    
    quests = get_user_quests(user_id)
    
    embed = discord.Embed(title="📋 Your Quests", color=0x3498db)
    
    # Daily Quests
    daily_quests = quests.get("daily", [])
    if daily_quests:
        daily_text = ""
        for i, quest in enumerate(daily_quests, 1):
            # Validate quest structure
            if not isinstance(quest, dict) or "objectives" not in quest:
                daily_text += f"⚠️ **{i}.** Corrupted quest data - skipping\n"
                continue
            
            # Show quest with objectives
            objectives_completed = sum(1 for obj in quest.get("objectives", []) if obj.get("completed", False))
            total_objectives = len(quest.get("objectives", []))
            
            if quest.get("all_objectives_completed", False):
                daily_text += f"✅ **Daily Quest {i}** - ALL OBJECTIVES COMPLETED!\n"
            else:
                daily_text += f"⏳ **Daily Quest {i}** - {objectives_completed}/{total_objectives} objectives completed\n"
                
                # Show individual objectives
                for j, objective in enumerate(quest.get("objectives", []), 1):
                    if objective.get("completed", False):
                        daily_text += f"   ✅ **{j}.** {objective.get('description', 'Unknown')}\n"
                    else:
                        current = objective.get("requirement", {}).get("current", 0)
                        amount = objective.get("requirement", {}).get("amount", 1)
                        daily_text += f"   ⏳ **{j}.** {objective.get('description', 'Unknown')} - {current}/{amount}\n"
        
        embed.add_field(
            name=f"🌅 Daily Quest ({objectives_completed}/{total_objectives} objectives completed)", 
            value=daily_text, 
            inline=False
        )
    else:
        # Check cooldown for daily quests
        can_generate, seconds_remaining = check_quest_cooldown(user_id, "daily")
        if can_generate:
            daily_value = "No daily quest active. Use `/quest daily` to get one!"
        else:
            time_remaining = f"{seconds_remaining // 3600}h {(seconds_remaining % 3600) // 60}m"
            daily_value = f"⏳ **Cooldown Active** - Available in **{time_remaining}**\nDaily quests have a 24-hour cooldown."
        
        embed.add_field(name="🌅 Daily Quest", value=daily_value, inline=False)
    
    # Weekly Quests
    weekly_quests = quests.get("weekly", [])
    if weekly_quests:
        weekly_text = ""
        for i, quest in enumerate(weekly_quests, 1):
            # Validate quest structure
            if not isinstance(quest, dict) or "objectives" not in quest:
                weekly_text += f"⚠️ **{i}.** Corrupted quest data - skipping\n"
                continue
            
            # Show quest with objectives
            objectives_completed = sum(1 for obj in quest.get("objectives", []) if obj.get("completed", False))
            total_objectives = len(quest.get("objectives", []))
            
            if quest.get("all_objectives_completed", False):
                weekly_text += f"✅ **Weekly Quest {i}** - ALL OBJECTIVES COMPLETED!\n"
            else:
                weekly_text += f"⏳ **Weekly Quest {i}** - {objectives_completed}/{total_objectives} objectives completed\n"
                
                # Show individual objectives
                for j, objective in enumerate(quest.get("objectives", []), 1):
                    if objective.get("completed", False):
                        weekly_text += f"   ✅ **{j}.** {objective.get('description', 'Unknown')}\n"
                    else:
                        current = objective.get("requirement", {}).get("current", 0)
                        amount = objective.get("requirement", {}).get("amount", 1)
                        weekly_text += f"   ⏳ **{j}.** {objective.get('description', 'Unknown')} - {current}/{amount}\n"
        
        embed.add_field(
            name=f"📅 Weekly Quest ({objectives_completed}/{total_objectives} objectives completed)", 
            value=weekly_text, 
            inline=False
        )
    else:
        # Check cooldown for weekly quests
        can_generate, seconds_remaining = check_quest_cooldown(user_id, "weekly")
        if can_generate:
            weekly_value = "No weekly quest active. Use `/quest weekly` to get one!"
        else:
            days_remaining = seconds_remaining // 86400
            hours_remaining = (seconds_remaining % 86400) // 3600
            weekly_value = f"⏳ **Cooldown Active** - Available in **{days_remaining}d {hours_remaining}h**\nWeekly quests have a 7-day cooldown."
        
        embed.add_field(name="📅 Weekly Quest", value=weekly_value, inline=False)
    
    embed.set_footer(text="Complete quests to earn rewards!")
    await ctx.send(embed=embed)

@bot.hybrid_command(name="quest", description="Generate new daily or weekly quests")
@app_commands.describe(quest_type="Type of quest to generate (daily or weekly)")
async def quest_cmd(ctx, quest_type: str):
    """Generate new daily or weekly quests"""
    user_id = ctx.author.id
    quest_type = quest_type.lower()
    
    if quest_type not in ["daily", "weekly"]:
        return await send_embed(ctx, "Invalid Quest Type", "Please specify 'daily' or 'weekly'.", 0xe74c3c)
    
    # Check quest cooldown first
    can_generate, seconds_remaining = check_quest_cooldown(user_id, quest_type)
    if not can_generate:
        if quest_type == "daily":
            time_remaining = f"{seconds_remaining // 3600}h {(seconds_remaining % 3600) // 60}m"
            return await send_embed(ctx, "Daily Quest Cooldown", 
                                  f"You can generate a new daily quest in **{time_remaining}**.\n"
                                  f"Daily quests have a 24-hour cooldown.", 0xf39c12)
        else:
            days_remaining = seconds_remaining // 86400
            hours_remaining = (seconds_remaining % 86400) // 3600
            time_remaining = f"{days_remaining}d {hours_remaining}h"
            return await send_embed(ctx, "Weekly Quest Cooldown", 
                                  f"You can generate a new weekly quest in **{time_remaining}**.\n"
                                  f"Weekly quests have a 7-day cooldown.", 0xf39c12)
    
    current_quests = get_user_quests(user_id)
    
    # Check if user already has quests of this type
    existing_quests = current_quests.get(quest_type, [])
    if existing_quests:
        # Check if any existing quests are not completed (with validation)
        incomplete_quests = []
        for q in existing_quests:
            if isinstance(q, dict) and not q.get("all_objectives_completed", False):
                incomplete_quests.append(q)
        
        if incomplete_quests:
            return await send_embed(ctx, "Quest Already Active", f"You already have an incomplete {quest_type} quest. Complete all objectives first!", 0xe74c3c)
    
    # Generate single quest with multiple objectives
    new_quest = generate_multi_objective_quest(quest_type, user_id)
    if not new_quest:
        return await send_embed(ctx, "Quest Generation Error", "Failed to generate quest. Please try again.", 0xe74c3c)
    
    # Save quest (only 1 quest per type)
    current_quests[quest_type] = [new_quest]
    save_user_quests(user_id, current_quests)
    
    # Set cooldown for this quest type
    set_quest_cooldown(user_id, quest_type)
    
    # Create response embed
    embed = discord.Embed(title=f"🎯 New {quest_type.title()} Quest Generated!", color=0x2ecc71)
    embed.description = f"Generated a new {quest_type} quest with **{len(new_quest['objectives'])} objectives**!"
    
    # Show all objectives
    for i, objective in enumerate(new_quest['objectives'], 1):
        embed.add_field(
            name=f"Objective {i}", 
            value=f"**{objective['description']}**\nProgress: 0/{objective['requirement']['amount']}", 
            inline=True
        )
    
    # Show reward
    embed.add_field(
        name="🎁 Reward", 
        value=f"{format_quest_reward(new_quest['reward'])}", 
        inline=False
    )
    
    # Add expiration info
    embed.add_field(name="⏰ Expires", value="<t:" + str(int(new_quest['expires_at'])) + ":R>", inline=True)
    embed.set_footer(text=f"Complete all objectives to claim your reward! Use /quests to view progress")
    await ctx.send(embed=embed)

@bot.hybrid_command(name="claim_quest", description="Claim reward from a completed quest")
@app_commands.describe(quest_type="Type of quest to claim (daily or weekly)")
async def claim_quest_cmd(ctx, quest_type: str):
    """Claim reward from a completed quest"""
    user_id = ctx.author.id
    quest_type = quest_type.lower()
    
    if quest_type not in ["daily", "weekly"]:
        return await send_embed(ctx, "Invalid Quest Type", "Please specify 'daily' or 'weekly'.", 0xe74c3c)
    
    current_quests = get_user_quests(user_id)
    quest_list = current_quests.get(quest_type, [])
    
    if not quest_list:
        return await send_embed(ctx, "No Quests", f"You don't have any active {quest_type} quests.", 0xe74c3c)
    
    # Find completed but unclaimed quests (with validation)
    completed_quests = []
    for q in quest_list:
        if (isinstance(q, dict) and 
            q.get("all_objectives_completed") and 
            not q.get("claimed", False) and
            q.get("reward")):
            completed_quests.append(q)
    
    if not completed_quests:
        return await send_embed(ctx, "No Completed Quests", f"You don't have any completed {quest_type} quests to claim.", 0xe74c3c)
    
    # Claim all completed quests
    total_rewards = {"money": 0, "items": [], "rerolls": 0}
    
    for quest in completed_quests:
        # Validate quest structure before processing
        if not isinstance(quest, dict) or not quest.get("reward"):
            continue
            
        # Give reward
        reward = quest["reward"]
        if not isinstance(reward, dict) or "type" not in reward:
            continue
            
        if reward["type"] == "money":
            amount = reward.get("amount", 0)
            if amount > 0:
                add_cash(user_id, amount)
                total_rewards["money"] += amount
        elif reward["type"] == "mixed":
            money_amount = reward.get("money", 0)
            if money_amount > 0:
                add_cash(user_id, money_amount)
                total_rewards["money"] += money_amount
            
            # Process bonus rewards
            bonuses = reward.get("bonuses", [])
            for bonus in bonuses:
                if bonus["type"] == "item":
                    # Add item reward with better item generation
                    item_name = bonus.get("item", "Unknown Item")
                    
                    # Parse item type and rarity from the item name
                    item_parts = item_name.split("_")
                    if len(item_parts) >= 2:
                        rarity = item_parts[0]
                        item_type = item_parts[1]
                    else:
                        rarity = "common"
                        item_type = "artifact"
                    
                    # Generate better item based on type and rarity
                    if item_type == "weapon":
                        item_data = {
                            "name": f"{rarity.title()} Quest Weapon",
                            "type": "weapon",
                            "rarity": rarity,
                            "weapon_type": random.choice(list(WEAPON_TYPES.keys())),
                            "damage": random.randint(1, 10) if rarity == "common" else random.randint(5, 25),
                            "description": f"Quest reward weapon with {rarity} quality",
                            "value": 50000 if rarity == "common" else 100000,
                            "source": "quest_reward"
                        }
                    elif item_type == "armor":
                        item_data = {
                            "name": f"{rarity.title()} Quest Armor",
                            "type": "armor",
                            "rarity": rarity,
                            "armor_type": random.choice(list(ARMOR_TYPES.keys())),
                            "health": random.randint(1, 5) if rarity == "common" else random.randint(3, 15),
                            "description": f"Quest reward armor with {rarity} quality",
                            "value": 50000 if rarity == "common" else 100000,
                            "source": "quest_reward"
                        }
                    elif item_type == "ore":
                        item_data = {
                            "name": f"{rarity.title()} Quest Ore",
                            "type": "ore",
                            "rarity": rarity,
                            "amount": random.randint(1, 3),
                            "description": f"Quest reward ore with {rarity} quality",
                            "value": 25000 if rarity == "common" else 50000,
                            "source": "quest_reward"
                        }
                    else:
                        # Default artifact
                        item_data = {
                            "name": f"{rarity.title()} Quest Artifact",
                            "type": "artifact",
                            "rarity": rarity,
                            "abilities": ["damage", "defense"],
                            "description": f"Quest reward artifact with {rarity} quality",
                            "value": 50000 if rarity == "common" else 100000,
                            "source": "quest_reward"
                        }
                    
                    add_item_to_inventory(user_id, item_data)
                    total_rewards["items"].append(item_data["name"])
                    
                elif bonus["type"] == "reroll":
                    # Add immortal art rerolls
                    reroll_amount = bonus.get("amount", 1)
                    user_meta = get_user_meta(user_id)
                    if "immortal_arts" not in user_meta:
                        user_meta["immortal_arts"] = {"slots": [None, None, None], "rerolls": 0, "unlocked_slots": 1}
                    
                    current_rerolls = user_meta["immortal_arts"].get("rerolls", 0)
                    user_meta["immortal_arts"]["rerolls"] = current_rerolls + reroll_amount
                    set_user_meta(user_id, user_meta)
                    
                    # Track rerolls in total rewards
                    if "rerolls" not in total_rewards:
                        total_rewards["rerolls"] = 0
                    total_rewards["rerolls"] += reroll_amount
        elif reward["type"] == "item":
            # Add item reward with better item generation
            item_name = reward.get("item", "Unknown Item")
            
            # Parse item type and rarity from the item name
            item_parts = item_name.split("_")
            if len(item_parts) >= 2:
                rarity = item_parts[0]
                item_type = item_parts[1]
            else:
                rarity = "rare"
                item_type = "artifact"
            
            # Generate better item based on type and rarity
            if item_type == "weapon":
                item_data = {
                    "name": f"{rarity.title()} Quest Weapon",
                    "type": "weapon",
                    "rarity": rarity,
                    "weapon_type": random.choice(list(WEAPON_TYPES.keys())),
                    "damage": random.randint(5, 25),
                    "description": f"Quest reward weapon with {rarity} quality",
                    "value": 100000,
                    "source": "quest_reward"
                }
            elif item_type == "armor":
                item_data = {
                    "name": f"{rarity.title()} Quest Armor",
                    "type": "armor",
                    "rarity": rarity,
                    "armor_type": random.choice(list(ARMOR_TYPES.keys())),
                    "health": random.randint(3, 15),
                    "description": f"Quest reward armor with {rarity} quality",
                    "value": 100000,
                    "source": "quest_reward"
                }
            elif item_type == "ore":
                item_data = {
                    "name": f"{rarity.title()} Quest Ore",
                    "type": "ore",
                    "rarity": rarity,
                    "amount": random.randint(1, 3),
                    "description": f"Quest reward ore with {rarity} quality",
                    "value": 50000,
                    "source": "quest_reward"
                }
            else:
                # Default artifact
                item_data = {
                    "name": f"{rarity.title()} Quest Artifact",
                    "type": "artifact",
                    "rarity": rarity,
                    "abilities": ["damage", "defense"],
                    "description": f"Quest reward artifact with {rarity} quality",
                    "value": 100000,
                    "source": "quest_reward"
                }
            
            add_item_to_inventory(user_id, item_data)
            total_rewards["items"].append(item_data["name"])
        
        # Mark quest as claimed
        quest["claimed"] = True
    
    # Save updated quests
    save_user_quests(user_id, current_quests)
    
    # Reset cooldown when quest is completed and claimed
    # This allows players to get new quests immediately after completing the previous ones
    set_quest_cooldown(user_id, quest_type)
    
    # Create success embed
    embed = discord.Embed(title="🎉 Quest Rewards Claimed!", color=0x2ecc71)
    embed.description = f"Successfully claimed rewards from **{len(completed_quests)}** {quest_type} quest(s)!"
    
    # Show rewards summary
    rewards_text = ""
    if total_rewards["money"] > 0:
        rewards_text += f"💰 **Money:** {MONEY_ICON} {total_rewards['money']:,}\n"
    if total_rewards["items"]:
        rewards_text += f"🎁 **Items:** {', '.join(total_rewards['items'])}\n"
    if total_rewards.get("rerolls", 0) > 0:
        rewards_text += f"✨ **Immortal Art Rerolls:** +{total_rewards['rerolls']}\n"
    
    embed.add_field(name="🎁 Rewards Received", value=rewards_text, inline=False)
    embed.add_field(name="💡 Next Step", value=f"Generate new {quest_type} quests with `/quest {quest_type}`", inline=False)
    
    embed.set_footer(text="Keep completing quests for more rewards!")
    await ctx.send(embed=embed)






@bot.hybrid_command(name="quest_cooldown", description="Check cooldown status for daily and weekly quests")
async def quest_cooldown_cmd(ctx):
    """Check when you can generate new quests"""
    user_id = ctx.author.id
    
    embed = discord.Embed(title="⏰ Quest Cooldown Status", color=0x3498db)
    
    # Check daily quest cooldown
    daily_can_generate, daily_remaining = check_quest_cooldown(user_id, "daily")
    if daily_can_generate:
        daily_status = "✅ **Available Now**"
    else:
        daily_hours = daily_remaining // 3600
        daily_minutes = (daily_remaining % 3600) // 60
        daily_status = f"⏳ **Cooldown Active** - Available in **{daily_hours}h {daily_minutes}m**"
    
    # Check weekly quest cooldown
    weekly_can_generate, weekly_remaining = check_quest_cooldown(user_id, "weekly")
    if weekly_can_generate:
        weekly_status = "✅ **Available Now**"
    else:
        weekly_days = weekly_remaining // 86400
        weekly_hours = (weekly_remaining % 86400) // 3600
        weekly_status = f"⏳ **Cooldown Active** - Available in **{weekly_days}d {weekly_hours}h**"
    
    embed.add_field(name="🌅 Daily Quest", value=daily_status, inline=True)
    embed.add_field(name="📅 Weekly Quest", value=weekly_status, inline=True)
    
    embed.add_field(
        name="📋 Cooldown Rules", 
        value="• **Daily Quests:** 24-hour cooldown\n• **Weekly Quests:** 7-day cooldown\n• Cooldowns reset when you complete and claim quests",
        inline=False
    )
    
    embed.set_footer(text="Use /quest daily or /quest weekly to generate new quests when available")
    await ctx.send(embed=embed)



# -----------------------
# Admin Reset Commands
# -----------------------

@bot.command(name="reset_economy")
@commands.has_permissions(administrator=True)
async def reset_economy(ctx):
    """Reset all users' money to 0 - Admin only"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        # Get all user files
        data_dir = "data"
        user_files = [f for f in os.listdir(data_dir) if f.startswith("user_") and f.endswith(".json")]
        
        reset_count = 0
        total_users = len(user_files)
        
        # Show confirmation
        embed = discord.Embed(title="⚠️ Economy Reset Confirmation", color=0xf39c12)
        embed.description = f"This will reset **ALL** users' money to 0.\n\n**Found {total_users} users**\n\nAre you sure you want to continue?"
        embed.add_field(name="⚠️ Warning", value="This action cannot be undone!", inline=False)
        embed.set_footer(text="React with ✅ to confirm or ❌ to cancel")
        
        msg = await ctx.send(embed=embed)
        await msg.add_reaction("✅")
        await msg.add_reaction("❌")
        
        def check(reaction, user):
            return user == ctx.author and str(reaction.emoji) in ["✅", "❌"] and reaction.message.id == msg.id
        
        try:
            reaction, user = await bot.wait_for('reaction_add', timeout=30.0, check=check)
            
            if str(reaction.emoji) == "✅":
                # User confirmed - proceed with reset
                await msg.edit(embed=discord.Embed(title="🔄 Resetting Economy...", description="Processing users...", color=0x3498db))
                
                for user_file in user_files:
                    try:
                        user_id = int(user_file.split("_")[1].split(".")[0])
                        user_meta = get_user_meta(user_id)
                        
                        # Reset money
                        if "stats" in user_meta:
                            user_meta["stats"]["cash"] = 0
                            user_meta["stats"]["bank"] = 0
                            set_user_meta(user_id, user_meta)
                            reset_count += 1
                    except Exception as e:
                        print(f"Error resetting user {user_file}: {e}")
                        continue
                
                # Success embed
                success_embed = discord.Embed(title="✅ Economy Reset Complete!", color=0x2ecc71)
                success_embed.description = f"Successfully reset money for **{reset_count} users**"
                success_embed.add_field(name="Users Processed", value=f"{reset_count}/{total_users}", inline=True)
                success_embed.add_field(name="Reset By", value=ctx.author.mention, inline=True)
                success_embed.add_field(name="💰 All Money Reset", value="Cash: 0 | Bank: 0", inline=False)
                success_embed.set_footer(text="All users now start with 0 money")
                
                await msg.edit(embed=success_embed)
                
            else:
                # User cancelled
                await msg.edit(embed=discord.Embed(title="❌ Economy Reset Cancelled", description="No changes were made.", color=0xe74c3c))
                
        except asyncio.TimeoutError:
            await msg.edit(embed=discord.Embed(title="⏰ Timeout", description="No response received. Economy reset cancelled.", color=0x95a5a6))
            
    except Exception as e:
        await send_embed(ctx, "Economy Reset Error", f"An error occurred: {str(e)}", 0xe74c3c)
        print(f"Error in reset_economy: {e}")


@bot.command(name="reset_sect")
@commands.has_permissions(administrator=True)
async def reset_sect(ctx, sect_name: str):
    """Reset a sect's upgrades and increase prices by 10x - Admin only"""
    if not ctx.author.guild_permissions.administrator:
        await send_embed(ctx, "Access Denied", "This command is for administrators only.", 0xe74c3c)
        return
    
    try:
        # Load sects data
        sects = load_json(SECTS_FILE)
        
        if sect_name not in sects:
            await send_embed(ctx, "Sect Not Found", f"No sect found with name '{sect_name}'.", 0xe74c3c)
            return
        
        sect_data = sects[sect_name]
        
        # Show confirmation
        embed = discord.Embed(title="⚠️ Sect Reset Confirmation", color=0xf39c12)
        embed.description = f"This will reset **{sect_name}**'s upgrades and increase all prices by 10x.\n\n**Current Sect Info:**"
        embed.add_field(name="Leader", value=f"<@{sect_data.get('leader', 'Unknown')}>", inline=True)
        embed.add_field(name="Members", value=f"{len(sect_data.get('members', []))}", inline=True)
        embed.add_field(name="Level", value=f"{sect_data.get('level', 1)}", inline=True)
        embed.add_field(name="⚠️ Warning", value="This action cannot be undone!", inline=False)
        embed.set_footer(text="React with ✅ to confirm or ❌ to cancel")
        
        msg = await ctx.send(embed=embed)
        await msg.add_reaction("✅")
        await msg.add_reaction("❌")
        
        def check(reaction, user):
            return user == ctx.author and str(reaction.emoji) in ["✅", "❌"] and reaction.message.id == msg.id
        
        try:
            reaction, user = await bot.wait_for('reaction_add', timeout=30.0, check=check)
            
            if str(reaction.emoji) == "✅":
                # User confirmed - proceed with reset
                await msg.edit(embed=discord.Embed(title="🔄 Resetting Sect...", description="Processing sect reset...", color=0x3498db))
                
                # Reset sect upgrades
                original_level = sect_data.get('level', 1)
                original_xp = sect_data.get('xp', 0)
                
                sect_data['level'] = 1
                sect_data['xp'] = 0
                sect_data['upgrades'] = {}
                sect_data['sect_shop'] = {}
                
                # Save updated sect data
                sects[sect_name] = sect_data
                save_json(SECTS_FILE, sects)
                
                # Now increase sect shop prices by 10x
                sect_shop = load_json(SECT_SHOP_FILE)
                
                for upgrade_key, upgrade_data in sect_shop.items():
                    if isinstance(upgrade_data, dict) and 'price' in upgrade_data:
                        original_price = upgrade_data['price']
                        upgrade_data['price'] = original_price * 10
                        print(f"Increased {upgrade_key} price from {original_price:,} to {upgrade_data['price']:,}")
                
                # Save updated sect shop
                save_json(SECT_SHOP_FILE, sect_shop)
                
                # Also increase immortal art reroll slot prices by 10x
                # Update the constant in the code
                global IMMORTAL_ART_REROLL_COST
                original_reroll_cost = IMMORTAL_ART_REROLL_COST
                IMMORTAL_ART_REROLL_COST = original_reroll_cost * 10
                print(f"Increased immortal art reroll cost from {original_reroll_cost:,} to {IMMORTAL_ART_REROLL_COST:,}")
                
                # Success embed
                success_embed = discord.Embed(title="✅ Sect Reset Complete!", color=0x2ecc71)
                success_embed.description = f"Successfully reset **{sect_name}** and increased all prices by 10x"
                success_embed.add_field(name="Sect Reset", value=f"Level: {original_level} → 1\nXP: {original_xp:,} → 0", inline=True)
                success_embed.add_field(name="Upgrades", value="All upgrades reset", inline=True)
                success_embed.add_field(name="Price Increase", value="All sect shop prices ×10", inline=True)
                success_embed.add_field(name="Reset By", value=ctx.author.mention, inline=True)
                success_embed.add_field(name="💰 Immortal Art Slots", value=f"Reroll cost: {original_reroll_cost:,} → {IMMORTAL_ART_REROLL_COST:,}", inline=True)
                success_embed.set_footer(text=f"Sect {sect_name} has been completely reset")
                
                await msg.edit(embed=success_embed)
                
            else:
                # User cancelled
                await msg.edit(embed=discord.Embed(title="❌ Sect Reset Cancelled", description="No changes were made.", color=0xe74c3c))
                
        except asyncio.TimeoutError:
            await msg.edit(embed=discord.Embed(title="⏰ Timeout", description="No response received. Sect reset cancelled.", color=0x95a5a6))
            
    except Exception as e:
        await send_embed(ctx, "Sect Reset Error", f"An error occurred: {str(e)}", 0xe74c3c)
        print(f"Error in reset_sect: {e}")


# -----------------------
# Test JSON system if run directly
# -----------------------
if __name__ == "__main__":
    try:
         print("🧪 Testing JSON system...")
         
         # Test user ID
         test_user_id = 12345
         
         # Test saving and loading
         test_inventory = [{"name": "Test Sword", "rarity": "common"}]
         test_equipment = {"weapon": None, "armor": None, "artifacts": []}
         test_stats = {"cash": 100, "bank": 50}
         
         print("Saving test data...")
         # Use the old system for consistency - save to economy.json
         test_meta = get_user_meta(test_user_id)
         test_meta["inventory"] = test_inventory
         test_meta["equipment"] = test_equipment
         test_meta["attributes"] = test_stats
         set_user_meta(test_user_id, test_meta)
         
         print("Loading test data...")
         # Load from the same system
         loaded_meta = get_user_meta(test_user_id)
         loaded_inventory = loaded_meta.get("inventory", [])
         loaded_equipment = loaded_meta.get("equipment", {})
         loaded_stats = loaded_meta.get("attributes", {})
         
         print(f"Inventory: {loaded_inventory}")
         print(f"Equipment: {loaded_equipment}")
         print(f"Stats: {loaded_stats}")
         
         print("✅ JSON system test complete!")
         print("Starting bot(s)...")

         print(f"SECONDARY_BOT_ENABLED: {SECONDARY_BOT_ENABLED}")
         print(f"paired_bot exists: {paired_bot is not None}")
         
         if SECONDARY_BOT_ENABLED and paired_bot is not None:
             print("Setting up dual-bot mode...")
             
             # Secondary bot commands defined at global level for proper scope access
             print("Setting up secondary bot commands...")
             
             # Enhanced autocomplete functions for secondary bot
             async def rarity_autocomplete(interaction: discord.Interaction, current: str):
                 rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic"]
                 filtered = [r for r in rarities if current.lower() in r.lower()]
                 return [app_commands.Choice(name=r.title(), value=r) for r in filtered[:25]]
             
             async def item_type_autocomplete(interaction: discord.Interaction, current: str):
                 types = ["weapon", "armor", "artifact", "consumable", "material", "currency"]
                 filtered = [t for t in types if current.lower() in t.lower()]
                 return [app_commands.Choice(name=t.title(), value=t) for t in filtered[:25]]
             
             async def sect_autocomplete(interaction: discord.Interaction, current: str):
                 try:
                     import json
                     import os
                     
                     sect_file = "data/sects.json"
                     if not os.path.exists(sect_file):
                         return []
                     
                     with open(sect_file, 'r') as f:
                         data = json.load(f)
                     
                     sects = list(data.keys())
                     filtered = [s for s in sects if current.lower() in s.lower()]
                     return [app_commands.Choice(name=s, value=s) for s in filtered[:25]]
                 except:
                     return []
             
             async def store_item_autocomplete(interaction: discord.Interaction, current: str):
                 try:
                     import json
                     import os
                     
                     store_file = "data/store.json"
                     if not os.path.exists(store_file):
                         return []
                     
                     with open(store_file, 'r') as f:
                         data = json.load(f)
                     
                     items = list(data.keys())
                     filtered = [i for i in items if current.lower() in i.lower()]
                     return [app_commands.Choice(name=i, value=i) for i in filtered[:25]]
                 except:
                     return []
             
             # User inventory autocomplete with real-time data
             async def user_inventory_autocomplete(interaction: discord.Interaction, current: str):
                 try:
                     user_id = interaction.namespace.user
                     if not user_id:
                         return []
                     
                     # Use the old system for consistency
                     user_meta = get_user_meta(user_id)
                     user_inv = user_meta.get("inventory", [])
                     filtered = [item['name'] for item in user_inv if current.lower() in item['name'].lower()]
                     
                     choices = []
                     for item in filtered[:25]:
                         item_data = next((i for i in user_inv if i['name'] == item), None)
                         if item_data:
                             rarity = item_data.get('rarity', 'unknown')
                             display_name = f"{item} ({rarity})"
                             choices.append(app_commands.Choice(name=display_name, value=item))
                     
                     return choices
                 except Exception as e:
                     print(f"Autocomplete error: {e}")
                     return []
             
             # Enhanced autocomplete functions for inventory system
             async def weapon_type_autocomplete(interaction: discord.Interaction, current: str):
                 weapon_types = ["sword", "axe", "dagger", "staff", "bow", "spear", "hammer", "whip"]
                 filtered = [w for w in weapon_types if current.lower() in w.lower()]
                 return [app_commands.Choice(name=w.title(), value=w) for w in filtered[:25]]
             
             async def armor_type_autocomplete(interaction: discord.Interaction, current: str):
                 armor_types = ["leather", "chainmail", "plate", "robe", "scale", "bone"]
                 filtered = [a for a in armor_types if current.lower() in a.lower()]
                 return [app_commands.Choice(name=a.title(), value=a) for a in filtered[:25]]
             
             async def artifact_type_autocomplete(interaction: discord.Interaction, current: str):
                 artifact_types = ["ring", "amulet", "crystal", "scroll", "orb", "talisman"]
                 filtered = [ar for ar in artifact_types if current.lower() in ar.lower()]
                 return [app_commands.Choice(name=ar.title(), value=ar) for ar in filtered[:25]]
             
             async def enhanced_rarity_autocomplete(interaction: discord.Interaction, current: str):
                 rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]
                 filtered = [r for r in rarities if current.lower() in r.lower()]
                 return [app_commands.Choice(name=r.title(), value=r) for r in filtered[:25]]
             
             # Enhanced inventory add command with full validation and autocomplete (HIDDEN)
             @paired_bot.tree.command(name="admin_inventory_add", description="Add item to user inventory with full validation (Admin only)")
             @app_commands.describe(
                 user="User to add item to",
                 item_type="Type of item to add",
                 item_name="Specific item name",
                 rarity="Item rarity level"
             )
             @app_commands.autocomplete(
                 item_type=item_type_autocomplete,
                 rarity=enhanced_rarity_autocomplete
             )
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_inventory_add(ctx: commands.Context, user: discord.Member, item_type: str, item_name: str, rarity: str = "common"):
                 """Enhanced inventory add command with full validation"""
                 try:
                     # Validate item type
                     if item_type.lower() not in ["weapon", "armor", "artifact", "material"]:
                         await ctx.send("❌ **Invalid Item Type**\nAvailable types: `weapon`, `armor`, `artifact`, `material`")
                         return
                     
                     # Validate rarity for equipment
                     valid_rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]
                     if item_type.lower() != "material" and rarity.lower() not in valid_rarities:
                         available_rarities = ", ".join(valid_rarities)
                         await ctx.send(f"❌ **Invalid Rarity**\nAvailable rarities: `{available_rarities}`")
                         return
                     
                     # Validate specific item types
                     if item_type.lower() == "weapon":
                         weapon_types = ["sword", "axe", "dagger", "staff", "bow", "spear", "hammer", "whip"]
                         if item_name.lower() not in weapon_types:
                             available_types = ", ".join(weapon_types)
                             await ctx.send(f"❌ **Invalid Weapon Type**\nAvailable types: `{available_types}`")
                             return
                     elif item_type.lower() == "armor":
                         armor_types = ["leather", "chainmail", "plate", "robe", "scale", "bone"]
                         if item_name.lower() not in armor_types:
                             available_types = ", ".join(armor_types)
                             await ctx.send(f"❌ **Invalid Armor Type**\nAvailable types: `{available_types}`")
                             return
                     elif item_type.lower() == "artifact":
                         artifact_types = ["ring", "amulet", "crystal", "scroll", "orb", "talisman"]
                         if item_name.lower() not in artifact_types:
                             available_types = ", ".join(artifact_types)
                             await ctx.send(f"❌ **Invalid Artifact Type**\nAvailable types: `{available_types}`")
                             return
                     
                     # Generate or create the item directly (same as primary bot)
                     if item_type.lower() == "material":
                         item = item_name
                     elif item_type.lower() == "weapon":
                         item = generate_weapon(item_name.lower(), rarity.lower())
                     elif item_type.lower() == "armor":
                         item = generate_armor(item_name.lower(), rarity.lower())
                     else:  # artifact
                         item = generate_artifact(item_name.lower(), rarity.lower())
                     
                     # Add to user's inventory using the same system as regular commands
                     user_id = user.id
                     inventory = load_user_inventory(user_id)
                     inventory.append(item)
                     save_user_inventory(user_id, inventory)
                     
                     # Create success embed (same as primary bot)
                     if item_type.lower() == "material":
                         embed = discord.Embed(
                             title="✅ Material Added!",
                             description=f"Successfully added **{item_name}** to {user.mention}'s inventory",
                             color=0x2ecc71
                         )
                         embed.add_field(name="📦 Item", value=item_name, inline=True)
                         embed.add_field(name="📊 Type", value="Material", inline=True)
                     else:
                         rarity_emoji = RARITY_EMOJI.get(rarity.lower(), "⚪")
                         embed = discord.Embed(
                             title="✅ Equipment Added!",
                             description=f"Successfully added {rarity_emoji} **{item['name']}** to {user.mention}'s inventory",
                             color=0x2ecc71
                         )
                         
                         if item_type.lower() == "weapon":
                             embed.add_field(name="⚔️ Weapon Stats", value=f"Damage: {item['damage']}", inline=True)
                         elif item_type.lower() == "armor":
                             embed.add_field(name="🛡️ Armor Stats", value=f"Health: {item['health']}", inline=True)
                         elif item_type.lower() == "artifact":
                             embed.add_field(name="✨ Abilities", value=", ".join(item["abilities"]), inline=True)
                         
                         embed.add_field(name="💰 Value", value=f"{MONEY_ICON} {item['value']:,}", inline=True)
                         embed.add_field(name="📊 Type", value=item_type.title(), inline=True)
                     
                     embed.add_field(name="👤 User", value=user.mention, inline=True)
                     embed.add_field(name="👑 Admin", value=ctx.author.mention, inline=True)
                     
                     embed.set_footer(text=f"Item added to {user.display_name}'s inventory")
                     await ctx.send(embed=embed)
                     
                 except Exception as e:
                     await ctx.send(f"❌ **Error adding item**: {str(e)}")
                     print(f"Inventory add error: {e}")
             
             # Enhanced inventory add with weapon-specific autocomplete (HIDDEN)
             @paired_bot.tree.command(name="admin_inventory_add_weapon", description="Add weapon to user inventory (Admin only)")
             @app_commands.describe(
                 user="User to add weapon to",
                 weapon_type="Type of weapon",
                 rarity="Weapon rarity"
             )
             @app_commands.autocomplete(
                 weapon_type=weapon_type_autocomplete,
                 rarity=enhanced_rarity_autocomplete
             )
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_inventory_add_weapon(interaction: discord.Interaction, user: discord.Member, weapon_type: str, rarity: str):
                 """Add weapon with weapon-specific autocomplete"""
                 try:
                     # Validate weapon type
                     weapon_types = ["sword", "axe", "dagger", "staff", "bow", "spear", "hammer", "whip"]
                     if weapon_type.lower() not in weapon_types:
                         available_types = ", ".join(weapon_types)
                         await interaction.response.send_message(f"❌ **Invalid Weapon Type**\nAvailable types: `{available_types}`")
                         return
                     
                     # Validate rarity
                     valid_rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]
                     if rarity.lower() not in valid_rarities:
                         available_rarities = ", ".join(valid_rarities)
                         await interaction.response.send_message(f"❌ **Invalid Rarity**\nAvailable rarities: `{available_rarities}`")
                         return
                     
                     # Generate the weapon
                     item = generate_weapon(weapon_type.lower(), rarity.lower())
                     
                     # Add to user's inventory using the old system for compatibility
                     user_id = user.id
                     meta = get_user_meta(user_id)
                     if "inventory" not in meta:
                         meta["inventory"] = []
                     meta["inventory"].append(item)
                     set_user_meta(user_id, meta)
                     
                     # Create success embed
                     rarity_emoji = RARITY_EMOJI.get(rarity.lower(), "⚪")
                     embed = discord.Embed(
                         title="✅ Weapon Added!",
                         description=f"Successfully added {rarity_emoji} **{item['name']}** to {user.mention}'s inventory",
                         color=0x2ecc71
                     )
                     embed.add_field(name="⚔️ Weapon Stats", value=f"Damage: {item['damage']}", inline=True)
                     embed.add_field(name="💰 Value", value=f"{MONEY_ICON} {item['value']:,}", inline=True)
                     embed.add_field(name="👤 User", value=user.mention, inline=True)
                     embed.add_field(name="👑 Admin", value=interaction.user.mention, inline=True)
                     embed.set_footer(text=f"Weapon added to {user.display_name}'s inventory")
                     await interaction.response.send_message(embed=embed)
                     
                 except Exception as e:
                     await interaction.response.send_message(f"❌ **Error adding weapon**: {str(e)}")
                     print(f"Weapon add error: {e}")
             
             # Enhanced inventory add with armor-specific autocomplete (HIDDEN)
             @paired_bot.tree.command(name="admin_inventory_add_armor", description="Add armor to user inventory (Admin only)")
             @app_commands.describe(
                 user="User to add armor to",
                 armor_type="Type of armor",
                 rarity="Armor rarity"
             )
             @app_commands.autocomplete(
                 armor_type=armor_type_autocomplete,
                 rarity=enhanced_rarity_autocomplete
             )
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_inventory_add_armor(interaction: discord.Interaction, user: discord.Member, armor_type: str, rarity: str):
                 """Add armor with armor-specific autocomplete"""
                 try:
                     # Validate armor type
                     armor_types = ["leather", "chainmail", "plate", "robe", "scale", "bone"]
                     if armor_type.lower() not in armor_types:
                         available_types = ", ".join(armor_types)
                         await interaction.response.send_message(f"❌ **Invalid Armor Type**\nAvailable types: `{available_types}`")
                         return
                     
                     # Validate rarity
                     valid_rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]
                     if rarity.lower() not in valid_rarities:
                         available_rarities = ", ".join(valid_rarities)
                         await interaction.response.send_message(f"❌ **Invalid Rarity**\nAvailable rarities: `{available_rarities}`")
                         return
                     
                     # Generate the armor
                     item = generate_armor(armor_type.lower(), rarity.lower())
                     
                     # Add to user's inventory using the old system for compatibility
                     user_id = user.id
                     meta = get_user_meta(user_id)
                     if "inventory" not in meta:
                         meta["inventory"] = []
                     meta["inventory"].append(item)
                     set_user_meta(user_id, meta)
                     
                     # Create success embed
                     rarity_emoji = RARITY_EMOJI.get(rarity.lower(), "⚪")
                     embed = discord.Embed(
                         title="✅ Armor Added!",
                         description=f"Successfully added {rarity_emoji} **{item['name']}** to {user.mention}'s inventory",
                         color=0x2ecc71
                     )
                     embed.add_field(name="🛡️ Armor Stats", value=f"Health: {item['health']}", inline=True)
                     embed.add_field(name="💰 Value", value=f"{MONEY_ICON} {item['value']:,}", inline=True)
                     embed.add_field(name="👤 User", value=user.mention, inline=True)
                     embed.add_field(name="👑 Admin", value=interaction.user.mention, inline=True)
                     embed.set_footer(text=f"Armor added to {user.display_name}'s inventory")
                     await interaction.response.send_message(embed=embed)
                     
                 except Exception as e:
                     await interaction.response.send_message(f"❌ **Error adding armor**: {str(e)}")
                     print(f"Armor add error: {e}")
             
             # Enhanced inventory add with artifact-specific autocomplete (HIDDEN)
             @paired_bot.tree.command(name="admin_inventory_add_artifact", description="Add artifact to user inventory (Admin only)")
             @app_commands.describe(
                 user="User to add artifact to",
                 artifact_type="Type of artifact",
                 rarity="Artifact rarity"
             )
             @app_commands.autocomplete(
                 artifact_type=artifact_type_autocomplete,
                 rarity=enhanced_rarity_autocomplete
             )
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_inventory_add_artifact(interaction: discord.Interaction, user: discord.Member, artifact_type: str, rarity: str):
                 """Add artifact with artifact-specific autocomplete"""
                 try:
                     # Validate artifact type
                     artifact_types = ["ring", "amulet", "crystal", "scroll", "orb", "talisman"]
                     if artifact_type.lower() not in artifact_types:
                         available_types = ", ".join(artifact_types)
                         await interaction.response.send_message(f"❌ **Invalid Artifact Type**\nAvailable types: `{available_types}`")
                         return
                     
                     # Validate rarity
                     valid_rarities = ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]
                     if rarity.lower() not in valid_rarities:
                         available_rarities = ", ".join(valid_rarities)
                         await interaction.response.send_message(f"❌ **Invalid Rarity**\nAvailable rarities: `{available_rarities}`")
                         return
                     
                     # Generate the artifact
                     item = generate_artifact(artifact_type.lower(), rarity.lower())
                     
                     # Add to user's inventory using the old system for compatibility
                     user_id = user.id
                     meta = get_user_meta(user_id)
                     if "inventory" not in meta:
                         meta["inventory"] = []
                     meta["inventory"].append(item)
                     set_user_meta(user_id, meta)
                     
                     # Create success embed
                     rarity_emoji = RARITY_EMOJI.get(rarity.lower(), "⚪")
                     embed = discord.Embed(
                         title="✅ Artifact Added!",
                         description=f"Successfully added {rarity_emoji} **{item['name']}** to {user.mention}'s inventory",
                         color=0x2ecc71
                     )
                     embed.add_field(name="✨ Abilities", value=", ".join(item["abilities"]), inline=True)
                     embed.add_field(name="💰 Value", value=f"{MONEY_ICON} {item['value']:,}", inline=True)
                     embed.add_field(name="👤 User", value=user.mention, inline=True)
                     embed.add_field(name="👑 Admin", value=interaction.user.mention, inline=True)
                     embed.set_footer(text=f"Artifact added to {user.display_name}'s inventory")
                     await interaction.response.send_message(embed=embed)
                     
                 except Exception as e:
                     await interaction.response.send_message(f"❌ **Error adding artifact**: {str(e)}")
                     print(f"Artifact add error: {e}")
             
             # Enhanced inventory add for materials (HIDDEN)
             @paired_bot.tree.command(name="admin_inventory_add_material", description="Add material to user inventory (Admin only)")
             @app_commands.describe(
                 user="User to add material to",
                 material_name="Name of the material"
             )
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_inventory_add_material(interaction: discord.Interaction, user: discord.Member, material_name: str):
                 """Add material to inventory"""
                 try:
                     # Add material to user's inventory using the old system for compatibility
                     user_id = user.id
                     meta = get_user_meta(user_id)
                     if "inventory" not in meta:
                         meta["inventory"] = []
                     meta["inventory"].append(material_name)
                     set_user_meta(user_id, meta)
                     
                     # Create success embed
                     embed = discord.Embed(
                         title="✅ Material Added!",
                         description=f"Successfully added **{material_name}** to {user.mention}'s inventory",
                         color=0x2ecc71
                     )
                     embed.add_field(name="📦 Item", value=material_name, inline=True)
                     embed.add_field(name="📊 Type", value="Material", inline=True)
                     embed.add_field(name="👤 User", value=user.mention, inline=True)
                     embed.add_field(name="👑 Admin", value=interaction.user.mention, inline=True)
                     embed.set_footer(text=f"Material added to {user.display_name}'s inventory")
                     await interaction.response.send_message(embed=embed)
                     
                 except Exception as e:
                     await interaction.response.send_message(f"❌ **Error adding material**: {str(e)}")
                     print(f"Material add error: {e}")
             
             @paired_bot.tree.command(name="admin_inventory_clear", description="Clear user inventory (Admin only)")
             @app_commands.describe(user="User to clear inventory for")
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_inventory_clear(interaction: discord.Interaction, user: discord.Member):
                 """Clear user inventory directly"""
                 try:
                     user_id = user.id
                     meta = get_user_meta(user_id)
                     meta["inventory"] = []
                     set_user_meta(user_id, meta)
                     
                     embed = discord.Embed(
                         title="🗑️ Inventory Cleared!",
                         description=f"Successfully cleared {user.mention}'s inventory",
                         color=0xe74c3c
                     )
                     embed.add_field(name="👤 User", value=user.mention, inline=True)
                     embed.add_field(name="👑 Admin", value=interaction.user.mention, inline=True)
                     embed.set_footer(text=f"Inventory cleared by {interaction.user.display_name}")
                     await interaction.response.send_message(embed=embed)
                 except Exception as e:
                     await interaction.response.send_message(f"❌ **Error clearing inventory**: {str(e)}")
                     print(f"Inventory clear error: {e}")
             
             @paired_bot.tree.command(name="admin_inventory_remove", description="Remove specific item from user inventory (Admin only)")
             @app_commands.describe(
                 user="User to remove item from", 
                 item_name="Item name to remove (with autocomplete)"
             )
             @app_commands.autocomplete(item_name=user_inventory_autocomplete)
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_inventory_remove(interaction: discord.Interaction, user: discord.Member, item_name: str):
                 """Remove specific item from user inventory directly"""
                 try:
                     user_id = user.id
                     meta = get_user_meta(user_id)
                     if "inventory" not in meta:
                         meta["inventory"] = []
                     
                     # Find and remove the item
                     original_length = len(meta["inventory"])
                     meta["inventory"] = [item for item in meta["inventory"] if item.get('name', '') != item_name]
                     
                     if len(meta["inventory"]) < original_length:
                         set_user_meta(user_id, meta)
                         
                         embed = discord.Embed(
                             title="✅ Item Removed!",
                             description=f"Successfully removed **{item_name}** from {user.mention}'s inventory",
                             color=0x2ecc71
                         )
                         embed.add_field(name="📦 Item", value=item_name, inline=True)
                         embed.add_field(name="👤 User", value=user.mention, inline=True)
                         embed.add_field(name="👑 Admin", value=interaction.user.mention, inline=True)
                         embed.set_footer(text=f"Item removed by {interaction.user.display_name}")
                         await interaction.response.send_message(embed=embed)
                     else:
                         await interaction.response.send_message(f"❌ **Item not found**: Could not find `{item_name}` in {user.mention}'s inventory")
                 except Exception as e:
                     await interaction.response.send_message(f"❌ **Error removing item**: {str(e)}")
                     print(f"Inventory remove error: {e}")
             
             @paired_bot.tree.command(name="admin_inventory_view", description="View user inventory (Admin only)")
             @app_commands.describe(user="User to view inventory for")
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_inventory_view(interaction: discord.Interaction, user: discord.Member):
                 """View user inventory directly"""
                 try:
                     user_id = user.id
                     meta = get_user_meta(user_id)
                     inventory = meta.get("inventory", [])
                     
                     if not inventory:
                         embed = discord.Embed(
                             title="📦 Empty Inventory",
                             description=f"{user.mention} has no items in their inventory",
                             color=0x95a5a6
                         )
                         await interaction.response.send_message(embed=embed)
                         return
                     
                     # Group items by type
                     weapons = [item for item in inventory if item.get('type') == 'weapon']
                     armors = [item for item in inventory if item.get('type') == 'armor']
                     artifacts = [item for item in inventory if item.get('type') == 'artifact']
                     materials = [item for item in inventory if item.get('type') == 'material']
                     
                     embed = discord.Embed(
                         title=f"📦 {user.display_name}'s Inventory",
                         description=f"Total items: {len(inventory)}",
                         color=0x3498db
                     )
                     
                     if weapons:
                         weapon_text = "\n".join([f"⚔️ {item['name']} (+{item.get('damage', 0)} damage)" for item in weapons[:10]])
                         if len(weapons) > 10:
                             weapon_text += f"\n... and {len(weapons) - 10} more weapons"
                         embed.add_field(name="⚔️ Weapons", value=weapon_text, inline=False)
                     
                     if armors:
                         armor_text = "\n".join([f"🛡️ {item['name']} (+{item.get('health', 0)} health)" for item in armors[:10]])
                         if len(armors) > 10:
                             armor_text += f"\n... and {len(armors) - 10} more armors"
                         embed.add_field(name="🛡️ Armors", value=armor_text, inline=False)
                     
                     if artifacts:
                         artifact_text = "\n".join([f"🔮 {item['name']}" for item in artifacts[:10]])
                         if len(artifacts) > 10:
                             artifact_text += f"\n... and {len(artifacts) - 10} more artifacts"
                         embed.add_field(name="🔮 Artifacts", value=artifact_text, inline=False)
                     
                     if materials:
                         material_text = "\n".join([f"📦 {item['name']}" for item in materials[:10]])
                         if len(materials) > 10:
                             material_text += f"\n... and {len(materials) - 10} more materials"
                         embed.add_field(name="📦 Materials", value=material_text, inline=False)
                     
                     embed.set_footer(text=f"Requested by {interaction.user.display_name}")
                     await interaction.response.send_message(embed=embed)
                 except Exception as e:
                     await interaction.response.send_message(f"❌ **Error viewing inventory**: {str(e)}")
                     print(f"Inventory view error: {e}")
             
             # Sect Management Commands (HIDDEN)
             @paired_bot.hybrid_command(name="admin_sect_delete", description="Delete ANY sect (Admin only)", hidden=True)
             @app_commands.describe(sect_name="Sect name to delete")
             @app_commands.autocomplete(sect_name=sect_autocomplete)
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_sect_delete(ctx: commands.Context, sect_name: str):
                 """Delete sect directly"""
                 try:
                     import json
                     import os
                     
                     sect_file = "data/sects.json"
                     if not os.path.exists(sect_file):
                         await ctx.send("❌ **No sects file found**")
                         return
                     
                     with open(sect_file, 'r') as f:
                         sects = json.load(f)
                     
                     if sect_name not in sects:
                         await ctx.send(f"❌ **Sect not found**: `{sect_name}`")
                         return
                     
                     del sects[sect_name]
                     
                     with open(sect_file, 'w') as f:
                         json.dump(sects, f, indent=2)
                     
                     embed = discord.Embed(
                         title="🗑️ Sect Deleted!",
                         description=f"Successfully deleted sect **{sect_name}**",
                         color=0xe74c3c
                     )
                     embed.add_field(name="👑 Admin", value=ctx.author.mention, inline=True)
                     embed.set_footer(text=f"Sect deleted by {ctx.author.display_name}")
                     await ctx.send(embed=embed)
                     
                 except Exception as e:
                     await ctx.send(f"❌ **Error deleting sect**: {str(e)}")
                     print(f"Sect delete error: {e}")
             
             @paired_bot.hybrid_command(name="admin_sect_kick", description="Kick user from ANY sect (Admin only)", hidden=True)
             @app_commands.describe(user="User to kick", sect_name="Sect name")
             @app_commands.autocomplete(sect_name=sect_autocomplete)
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_sect_kick(ctx: commands.Context, user: discord.Member, sect_name: str):
                 """Kick user from sect directly"""
                 try:
                     user_id = user.id
                     meta = get_user_meta(user_id)
                     
                     if "sect" in meta and meta["sect"] == sect_name:
                         meta["sect"] = None
                         set_user_meta(user_id, meta)
                         
                         embed = discord.Embed(
                             title="👢 User Kicked!",
                             description=f"Successfully kicked {user.mention} from sect **{sect_name}**",
                             color=0xe67e22
                         )
                         embed.add_field(name="👤 User", value=user.mention, inline=True)
                         embed.add_field(name="🏛️ Sect", value=sect_name, inline=True)
                         embed.add_field(name="👑 Admin", value=ctx.author.mention, inline=True)
                         embed.set_footer(text=f"User kicked by {ctx.author.display_name}")
                         await ctx.send(embed=embed)
                     else:
                         await ctx.send(f"❌ **User not in sect**: {user.mention} is not in sect `{sect_name}`")
                         
                 except Exception as e:
                     await ctx.send(f"❌ **Error kicking user**: {str(e)}")
                     print(f"Sect kick error: {e}")
             
             @paired_bot.hybrid_command(name="admin_sect_info", description="View detailed info of ANY sect (Admin only)", hidden=True)
             @app_commands.describe(sect_name="Sect name to view")
             @app_commands.autocomplete(sect_name=sect_autocomplete)
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_sect_info(ctx: commands.Context, sect_name: str):
                 """View sect info directly"""
                 try:
                     import json
                     import os
                     
                     sect_file = "data/sects.json"
                     if not os.path.exists(sect_file):
                         await ctx.send("❌ **No sects file found**")
                         return
                     
                     with open(sect_file, 'r') as f:
                         sects = json.load(f)
                     
                     if sect_name not in sects:
                         await ctx.send(f"❌ **Sect not found**: `{sect_name}`")
                         return
                     
                     sect_data = sects[sect_name]
                     
                     embed = discord.Embed(
                         title=f"🏛️ {sect_name} Info",
                         description=f"Detailed information about sect **{sect_name}**",
                         color=0x3498db
                     )
                     
                     embed.add_field(name="📊 Level", value=sect_data.get("level", 1), inline=True)
                     embed.add_field(name="⭐ XP", value=f"{sect_data.get('xp', 0):,}", inline=True)
                     embed.add_field(name="💰 Treasury", value=f"{sect_data.get('treasury', 0):,}", inline=True)
                     
                     embed.set_footer(text=f"Requested by {ctx.author.display_name}")
                     await ctx.send(embed=embed)
                     
                 except Exception as e:
                     await ctx.send(f"❌ **Error viewing sect**: {str(e)}")
                     print(f"Sect info error: {e}")
             
             @paired_bot.hybrid_command(name="admin_sect_set_level", description="Set sect level directly (Admin only)", hidden=True)
             @app_commands.describe(sect_name="Sect name", level="Level to set (1-100)")
             @app_commands.autocomplete(sect_name=sect_autocomplete)
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_sect_set_level(ctx: commands.Context, sect_name: str, level: int):
                 """Set sect level directly"""
                 try:
                     if level < 1 or level > 100:
                         await ctx.send("❌ **Invalid level**: Level must be between 1 and 100")
                         return
                     
                     import json
                     import os
                     
                     sect_file = "data/sects.json"
                     if not os.path.exists(sect_file):
                         await ctx.send("❌ **No sects file found**")
                         return
                     
                     with open(sect_file, 'r') as f:
                         sects = json.load(f)
                     
                     if sect_name not in sects:
                         await ctx.send(f"❌ **Sect not found**: `{sect_name}`")
                         return
                     
                     old_level = sects[sect_name].get("level", 1)
                     sects[sect_name]["level"] = level
                     
                     with open(sect_file, 'w') as f:
                         json.dump(sects, f, indent=2)
                     
                     embed = discord.Embed(
                         title="📊 Sect Level Updated!",
                         description=f"Successfully updated sect **{sect_name}** level",
                         color=0x2ecc71
                     )
                     embed.add_field(name="🏛️ Sect", value=sect_name, inline=True)
                     embed.add_field(name="📈 Level", value=f"{old_level} → {level}", inline=True)
                     embed.add_field(name="👑 Admin", value=ctx.author.mention, inline=True)
                     embed.set_footer(text=f"Level updated by {ctx.author.display_name}")
                     await ctx.send(embed=embed)
                     
                 except Exception as e:
                     await ctx.send(f"❌ **Error setting sect level**: {str(e)}")
                     print(f"Sect level error: {e}")
             
             @paired_bot.hybrid_command(name="admin_sect_reset", description="Reset sect to level 1 (⚠️ DESTRUCTIVE)", hidden=True)
             @app_commands.describe(sect_name="Sect name to reset")
             @app_commands.autocomplete(sect_name=sect_autocomplete)
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_sect_reset(ctx: commands.Context, sect_name: str):
                 """Reset sect to level 1 directly"""
                 try:
                     import json
                     import os
                     
                     sect_file = "data/sects.json"
                     if not os.path.exists(sect_file):
                         await ctx.send("❌ **No sects file found**")
                         return
                     
                     with open(sect_file, 'r') as f:
                         sects = json.load(f)
                     
                     if sect_name not in sects:
                         await ctx.send(f"❌ **Sect not found**: `{sect_name}`")
                         return
                     
                     old_level = sects[sect_name].get("level", 1)
                     old_xp = sects[sect_name].get("xp", 0)
                     
                     sects[sect_name]["level"] = 1
                     sects[sect_name]["xp"] = 0
                     sects[sect_name]["upgrades"] = {}
                     sects[sect_name]["sect_shop"] = {}
                     
                     with open(sect_file, 'w') as f:
                         json.dump(sects, f, indent=2)
                     
                     embed = discord.Embed(
                         title="🔄 Sect Reset Complete!",
                         description=f"Successfully reset sect **{sect_name}** to level 1",
                         color=0xe67e22
                     )
                     embed.add_field(name="🏛️ Sect", value=sect_name, inline=True)
                     embed.add_field(name="📊 Reset", value=f"Level: {old_level} → 1\nXP: {old_xp:,} → 0", inline=True)
                     embed.add_field(name="👑 Admin", value=ctx.author.mention, inline=True)
                     embed.set_footer(text=f"Sect reset by {ctx.author.display_name}")
                     await ctx.send(embed=embed)
                     
                 except Exception as e:
                     await ctx.send(f"❌ **Error resetting sect**: {str(e)}")
                     print(f"Sect reset error: {e}")
             
             # Set Rerolls Command (HIDDEN)
             @paired_bot.tree.command(name="admin_set_rerolls", description="Set immortal art rerolls for user (Admin only)")
             @app_commands.describe(
                 user="User to set rerolls for",
                 rerolls="Number of rerolls to set"
             )
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_set_rerolls(interaction: discord.Interaction, user: discord.Member, rerolls: int):
                 """Set immortal art rerolls for user directly"""
                 try:
                     if rerolls < 0:
                         await interaction.response.send_message("❌ **Invalid Rerolls**: Rerolls cannot be negative.")
                         return
                     
                     # Get user data using the same system as other admin commands
                     user_id = user.id
                     meta = get_user_meta(user_id)
                     
                     if "immortal_arts" not in meta:
                         meta["immortal_arts"] = {
                             "slots": [None, None, None],
                             "rerolls": rerolls,
                             "unlocked_slots": 1
                         }
                     else:
                         meta["immortal_arts"]["rerolls"] = rerolls
                     
                     # Save the changes
                     if set_user_meta(user_id, meta):
                         embed = discord.Embed(
                             title="🎲 Rerolls Set Successfully!",
                             description=f"Set {user.mention}'s immortal art rerolls to **{rerolls}**",
                             color=0x9b59b6
                         )
                         embed.add_field(name="👤 User", value=user.mention, inline=True)
                         embed.add_field(name="🎲 New Rerolls", value=rerolls, inline=True)
                         embed.add_field(name="👑 Admin", value=interaction.user.mention, inline=True)
                         embed.set_footer(text=f"Rerolls set by {interaction.user.display_name}")
                         await interaction.response.send_message(embed=embed)
                     else:
                         await interaction.response.send_message("❌ **Error**: Failed to save rerolls. Please try again.")
                         
                 except Exception as e:
                     await interaction.response.send_message(f"❌ **Error setting rerolls**: {str(e)}")
                     print(f"Set rerolls error: {e}")
             
             # Set User Attributes Command (HIDDEN)
             @paired_bot.tree.command(name="admin_set_attributes", description="Set user attributes (Admin only)")
             @app_commands.describe(
                 user="User to set attributes for",
                 strength="Strength value (0-1000)",
                 defence="Defence value (0-1000)",
                 longevity="Longevity value (0-1000)",
                 luck="Luck value (0-1000)"
             )
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_set_attributes(interaction: discord.Interaction, user: discord.Member, strength: int = None, defence: int = None, longevity: int = None, luck: int = None):
                 """Set user attributes directly"""
                 try:
                     # Validate input values
                     if strength is not None and (strength < 0 or strength > 1000):
                         await interaction.response.send_message("❌ **Invalid Strength**: Must be between 0-1000")
                         return
                     if defence is not None and (defence < 0 or defence > 1000):
                         await interaction.response.send_message("❌ **Invalid Defence**: Must be between 0-1000")
                         return
                     if longevity is not None and (longevity < 0 or longevity > 1000):
                         await interaction.response.send_message("❌ **Invalid Longevity**: Must be between 0-1000")
                         return
                     if luck is not None and (luck < 0 or luck > 1000):
                         await interaction.response.send_message("❌ **Invalid Luck**: Must be between 0-1000")
                         return
                     
                     # Check if at least one attribute is provided
                     if all(attr is None for attr in [strength, defence, longevity, luck]):
                         await interaction.response.send_message("❌ **No Attributes**: Please specify at least one attribute to set")
                         return
                     
                     user_id = user.id
                     meta = get_user_meta(user_id)
                     
                     # Ensure attributes exist
                     if "attributes" not in meta:
                         meta["attributes"] = {"strength": 0, "defence": 0, "longevity": 0, "luck": 0}
                     
                     # Track changes
                     changes_made = []
                     original_attributes = meta["attributes"].copy()
                     
                     # Update attributes if provided
                     if strength is not None:
                         meta["attributes"]["strength"] = strength
                         changes_made.append(f"Strength: {original_attributes.get('strength', 0)} → {strength}")
                     
                     if defence is not None:
                         meta["attributes"]["defence"] = defence
                         changes_made.append(f"Defence: {original_attributes.get('defence', 0)} → {defence}")
                     
                     if longevity is not None:
                         meta["attributes"]["longevity"] = longevity
                         changes_made.append(f"Longevity: {original_attributes.get('longevity', 0)} → {longevity}")
                     
                     if luck is not None:
                         meta["attributes"]["luck"] = luck
                         changes_made.append(f"Luck: {original_attributes.get('luck', 0)} → {luck}")
                     
                     # Save changes
                     if set_user_meta(user_id, meta):
                         # Create success embed
                         embed = discord.Embed(
                             title="✅ Attributes Set Successfully!",
                             description=f"Updated attributes for {user.mention}",
                             color=0x2ecc71
                         )
                         
                         # Add change details
                         changes_text = "\n".join([f"• {change}" for change in changes_made])
                         embed.add_field(name="📝 Changes Made", value=changes_text, inline=False)
                         
                         # Add current attributes
                         current_attrs = meta["attributes"]
                         embed.add_field(name="💪 Current Attributes", value=(
                             f"**Strength:** {current_attrs['strength']}\n"
                             f"**Defence:** {current_attrs['defence']}\n"
                             f"**Longevity:** {current_attrs['longevity']}\n"
                             f"**Luck:** {current_attrs['luck']}"
                         ), inline=False)
                         
                         embed.add_field(name="👤 User", value=user.mention, inline=True)
                         embed.add_field(name="👑 Admin", value=interaction.user.mention, inline=True)
                         embed.set_footer(text=f"Attributes set by {interaction.user.display_name}")
                         
                         await interaction.response.send_message(embed=embed)
                     else:
                         await interaction.response.send_message("❌ **Error**: Failed to save attributes. Please try again.")
                         
                 except Exception as e:
                     await interaction.response.send_message(f"❌ **Error setting attributes**: {str(e)}")
                     print(f"Set attributes error: {e}")
             
             # Store Item Editor Command (HIDDEN)
             @paired_bot.tree.command(name="admin_edit_store_item", description="Edit store item properties (Admin only)")
             @app_commands.describe(
                 item_name="Name of the store item to edit",
                 new_name="New name for the item (optional)",
                 new_rarity="New rarity level (optional)",
                 new_effect="New effect description (optional)",
                 new_value="New value in coins (optional)"
             )
             @app_commands.autocomplete(
                 item_name=store_item_autocomplete,
                 new_rarity=enhanced_rarity_autocomplete
             )
             @commands.has_permissions(administrator=True)
             async def hybrid_admin_edit_store_item(interaction: discord.Interaction, item_name: str, new_name: str = None, new_rarity: str = None, new_effect: str = None, new_value: int = None):
                 """Edit store item properties directly"""
                 try:
                     import json
                     import os
                     
                     store_file = "data/store.json"
                     if not os.path.exists(store_file):
                         await interaction.response.send_message("❌ **Store file not found**")
                         return
                     
                     # Load current store data
                     with open(store_file, 'r') as f:
                         store_data = json.load(f)
                     
                     if item_name not in store_data:
                         await interaction.response.send_message(f"❌ **Item not found**: `{item_name}`")
                         return
                     
                     # Get current item data
                     current_item = store_data[item_name]
                     original_item = current_item.copy()
                     
                     # Update fields if provided
                     changes_made = []
                     if new_name and new_name != item_name:
                         if new_name in store_data:
                             await interaction.response.send_message(f"❌ **Name conflict**: Item `{new_name}` already exists")
                             return
                         
                         # Remove old entry and create new one
                         del store_data[item_name]
                         store_data[new_name] = current_item
                         changes_made.append(f"Name: `{item_name}` → `{new_name}`")
                         item_name = new_name  # Update for display
                     
                     if new_rarity and new_rarity.lower() in ["common", "uncommon", "rare", "epic", "legendary", "mythic", "divine"]:
                         current_item["rarity"] = new_rarity.lower()
                         changes_made.append(f"Rarity: `{original_item.get('rarity', 'unknown')}` → `{new_rarity.lower()}`")
                     elif new_rarity:
                         await interaction.response.send_message(f"❌ **Invalid rarity**: `{new_rarity}`. Valid options: common, uncommon, rare, epic, legendary, mythic, divine")
                         return
                     
                     if new_effect is not None:
                         current_item["effect"] = new_effect
                         changes_made.append(f"Effect: `{original_item.get('effect', 'none')}` → `{new_effect}`")
                     
                     if new_value is not None and new_value >= 0:
                         current_item["value"] = new_value
                         changes_made.append(f"Value: `{original_item.get('value', 0)}` → `{new_value}`")
                     elif new_value is not None and new_value < 0:
                         await interaction.response.send_message("❌ **Invalid value**: Value cannot be negative")
                         return
                     
                     # Save updated store data
                     with open(store_file, 'w') as f:
                         json.dump(store_data, f, indent=2)
                     
                     if changes_made:
                         # Create success embed
                         embed = discord.Embed(
                             title="✅ Store Item Updated!",
                             description=f"Successfully updated **{item_name}** in the store",
                             color=0x2ecc71
                         )
                         
                         # Add change details
                         changes_text = "\n".join([f"• {change}" for change in changes_made])
                         embed.add_field(name="📝 Changes Made", value=changes_text, inline=False)
                         
                         # Add current item info
                         current_rarity = current_item.get("rarity", "unknown")
                         rarity_emoji = RARITY_EMOJI.get(current_rarity, "⚪")
                         embed.add_field(name="🎯 Current Item", value=f"{rarity_emoji} **{item_name}**", inline=True)
                         embed.add_field(name="💰 Value", value=f"{MONEY_ICON} {current_item.get('value', 0):,}", inline=True)
                         embed.add_field(name="✨ Effect", value=current_item.get("effect", "No effect"), inline=True)
                         
                         embed.add_field(name="👑 Admin", value=interaction.user.mention, inline=True)
                         embed.set_footer(text=f"Item updated by {interaction.user.display_name}")
                         
                         await interaction.response.send_message(embed=embed)
                     else:
                         await interaction.response.send_message("ℹ️ **No changes made**: All provided values are the same as current values")
                         
                 except Exception as e:
                     await interaction.response.send_message(f"❌ **Error updating store item**: {str(e)}")
                     print(f"Store item edit error: {e}")
             
             def start_primary():
                 print("Starting primary bot...")
                 
                 @bot.event
                 async def on_ready():
                     try:
                         print("Primary bot is ready!")
                         synced = await bot.tree.sync()
                         print(f"Synced {len(synced)} command(s) [primary]")
                     except Exception as e:
                         print(f"Sync error [primary]: {e}")
 
                     @bot.tree.command(name="ping_primary", description="Ping from primary bot")
                     async def ping_primary(interaction: discord.Interaction):
                         await interaction.response.send_message("Pong from primary!", ephemeral=True)
 
                 print("Primary bot starting with token...")
                 bot.run(TOKEN)

             def start_secondary():
                 print("Starting secondary bot...")
                 assert paired_bot is not None
                 
                 @paired_bot.event
                 async def on_ready():
                     try:
                         synced = await paired_bot.tree.sync()
                         print(f"Synced {len(synced)} command(s) [secondary]")
                         
                         # Debug: List all commands in the tree
                         all_commands = paired_bot.tree.get_commands()
                         print(f"Secondary bot commands: {[cmd.name for cmd in all_commands]}")
                         
                     except Exception as e:
                         print(f"Sync error [secondary]: {e}")

                     # Ensure admin prefix commands are available only here
                     try:
                         prepare_secondary_admin_prefix_commands()
                     except Exception as e2:
                         print(f"Failed to mirror admin prefix commands on secondary: {e2}")

                 @paired_bot.tree.command(name="ping_secondary", description="Ping from secondary bot")
                 async def ping_secondary(interaction: discord.Interaction):
                     await interaction.response.send_message("Pong from secondary!", ephemeral=True)
                 
                 # Test admin command to see if it works
                 @paired_bot.tree.command(name="test_admin", description="Test admin command")
                 @commands.has_permissions(administrator=True)
                 async def test_admin(interaction: discord.Interaction):
                     await interaction.response.send_message("Admin test command works!", ephemeral=True)

                 # Helper function to execute admin commands
                 async def execute_admin_command(ctx: commands.Context, command_name: str, *args):
                     if ctx.bot is not paired_bot:
                         await ctx.send("Use this on the secondary bot.")
                         return
                     
                     # Build the command string
                     content = f"?{command_name} {' '.join(args)}".strip()
                     
                     try:
                         # Create a fake message to process
                         fake_message = ctx.message
                         fake_message.content = content
                         
                         # Execute the command on the primary bot
                         await bot.process_commands(fake_message)
                         
                         # Send confirmation if it's a slash command
                         if hasattr(ctx, "interaction") and ctx.interaction and not ctx.interaction.response.is_done():
                             await ctx.interaction.response.send_message(f"Executed: {command_name}", ephemeral=True)
                     except Exception as e:
                         await ctx.send(f"Execution failed: {e}")
                 
                 # Admin commands use autocomplete functions defined in global scope
                 
                 print("Secondary bot starting with token...")
                 paired_bot.run(TOKEN_SECONDARY)  # type: ignore[arg-type]

             def run_both():
                 print("Starting both bots concurrently...")
                 # Use threading to run both bots simultaneously
                 import threading
                 
                 # Start primary bot in a thread
                 primary_thread = threading.Thread(target=start_primary, daemon=True)
                 primary_thread.start()
                 
                 # Start secondary bot in main thread
                 start_secondary()

             run_both()
         else:
             bot.run(TOKEN)
    except Exception as e:
        print(f"Bot crashed with error: {e}")
        logging.error(f"Bot crashed with error: {e}", exc_info=True)
        import time
        time.sleep(5)
        raise
